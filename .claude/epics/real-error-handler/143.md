# Task 143: ErrorHandler Integration

## Metadata
```yaml
created: 2025-09-26T13:56:25Z
priority: high
size: M
estimated_hours: 12
dependencies: []
parallel: false
status: pending
```

## Overview
Wire the existing ErrorRecovery.js system into the core game systems to provide comprehensive error handling and recovery capabilities. This foundational task enables error classification, automatic recovery, and circuit breaker patterns throughout the application.

## Acceptance Criteria

### 1. Core Integration (MUST)
- [ ] Create GameErrorHandler.js that wraps ErrorRecovery.js for game-specific functionality
- [ ] Integrate ErrorRecovery into Game.js initialization sequence
- [ ] Wire error handlers into existing core systems:
  - [ ] SaveManager.js error handling
  - [ ] CP progression system error handling
  - [ ] Resource system error handling
  - [ ] UI component error boundaries

### 2. Game-Specific Error Strategies (MUST)
- [ ] Register cultivation-game specific error recovery strategies:
  - [ ] SAVE_CORRUPTION: Fallback to checkpoint + notification
  - [ ] CP_CALCULATION_ERROR: Reset to safe state + recalculate
  - [ ] RESOURCE_OVERFLOW: Cap values + log warning
  - [ ] UI_RENDER_ERROR: Graceful degradation + retry
- [ ] Configure circuit breakers for critical game operations:
  - [ ] Save operations (max 3 failures, 30s timeout)
  - [ ] CP calculations (max 5 failures, 10s timeout)
  - [ ] Resource updates (max 10 failures, 5s timeout)

### 3. Error Context Enhancement (MUST)
- [ ] Extend error context with game-specific data:
  - [ ] Player level and progression state
  - [ ] Current cultivation stage
  - [ ] Active systems and their states
  - [ ] Performance metrics (FPS, memory usage)
- [ ] Implement error fingerprinting for duplicate detection
- [ ] Add telemetry hooks for error tracking

### 4. Integration Testing (MUST)
- [ ] Create comprehensive test suite using Playwright MCP:
  - [ ] Test error recovery in save corruption scenarios
  - [ ] Test circuit breaker behavior under repeated failures
  - [ ] Test fallback mechanisms in offline scenarios
  - [ ] Test memory error recovery and cleanup
- [ ] Validate error recovery doesn't break game state integrity
- [ ] Test error notification delivery to players

### 5. Performance Requirements (MUST)
- [ ] Error handling adds <5ms overhead to normal operations
- [ ] Memory footprint of error system <1MB
- [ ] Error logs automatically rotate (max 1000 entries)
- [ ] Circuit breaker state persists across page reloads

## Implementation Details

### Files to Create/Modify
1. **Create**: `js/core/GameErrorHandler.js` - Main integration wrapper
2. **Modify**: `js/Game.js` - Add error handler initialization
3. **Modify**: `js/core/SaveManager.js` - Add error recovery integration
4. **Modify**: Core progression files - Add error boundaries
5. **Create**: `tests/errorHandling.test.js` - Comprehensive test suite

### Key Integration Points
```javascript
// In Game.js initialization
this.errorHandler = new GameErrorHandler();
this.errorHandler.initialize(this);

// In SaveManager.js
try {
  await this.saveData(key, data);
} catch (error) {
  return await this.game.errorHandler.recover(error, {
    operation: 'save',
    key,
    dataSize: JSON.stringify(data).length
  });
}
```

### Error Classification Extensions
- **CULTIVATION_ERROR**: Progression calculation failures
- **SAVE_SYSTEM_ERROR**: Storage and persistence failures
- **RESOURCE_ERROR**: Resource calculation or overflow errors
- **UI_SYSTEM_ERROR**: Rendering and display failures

## Testing Strategy

### Playwright MCP Tests
1. **Error Injection Tests**: Simulate various error conditions
2. **Recovery Validation**: Verify state integrity post-recovery
3. **Circuit Breaker Tests**: Test failure thresholds and recovery
4. **Performance Tests**: Measure error handling overhead
5. **Integration Tests**: End-to-end error scenarios

### Manual Testing Scenarios
1. Force save corruption and verify recovery
2. Simulate network failures during save operations
3. Test memory pressure scenarios
4. Validate error notifications appear correctly

## Success Metrics
- All existing game functionality continues working
- Error recovery success rate >95% in testing
- No performance degradation in normal operations
- Comprehensive error coverage across all core systems
- Zero critical errors escape to users without recovery attempts

## Dependencies
None - this is the foundation task that other error handling tasks depend on.

## Notes
- This task blocks all other error handling tasks
- Focus on creating ACTUAL working implementations, not stubs
- Use Write/MultiEdit tools to create real files
- Ensure integration preserves existing game functionality
- Test in real browser environment using Playwright MCP
