
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CultivationProgress
 * 
 */
export type CultivationProgress = $Result.DefaultSelection<Prisma.$CultivationProgressPayload>
/**
 * Model CultivationTechnique
 * 
 */
export type CultivationTechnique = $Result.DefaultSelection<Prisma.$CultivationTechniquePayload>
/**
 * Model CharacterTechnique
 * 
 */
export type CharacterTechnique = $Result.DefaultSelection<Prisma.$CharacterTechniquePayload>
/**
 * Model Talent
 * 
 */
export type Talent = $Result.DefaultSelection<Prisma.$TalentPayload>
/**
 * Model CharacterTalent
 * 
 */
export type CharacterTalent = $Result.DefaultSelection<Prisma.$CharacterTalentPayload>
/**
 * Model Bloodline
 * 
 */
export type Bloodline = $Result.DefaultSelection<Prisma.$BloodlinePayload>
/**
 * Model Resources
 * 
 */
export type Resources = $Result.DefaultSelection<Prisma.$ResourcesPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model CombatStats
 * 
 */
export type CombatStats = $Result.DefaultSelection<Prisma.$CombatStatsPayload>
/**
 * Model CombatLog
 * 
 */
export type CombatLog = $Result.DefaultSelection<Prisma.$CombatLogPayload>
/**
 * Model Sect
 * 
 */
export type Sect = $Result.DefaultSelection<Prisma.$SectPayload>
/**
 * Model SectMember
 * 
 */
export type SectMember = $Result.DefaultSelection<Prisma.$SectMemberPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model GameStatistics
 * 
 */
export type GameStatistics = $Result.DefaultSelection<Prisma.$GameStatisticsPayload>
/**
 * Model GameEvent
 * 
 */
export type GameEvent = $Result.DefaultSelection<Prisma.$GameEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CultivationRealm: {
  MORTAL: 'MORTAL',
  QI_REFINING: 'QI_REFINING',
  FOUNDATION_ESTABLISHMENT: 'FOUNDATION_ESTABLISHMENT',
  CORE_FORMATION: 'CORE_FORMATION',
  NASCENT_SOUL: 'NASCENT_SOUL',
  SOUL_TRANSFORMATION: 'SOUL_TRANSFORMATION',
  VOID_REFINEMENT: 'VOID_REFINEMENT',
  BODY_INTEGRATION: 'BODY_INTEGRATION',
  MAHAYANA: 'MAHAYANA',
  TRANSCENDENCE: 'TRANSCENDENCE'
};

export type CultivationRealm = (typeof CultivationRealm)[keyof typeof CultivationRealm]


export const ElementType: {
  FIRE: 'FIRE',
  WATER: 'WATER',
  EARTH: 'EARTH',
  WOOD: 'WOOD',
  METAL: 'METAL',
  LIGHTNING: 'LIGHTNING',
  ICE: 'ICE',
  DARKNESS: 'DARKNESS',
  LIGHT: 'LIGHT'
};

export type ElementType = (typeof ElementType)[keyof typeof ElementType]


export const SpiritualGrade: {
  TRASH: 'TRASH',
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  LEGENDARY: 'LEGENDARY',
  MYTHICAL: 'MYTHICAL'
};

export type SpiritualGrade = (typeof SpiritualGrade)[keyof typeof SpiritualGrade]


export const TechniqueType: {
  BASIC: 'BASIC',
  ADVANCED: 'ADVANCED',
  SUPREME: 'SUPREME',
  DIVINE: 'DIVINE'
};

export type TechniqueType = (typeof TechniqueType)[keyof typeof TechniqueType]


export const TalentType: {
  PASSIVE: 'PASSIVE',
  ACTIVE: 'ACTIVE',
  CONDITIONAL: 'CONDITIONAL'
};

export type TalentType = (typeof TalentType)[keyof typeof TalentType]


export const ItemType: {
  PILL: 'PILL',
  HERB: 'HERB',
  WEAPON: 'WEAPON',
  ARMOR: 'ARMOR',
  ARTIFACT: 'ARTIFACT',
  MATERIAL: 'MATERIAL',
  SCROLL: 'SCROLL',
  TREASURE: 'TREASURE'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const ItemRarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY',
  MYTHICAL: 'MYTHICAL',
  DIVINE: 'DIVINE'
};

export type ItemRarity = (typeof ItemRarity)[keyof typeof ItemRarity]


export const SectRole: {
  LEADER: 'LEADER',
  ELDER: 'ELDER',
  CORE_DISCIPLE: 'CORE_DISCIPLE',
  INNER_DISCIPLE: 'INNER_DISCIPLE',
  OUTER_DISCIPLE: 'OUTER_DISCIPLE'
};

export type SectRole = (typeof SectRole)[keyof typeof SectRole]


export const AchievementCategory: {
  CULTIVATION: 'CULTIVATION',
  COMBAT: 'COMBAT',
  EXPLORATION: 'EXPLORATION',
  SOCIAL: 'SOCIAL',
  COLLECTION: 'COLLECTION',
  SPECIAL: 'SPECIAL'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const CombatResult: {
  WIN: 'WIN',
  LOSS: 'LOSS',
  DRAW: 'DRAW'
};

export type CombatResult = (typeof CombatResult)[keyof typeof CombatResult]


export const GameEventType: {
  CULTIVATION_BREAKTHROUGH: 'CULTIVATION_BREAKTHROUGH',
  ITEM_ACQUIRED: 'ITEM_ACQUIRED',
  COMBAT_COMPLETED: 'COMBAT_COMPLETED',
  ACHIEVEMENT_UNLOCKED: 'ACHIEVEMENT_UNLOCKED',
  SECT_JOINED: 'SECT_JOINED',
  SECT_LEFT: 'SECT_LEFT',
  TALENT_UNLOCKED: 'TALENT_UNLOCKED',
  BLOODLINE_AWAKENED: 'BLOODLINE_AWAKENED'
};

export type GameEventType = (typeof GameEventType)[keyof typeof GameEventType]

}

export type CultivationRealm = $Enums.CultivationRealm

export const CultivationRealm: typeof $Enums.CultivationRealm

export type ElementType = $Enums.ElementType

export const ElementType: typeof $Enums.ElementType

export type SpiritualGrade = $Enums.SpiritualGrade

export const SpiritualGrade: typeof $Enums.SpiritualGrade

export type TechniqueType = $Enums.TechniqueType

export const TechniqueType: typeof $Enums.TechniqueType

export type TalentType = $Enums.TalentType

export const TalentType: typeof $Enums.TalentType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type ItemRarity = $Enums.ItemRarity

export const ItemRarity: typeof $Enums.ItemRarity

export type SectRole = $Enums.SectRole

export const SectRole: typeof $Enums.SectRole

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type CombatResult = $Enums.CombatResult

export const CombatResult: typeof $Enums.CombatResult

export type GameEventType = $Enums.GameEventType

export const GameEventType: typeof $Enums.GameEventType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cultivationProgress`: Exposes CRUD operations for the **CultivationProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CultivationProgresses
    * const cultivationProgresses = await prisma.cultivationProgress.findMany()
    * ```
    */
  get cultivationProgress(): Prisma.CultivationProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cultivationTechnique`: Exposes CRUD operations for the **CultivationTechnique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CultivationTechniques
    * const cultivationTechniques = await prisma.cultivationTechnique.findMany()
    * ```
    */
  get cultivationTechnique(): Prisma.CultivationTechniqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterTechnique`: Exposes CRUD operations for the **CharacterTechnique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterTechniques
    * const characterTechniques = await prisma.characterTechnique.findMany()
    * ```
    */
  get characterTechnique(): Prisma.CharacterTechniqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.talent`: Exposes CRUD operations for the **Talent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Talents
    * const talents = await prisma.talent.findMany()
    * ```
    */
  get talent(): Prisma.TalentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterTalent`: Exposes CRUD operations for the **CharacterTalent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterTalents
    * const characterTalents = await prisma.characterTalent.findMany()
    * ```
    */
  get characterTalent(): Prisma.CharacterTalentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bloodline`: Exposes CRUD operations for the **Bloodline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bloodlines
    * const bloodlines = await prisma.bloodline.findMany()
    * ```
    */
  get bloodline(): Prisma.BloodlineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resources`: Exposes CRUD operations for the **Resources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resources.findMany()
    * ```
    */
  get resources(): Prisma.ResourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combatStats`: Exposes CRUD operations for the **CombatStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombatStats
    * const combatStats = await prisma.combatStats.findMany()
    * ```
    */
  get combatStats(): Prisma.CombatStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combatLog`: Exposes CRUD operations for the **CombatLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombatLogs
    * const combatLogs = await prisma.combatLog.findMany()
    * ```
    */
  get combatLog(): Prisma.CombatLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sect`: Exposes CRUD operations for the **Sect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sects
    * const sects = await prisma.sect.findMany()
    * ```
    */
  get sect(): Prisma.SectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sectMember`: Exposes CRUD operations for the **SectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectMembers
    * const sectMembers = await prisma.sectMember.findMany()
    * ```
    */
  get sectMember(): Prisma.SectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameStatistics`: Exposes CRUD operations for the **GameStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameStatistics
    * const gameStatistics = await prisma.gameStatistics.findMany()
    * ```
    */
  get gameStatistics(): Prisma.GameStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameEvent`: Exposes CRUD operations for the **GameEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameEvents
    * const gameEvents = await prisma.gameEvent.findMany()
    * ```
    */
  get gameEvent(): Prisma.GameEventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Character: 'Character',
    CultivationProgress: 'CultivationProgress',
    CultivationTechnique: 'CultivationTechnique',
    CharacterTechnique: 'CharacterTechnique',
    Talent: 'Talent',
    CharacterTalent: 'CharacterTalent',
    Bloodline: 'Bloodline',
    Resources: 'Resources',
    Item: 'Item',
    InventoryItem: 'InventoryItem',
    CombatStats: 'CombatStats',
    CombatLog: 'CombatLog',
    Sect: 'Sect',
    SectMember: 'SectMember',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    GameStatistics: 'GameStatistics',
    GameEvent: 'GameEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "character" | "cultivationProgress" | "cultivationTechnique" | "characterTechnique" | "talent" | "characterTalent" | "bloodline" | "resources" | "item" | "inventoryItem" | "combatStats" | "combatLog" | "sect" | "sectMember" | "achievement" | "userAchievement" | "gameStatistics" | "gameEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CultivationProgress: {
        payload: Prisma.$CultivationProgressPayload<ExtArgs>
        fields: Prisma.CultivationProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CultivationProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CultivationProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          findFirst: {
            args: Prisma.CultivationProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CultivationProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          findMany: {
            args: Prisma.CultivationProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>[]
          }
          create: {
            args: Prisma.CultivationProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          createMany: {
            args: Prisma.CultivationProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CultivationProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>[]
          }
          delete: {
            args: Prisma.CultivationProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          update: {
            args: Prisma.CultivationProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          deleteMany: {
            args: Prisma.CultivationProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CultivationProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CultivationProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>[]
          }
          upsert: {
            args: Prisma.CultivationProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationProgressPayload>
          }
          aggregate: {
            args: Prisma.CultivationProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCultivationProgress>
          }
          groupBy: {
            args: Prisma.CultivationProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CultivationProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CultivationProgressCountArgs<ExtArgs>
            result: $Utils.Optional<CultivationProgressCountAggregateOutputType> | number
          }
        }
      }
      CultivationTechnique: {
        payload: Prisma.$CultivationTechniquePayload<ExtArgs>
        fields: Prisma.CultivationTechniqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CultivationTechniqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CultivationTechniqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          findFirst: {
            args: Prisma.CultivationTechniqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CultivationTechniqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          findMany: {
            args: Prisma.CultivationTechniqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>[]
          }
          create: {
            args: Prisma.CultivationTechniqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          createMany: {
            args: Prisma.CultivationTechniqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CultivationTechniqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>[]
          }
          delete: {
            args: Prisma.CultivationTechniqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          update: {
            args: Prisma.CultivationTechniqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          deleteMany: {
            args: Prisma.CultivationTechniqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CultivationTechniqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CultivationTechniqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>[]
          }
          upsert: {
            args: Prisma.CultivationTechniqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultivationTechniquePayload>
          }
          aggregate: {
            args: Prisma.CultivationTechniqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCultivationTechnique>
          }
          groupBy: {
            args: Prisma.CultivationTechniqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CultivationTechniqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CultivationTechniqueCountArgs<ExtArgs>
            result: $Utils.Optional<CultivationTechniqueCountAggregateOutputType> | number
          }
        }
      }
      CharacterTechnique: {
        payload: Prisma.$CharacterTechniquePayload<ExtArgs>
        fields: Prisma.CharacterTechniqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterTechniqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterTechniqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          findFirst: {
            args: Prisma.CharacterTechniqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterTechniqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          findMany: {
            args: Prisma.CharacterTechniqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>[]
          }
          create: {
            args: Prisma.CharacterTechniqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          createMany: {
            args: Prisma.CharacterTechniqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterTechniqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>[]
          }
          delete: {
            args: Prisma.CharacterTechniqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          update: {
            args: Prisma.CharacterTechniqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          deleteMany: {
            args: Prisma.CharacterTechniqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterTechniqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterTechniqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>[]
          }
          upsert: {
            args: Prisma.CharacterTechniqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTechniquePayload>
          }
          aggregate: {
            args: Prisma.CharacterTechniqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterTechnique>
          }
          groupBy: {
            args: Prisma.CharacterTechniqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterTechniqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterTechniqueCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterTechniqueCountAggregateOutputType> | number
          }
        }
      }
      Talent: {
        payload: Prisma.$TalentPayload<ExtArgs>
        fields: Prisma.TalentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TalentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TalentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          findFirst: {
            args: Prisma.TalentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TalentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          findMany: {
            args: Prisma.TalentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>[]
          }
          create: {
            args: Prisma.TalentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          createMany: {
            args: Prisma.TalentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TalentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>[]
          }
          delete: {
            args: Prisma.TalentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          update: {
            args: Prisma.TalentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          deleteMany: {
            args: Prisma.TalentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TalentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TalentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>[]
          }
          upsert: {
            args: Prisma.TalentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentPayload>
          }
          aggregate: {
            args: Prisma.TalentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTalent>
          }
          groupBy: {
            args: Prisma.TalentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TalentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TalentCountArgs<ExtArgs>
            result: $Utils.Optional<TalentCountAggregateOutputType> | number
          }
        }
      }
      CharacterTalent: {
        payload: Prisma.$CharacterTalentPayload<ExtArgs>
        fields: Prisma.CharacterTalentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterTalentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterTalentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          findFirst: {
            args: Prisma.CharacterTalentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterTalentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          findMany: {
            args: Prisma.CharacterTalentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>[]
          }
          create: {
            args: Prisma.CharacterTalentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          createMany: {
            args: Prisma.CharacterTalentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterTalentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>[]
          }
          delete: {
            args: Prisma.CharacterTalentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          update: {
            args: Prisma.CharacterTalentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          deleteMany: {
            args: Prisma.CharacterTalentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterTalentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterTalentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>[]
          }
          upsert: {
            args: Prisma.CharacterTalentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterTalentPayload>
          }
          aggregate: {
            args: Prisma.CharacterTalentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterTalent>
          }
          groupBy: {
            args: Prisma.CharacterTalentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterTalentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterTalentCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterTalentCountAggregateOutputType> | number
          }
        }
      }
      Bloodline: {
        payload: Prisma.$BloodlinePayload<ExtArgs>
        fields: Prisma.BloodlineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BloodlineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BloodlineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          findFirst: {
            args: Prisma.BloodlineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BloodlineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          findMany: {
            args: Prisma.BloodlineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>[]
          }
          create: {
            args: Prisma.BloodlineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          createMany: {
            args: Prisma.BloodlineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BloodlineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>[]
          }
          delete: {
            args: Prisma.BloodlineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          update: {
            args: Prisma.BloodlineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          deleteMany: {
            args: Prisma.BloodlineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BloodlineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BloodlineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>[]
          }
          upsert: {
            args: Prisma.BloodlineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodlinePayload>
          }
          aggregate: {
            args: Prisma.BloodlineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBloodline>
          }
          groupBy: {
            args: Prisma.BloodlineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BloodlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BloodlineCountArgs<ExtArgs>
            result: $Utils.Optional<BloodlineCountAggregateOutputType> | number
          }
        }
      }
      Resources: {
        payload: Prisma.$ResourcesPayload<ExtArgs>
        fields: Prisma.ResourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          findFirst: {
            args: Prisma.ResourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          findMany: {
            args: Prisma.ResourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>[]
          }
          create: {
            args: Prisma.ResourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          createMany: {
            args: Prisma.ResourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourcesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>[]
          }
          delete: {
            args: Prisma.ResourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          update: {
            args: Prisma.ResourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          deleteMany: {
            args: Prisma.ResourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourcesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>[]
          }
          upsert: {
            args: Prisma.ResourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcesPayload>
          }
          aggregate: {
            args: Prisma.ResourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResources>
          }
          groupBy: {
            args: Prisma.ResourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourcesCountArgs<ExtArgs>
            result: $Utils.Optional<ResourcesCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      CombatStats: {
        payload: Prisma.$CombatStatsPayload<ExtArgs>
        fields: Prisma.CombatStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombatStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombatStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          findFirst: {
            args: Prisma.CombatStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombatStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          findMany: {
            args: Prisma.CombatStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>[]
          }
          create: {
            args: Prisma.CombatStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          createMany: {
            args: Prisma.CombatStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CombatStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>[]
          }
          delete: {
            args: Prisma.CombatStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          update: {
            args: Prisma.CombatStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          deleteMany: {
            args: Prisma.CombatStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombatStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CombatStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>[]
          }
          upsert: {
            args: Prisma.CombatStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatStatsPayload>
          }
          aggregate: {
            args: Prisma.CombatStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombatStats>
          }
          groupBy: {
            args: Prisma.CombatStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombatStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombatStatsCountArgs<ExtArgs>
            result: $Utils.Optional<CombatStatsCountAggregateOutputType> | number
          }
        }
      }
      CombatLog: {
        payload: Prisma.$CombatLogPayload<ExtArgs>
        fields: Prisma.CombatLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombatLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombatLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          findFirst: {
            args: Prisma.CombatLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombatLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          findMany: {
            args: Prisma.CombatLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          create: {
            args: Prisma.CombatLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          createMany: {
            args: Prisma.CombatLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CombatLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          delete: {
            args: Prisma.CombatLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          update: {
            args: Prisma.CombatLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          deleteMany: {
            args: Prisma.CombatLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombatLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CombatLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>[]
          }
          upsert: {
            args: Prisma.CombatLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatLogPayload>
          }
          aggregate: {
            args: Prisma.CombatLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombatLog>
          }
          groupBy: {
            args: Prisma.CombatLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombatLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombatLogCountArgs<ExtArgs>
            result: $Utils.Optional<CombatLogCountAggregateOutputType> | number
          }
        }
      }
      Sect: {
        payload: Prisma.$SectPayload<ExtArgs>
        fields: Prisma.SectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          findFirst: {
            args: Prisma.SectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          findMany: {
            args: Prisma.SectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>[]
          }
          create: {
            args: Prisma.SectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          createMany: {
            args: Prisma.SectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>[]
          }
          delete: {
            args: Prisma.SectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          update: {
            args: Prisma.SectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          deleteMany: {
            args: Prisma.SectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>[]
          }
          upsert: {
            args: Prisma.SectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectPayload>
          }
          aggregate: {
            args: Prisma.SectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSect>
          }
          groupBy: {
            args: Prisma.SectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectCountArgs<ExtArgs>
            result: $Utils.Optional<SectCountAggregateOutputType> | number
          }
        }
      }
      SectMember: {
        payload: Prisma.$SectMemberPayload<ExtArgs>
        fields: Prisma.SectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          findFirst: {
            args: Prisma.SectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          findMany: {
            args: Prisma.SectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>[]
          }
          create: {
            args: Prisma.SectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          createMany: {
            args: Prisma.SectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>[]
          }
          delete: {
            args: Prisma.SectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          update: {
            args: Prisma.SectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          deleteMany: {
            args: Prisma.SectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>[]
          }
          upsert: {
            args: Prisma.SectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectMemberPayload>
          }
          aggregate: {
            args: Prisma.SectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectMember>
          }
          groupBy: {
            args: Prisma.SectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<SectMemberCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      GameStatistics: {
        payload: Prisma.$GameStatisticsPayload<ExtArgs>
        fields: Prisma.GameStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          findFirst: {
            args: Prisma.GameStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          findMany: {
            args: Prisma.GameStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>[]
          }
          create: {
            args: Prisma.GameStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          createMany: {
            args: Prisma.GameStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>[]
          }
          delete: {
            args: Prisma.GameStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          update: {
            args: Prisma.GameStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.GameStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.GameStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatisticsPayload>
          }
          aggregate: {
            args: Prisma.GameStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameStatistics>
          }
          groupBy: {
            args: Prisma.GameStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<GameStatisticsCountAggregateOutputType> | number
          }
        }
      }
      GameEvent: {
        payload: Prisma.$GameEventPayload<ExtArgs>
        fields: Prisma.GameEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findFirst: {
            args: Prisma.GameEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findMany: {
            args: Prisma.GameEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          create: {
            args: Prisma.GameEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          createMany: {
            args: Prisma.GameEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          delete: {
            args: Prisma.GameEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          update: {
            args: Prisma.GameEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          deleteMany: {
            args: Prisma.GameEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          upsert: {
            args: Prisma.GameEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          aggregate: {
            args: Prisma.GameEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameEvent>
          }
          groupBy: {
            args: Prisma.GameEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameEventCountArgs<ExtArgs>
            result: $Utils.Optional<GameEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    character?: CharacterOmit
    cultivationProgress?: CultivationProgressOmit
    cultivationTechnique?: CultivationTechniqueOmit
    characterTechnique?: CharacterTechniqueOmit
    talent?: TalentOmit
    characterTalent?: CharacterTalentOmit
    bloodline?: BloodlineOmit
    resources?: ResourcesOmit
    item?: ItemOmit
    inventoryItem?: InventoryItemOmit
    combatStats?: CombatStatsOmit
    combatLog?: CombatLogOmit
    sect?: SectOmit
    sectMember?: SectMemberOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    gameStatistics?: GameStatisticsOmit
    gameEvent?: GameEventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    inventory: number
    achievements: number
    gameEvents: number
    combatLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    gameEvents?: boolean | UserCountOutputTypeCountGameEventsArgs
    combatLogs?: boolean | UserCountOutputTypeCountCombatLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCombatLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatLogWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    techniques: number
    talents: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    techniques?: boolean | CharacterCountOutputTypeCountTechniquesArgs
    talents?: boolean | CharacterCountOutputTypeCountTalentsArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountTechniquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTechniqueWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTalentWhereInput
  }


  /**
   * Count Type CultivationTechniqueCountOutputType
   */

  export type CultivationTechniqueCountOutputType = {
    userProgress: number
    characterTechniques: number
  }

  export type CultivationTechniqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | CultivationTechniqueCountOutputTypeCountUserProgressArgs
    characterTechniques?: boolean | CultivationTechniqueCountOutputTypeCountCharacterTechniquesArgs
  }

  // Custom InputTypes
  /**
   * CultivationTechniqueCountOutputType without action
   */
  export type CultivationTechniqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechniqueCountOutputType
     */
    select?: CultivationTechniqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CultivationTechniqueCountOutputType without action
   */
  export type CultivationTechniqueCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultivationProgressWhereInput
  }

  /**
   * CultivationTechniqueCountOutputType without action
   */
  export type CultivationTechniqueCountOutputTypeCountCharacterTechniquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTechniqueWhereInput
  }


  /**
   * Count Type TalentCountOutputType
   */

  export type TalentCountOutputType = {
    characterTalents: number
  }

  export type TalentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterTalents?: boolean | TalentCountOutputTypeCountCharacterTalentsArgs
  }

  // Custom InputTypes
  /**
   * TalentCountOutputType without action
   */
  export type TalentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentCountOutputType
     */
    select?: TalentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TalentCountOutputType without action
   */
  export type TalentCountOutputTypeCountCharacterTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTalentWhereInput
  }


  /**
   * Count Type BloodlineCountOutputType
   */

  export type BloodlineCountOutputType = {
    characters: number
  }

  export type BloodlineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | BloodlineCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * BloodlineCountOutputType without action
   */
  export type BloodlineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodlineCountOutputType
     */
    select?: BloodlineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BloodlineCountOutputType without action
   */
  export type BloodlineCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    inventoryItems: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ItemCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type SectCountOutputType
   */

  export type SectCountOutputType = {
    members: number
  }

  export type SectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SectCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * SectCountOutputType without action
   */
  export type SectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectCountOutputType
     */
    select?: SectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectCountOutputType without action
   */
  export type SectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectMemberWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatar: string | null
    title: string | null
    biography: string | null
    autoSave: boolean | null
    notifications: boolean | null
    soundEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActiveAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatar: string | null
    title: string | null
    biography: string | null
    autoSave: boolean | null
    notifications: boolean | null
    soundEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActiveAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    displayName: number
    avatar: number
    title: number
    biography: number
    autoSave: number
    notifications: number
    soundEnabled: number
    createdAt: number
    updatedAt: number
    lastActiveAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatar?: true
    title?: true
    biography?: true
    autoSave?: true
    notifications?: true
    soundEnabled?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatar?: true
    title?: true
    biography?: true
    autoSave?: true
    notifications?: true
    soundEnabled?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatar?: true
    title?: true
    biography?: true
    autoSave?: true
    notifications?: true
    soundEnabled?: true
    createdAt?: true
    updatedAt?: true
    lastActiveAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar: string | null
    title: string | null
    biography: string | null
    autoSave: boolean
    notifications: boolean
    soundEnabled: boolean
    createdAt: Date
    updatedAt: Date
    lastActiveAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatar?: boolean
    title?: boolean
    biography?: boolean
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
    character?: boolean | User$characterArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    cultivation?: boolean | User$cultivationArgs<ExtArgs>
    combat?: boolean | User$combatArgs<ExtArgs>
    sectMembership?: boolean | User$sectMembershipArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    statistics?: boolean | User$statisticsArgs<ExtArgs>
    gameEvents?: boolean | User$gameEventsArgs<ExtArgs>
    combatLogs?: boolean | User$combatLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatar?: boolean
    title?: boolean
    biography?: boolean
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatar?: boolean
    title?: boolean
    biography?: boolean
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatar?: boolean
    title?: boolean
    biography?: boolean
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActiveAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "displayName" | "avatar" | "title" | "biography" | "autoSave" | "notifications" | "soundEnabled" | "createdAt" | "updatedAt" | "lastActiveAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | User$characterArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    cultivation?: boolean | User$cultivationArgs<ExtArgs>
    combat?: boolean | User$combatArgs<ExtArgs>
    sectMembership?: boolean | User$sectMembershipArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    statistics?: boolean | User$statisticsArgs<ExtArgs>
    gameEvents?: boolean | User$gameEventsArgs<ExtArgs>
    combatLogs?: boolean | User$combatLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs> | null
      resources: Prisma.$ResourcesPayload<ExtArgs> | null
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
      cultivation: Prisma.$CultivationProgressPayload<ExtArgs> | null
      combat: Prisma.$CombatStatsPayload<ExtArgs> | null
      sectMembership: Prisma.$SectMemberPayload<ExtArgs> | null
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      statistics: Prisma.$GameStatisticsPayload<ExtArgs> | null
      gameEvents: Prisma.$GameEventPayload<ExtArgs>[]
      combatLogs: Prisma.$CombatLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      passwordHash: string
      displayName: string
      avatar: string | null
      title: string | null
      biography: string | null
      autoSave: boolean
      notifications: boolean
      soundEnabled: boolean
      createdAt: Date
      updatedAt: Date
      lastActiveAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends User$characterArgs<ExtArgs> = {}>(args?: Subset<T, User$characterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resources<T extends User$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cultivation<T extends User$cultivationArgs<ExtArgs> = {}>(args?: Subset<T, User$cultivationArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    combat<T extends User$combatArgs<ExtArgs> = {}>(args?: Subset<T, User$combatArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sectMembership<T extends User$sectMembershipArgs<ExtArgs> = {}>(args?: Subset<T, User$sectMembershipArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statistics<T extends User$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, User$statisticsArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gameEvents<T extends User$gameEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$gameEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    combatLogs<T extends User$combatLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$combatLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly title: FieldRef<"User", 'String'>
    readonly biography: FieldRef<"User", 'String'>
    readonly autoSave: FieldRef<"User", 'Boolean'>
    readonly notifications: FieldRef<"User", 'Boolean'>
    readonly soundEnabled: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.character
   */
  export type User$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * User.resources
   */
  export type User$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    where?: ResourcesWhereInput
  }

  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * User.cultivation
   */
  export type User$cultivationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    where?: CultivationProgressWhereInput
  }

  /**
   * User.combat
   */
  export type User$combatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    where?: CombatStatsWhereInput
  }

  /**
   * User.sectMembership
   */
  export type User$sectMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    where?: SectMemberWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.statistics
   */
  export type User$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    where?: GameStatisticsWhereInput
  }

  /**
   * User.gameEvents
   */
  export type User$gameEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    cursor?: GameEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * User.combatLogs
   */
  export type User$combatLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    where?: CombatLogWhereInput
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    cursor?: CombatLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    level: number | null
    experience: number | null
    experienceToNext: number | null
    strength: number | null
    agility: number | null
    intelligence: number | null
    constitution: number | null
    perception: number | null
    luck: number | null
    spiritualPurity: number | null
    bloodlineAwakening: number | null
  }

  export type CharacterSumAggregateOutputType = {
    level: number | null
    experience: bigint | null
    experienceToNext: bigint | null
    strength: number | null
    agility: number | null
    intelligence: number | null
    constitution: number | null
    perception: number | null
    luck: number | null
    spiritualPurity: number | null
    bloodlineAwakening: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    realm: $Enums.CultivationRealm | null
    level: number | null
    experience: bigint | null
    experienceToNext: bigint | null
    strength: number | null
    agility: number | null
    intelligence: number | null
    constitution: number | null
    perception: number | null
    luck: number | null
    spiritualElement: $Enums.ElementType | null
    spiritualPurity: number | null
    spiritualGrade: $Enums.SpiritualGrade | null
    bloodlineId: string | null
    bloodlineAwakening: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    realm: $Enums.CultivationRealm | null
    level: number | null
    experience: bigint | null
    experienceToNext: bigint | null
    strength: number | null
    agility: number | null
    intelligence: number | null
    constitution: number | null
    perception: number | null
    luck: number | null
    spiritualElement: $Enums.ElementType | null
    spiritualPurity: number | null
    spiritualGrade: $Enums.SpiritualGrade | null
    bloodlineId: string | null
    bloodlineAwakening: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    realm: number
    level: number
    experience: number
    experienceToNext: number
    strength: number
    agility: number
    intelligence: number
    constitution: number
    perception: number
    luck: number
    spiritualElement: number
    spiritualPurity: number
    spiritualGrade: number
    bloodlineId: number
    bloodlineAwakening: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    level?: true
    experience?: true
    experienceToNext?: true
    strength?: true
    agility?: true
    intelligence?: true
    constitution?: true
    perception?: true
    luck?: true
    spiritualPurity?: true
    bloodlineAwakening?: true
  }

  export type CharacterSumAggregateInputType = {
    level?: true
    experience?: true
    experienceToNext?: true
    strength?: true
    agility?: true
    intelligence?: true
    constitution?: true
    perception?: true
    luck?: true
    spiritualPurity?: true
    bloodlineAwakening?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    level?: true
    experience?: true
    experienceToNext?: true
    strength?: true
    agility?: true
    intelligence?: true
    constitution?: true
    perception?: true
    luck?: true
    spiritualElement?: true
    spiritualPurity?: true
    spiritualGrade?: true
    bloodlineId?: true
    bloodlineAwakening?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    level?: true
    experience?: true
    experienceToNext?: true
    strength?: true
    agility?: true
    intelligence?: true
    constitution?: true
    perception?: true
    luck?: true
    spiritualElement?: true
    spiritualPurity?: true
    spiritualGrade?: true
    bloodlineId?: true
    bloodlineAwakening?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    realm?: true
    level?: true
    experience?: true
    experienceToNext?: true
    strength?: true
    agility?: true
    intelligence?: true
    constitution?: true
    perception?: true
    luck?: true
    spiritualElement?: true
    spiritualPurity?: true
    spiritualGrade?: true
    bloodlineId?: true
    bloodlineAwakening?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    userId: string
    name: string
    realm: $Enums.CultivationRealm
    level: number
    experience: bigint
    experienceToNext: bigint
    strength: number
    agility: number
    intelligence: number
    constitution: number
    perception: number
    luck: number
    spiritualElement: $Enums.ElementType
    spiritualPurity: number
    spiritualGrade: $Enums.SpiritualGrade
    bloodlineId: string | null
    bloodlineAwakening: number
    createdAt: Date
    updatedAt: Date
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    level?: boolean
    experience?: boolean
    experienceToNext?: boolean
    strength?: boolean
    agility?: boolean
    intelligence?: boolean
    constitution?: boolean
    perception?: boolean
    luck?: boolean
    spiritualElement?: boolean
    spiritualPurity?: boolean
    spiritualGrade?: boolean
    bloodlineId?: boolean
    bloodlineAwakening?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
    techniques?: boolean | Character$techniquesArgs<ExtArgs>
    talents?: boolean | Character$talentsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    level?: boolean
    experience?: boolean
    experienceToNext?: boolean
    strength?: boolean
    agility?: boolean
    intelligence?: boolean
    constitution?: boolean
    perception?: boolean
    luck?: boolean
    spiritualElement?: boolean
    spiritualPurity?: boolean
    spiritualGrade?: boolean
    bloodlineId?: boolean
    bloodlineAwakening?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    level?: boolean
    experience?: boolean
    experienceToNext?: boolean
    strength?: boolean
    agility?: boolean
    intelligence?: boolean
    constitution?: boolean
    perception?: boolean
    luck?: boolean
    spiritualElement?: boolean
    spiritualPurity?: boolean
    spiritualGrade?: boolean
    bloodlineId?: boolean
    bloodlineAwakening?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    realm?: boolean
    level?: boolean
    experience?: boolean
    experienceToNext?: boolean
    strength?: boolean
    agility?: boolean
    intelligence?: boolean
    constitution?: boolean
    perception?: boolean
    luck?: boolean
    spiritualElement?: boolean
    spiritualPurity?: boolean
    spiritualGrade?: boolean
    bloodlineId?: boolean
    bloodlineAwakening?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "realm" | "level" | "experience" | "experienceToNext" | "strength" | "agility" | "intelligence" | "constitution" | "perception" | "luck" | "spiritualElement" | "spiritualPurity" | "spiritualGrade" | "bloodlineId" | "bloodlineAwakening" | "createdAt" | "updatedAt", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
    techniques?: boolean | Character$techniquesArgs<ExtArgs>
    talents?: boolean | Character$talentsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
  }
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bloodline?: boolean | Character$bloodlineArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bloodline: Prisma.$BloodlinePayload<ExtArgs> | null
      techniques: Prisma.$CharacterTechniquePayload<ExtArgs>[]
      talents: Prisma.$CharacterTalentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      realm: $Enums.CultivationRealm
      level: number
      experience: bigint
      experienceToNext: bigint
      strength: number
      agility: number
      intelligence: number
      constitution: number
      perception: number
      luck: number
      spiritualElement: $Enums.ElementType
      spiritualPurity: number
      spiritualGrade: $Enums.SpiritualGrade
      bloodlineId: string | null
      bloodlineAwakening: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bloodline<T extends Character$bloodlineArgs<ExtArgs> = {}>(args?: Subset<T, Character$bloodlineArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    techniques<T extends Character$techniquesArgs<ExtArgs> = {}>(args?: Subset<T, Character$techniquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    talents<T extends Character$talentsArgs<ExtArgs> = {}>(args?: Subset<T, Character$talentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly userId: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly realm: FieldRef<"Character", 'CultivationRealm'>
    readonly level: FieldRef<"Character", 'Int'>
    readonly experience: FieldRef<"Character", 'BigInt'>
    readonly experienceToNext: FieldRef<"Character", 'BigInt'>
    readonly strength: FieldRef<"Character", 'Int'>
    readonly agility: FieldRef<"Character", 'Int'>
    readonly intelligence: FieldRef<"Character", 'Int'>
    readonly constitution: FieldRef<"Character", 'Int'>
    readonly perception: FieldRef<"Character", 'Int'>
    readonly luck: FieldRef<"Character", 'Int'>
    readonly spiritualElement: FieldRef<"Character", 'ElementType'>
    readonly spiritualPurity: FieldRef<"Character", 'Int'>
    readonly spiritualGrade: FieldRef<"Character", 'SpiritualGrade'>
    readonly bloodlineId: FieldRef<"Character", 'String'>
    readonly bloodlineAwakening: FieldRef<"Character", 'Int'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.bloodline
   */
  export type Character$bloodlineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    where?: BloodlineWhereInput
  }

  /**
   * Character.techniques
   */
  export type Character$techniquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    where?: CharacterTechniqueWhereInput
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    cursor?: CharacterTechniqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterTechniqueScalarFieldEnum | CharacterTechniqueScalarFieldEnum[]
  }

  /**
   * Character.talents
   */
  export type Character$talentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    where?: CharacterTalentWhereInput
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    cursor?: CharacterTalentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterTalentScalarFieldEnum | CharacterTalentScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model CultivationProgress
   */

  export type AggregateCultivationProgress = {
    _count: CultivationProgressCountAggregateOutputType | null
    _avg: CultivationProgressAvgAggregateOutputType | null
    _sum: CultivationProgressSumAggregateOutputType | null
    _min: CultivationProgressMinAggregateOutputType | null
    _max: CultivationProgressMaxAggregateOutputType | null
  }

  export type CultivationProgressAvgAggregateOutputType = {
    qiAmount: number | null
    qiCapacity: number | null
    cultivationSpeed: number | null
    bottleneckProgress: number | null
    breakthroughAttempts: number | null
    stabilityPercentage: number | null
    sessionDuration: number | null
    sessionQiGained: number | null
    sessionExpGained: number | null
  }

  export type CultivationProgressSumAggregateOutputType = {
    qiAmount: bigint | null
    qiCapacity: bigint | null
    cultivationSpeed: number | null
    bottleneckProgress: number | null
    breakthroughAttempts: number | null
    stabilityPercentage: number | null
    sessionDuration: number | null
    sessionQiGained: bigint | null
    sessionExpGained: bigint | null
  }

  export type CultivationProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentTechniqueId: string | null
    qiAmount: bigint | null
    qiCapacity: bigint | null
    cultivationSpeed: number | null
    bottleneckProgress: number | null
    breakthroughAttempts: number | null
    stabilityPercentage: number | null
    isSessionActive: boolean | null
    sessionStartTime: Date | null
    sessionDuration: number | null
    sessionQiGained: bigint | null
    sessionExpGained: bigint | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultivationProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentTechniqueId: string | null
    qiAmount: bigint | null
    qiCapacity: bigint | null
    cultivationSpeed: number | null
    bottleneckProgress: number | null
    breakthroughAttempts: number | null
    stabilityPercentage: number | null
    isSessionActive: boolean | null
    sessionStartTime: Date | null
    sessionDuration: number | null
    sessionQiGained: bigint | null
    sessionExpGained: bigint | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultivationProgressCountAggregateOutputType = {
    id: number
    userId: number
    currentTechniqueId: number
    qiAmount: number
    qiCapacity: number
    cultivationSpeed: number
    bottleneckProgress: number
    breakthroughAttempts: number
    stabilityPercentage: number
    isSessionActive: number
    sessionStartTime: number
    sessionDuration: number
    sessionQiGained: number
    sessionExpGained: number
    lastCalculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CultivationProgressAvgAggregateInputType = {
    qiAmount?: true
    qiCapacity?: true
    cultivationSpeed?: true
    bottleneckProgress?: true
    breakthroughAttempts?: true
    stabilityPercentage?: true
    sessionDuration?: true
    sessionQiGained?: true
    sessionExpGained?: true
  }

  export type CultivationProgressSumAggregateInputType = {
    qiAmount?: true
    qiCapacity?: true
    cultivationSpeed?: true
    bottleneckProgress?: true
    breakthroughAttempts?: true
    stabilityPercentage?: true
    sessionDuration?: true
    sessionQiGained?: true
    sessionExpGained?: true
  }

  export type CultivationProgressMinAggregateInputType = {
    id?: true
    userId?: true
    currentTechniqueId?: true
    qiAmount?: true
    qiCapacity?: true
    cultivationSpeed?: true
    bottleneckProgress?: true
    breakthroughAttempts?: true
    stabilityPercentage?: true
    isSessionActive?: true
    sessionStartTime?: true
    sessionDuration?: true
    sessionQiGained?: true
    sessionExpGained?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultivationProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    currentTechniqueId?: true
    qiAmount?: true
    qiCapacity?: true
    cultivationSpeed?: true
    bottleneckProgress?: true
    breakthroughAttempts?: true
    stabilityPercentage?: true
    isSessionActive?: true
    sessionStartTime?: true
    sessionDuration?: true
    sessionQiGained?: true
    sessionExpGained?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultivationProgressCountAggregateInputType = {
    id?: true
    userId?: true
    currentTechniqueId?: true
    qiAmount?: true
    qiCapacity?: true
    cultivationSpeed?: true
    bottleneckProgress?: true
    breakthroughAttempts?: true
    stabilityPercentage?: true
    isSessionActive?: true
    sessionStartTime?: true
    sessionDuration?: true
    sessionQiGained?: true
    sessionExpGained?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CultivationProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationProgress to aggregate.
     */
    where?: CultivationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationProgresses to fetch.
     */
    orderBy?: CultivationProgressOrderByWithRelationInput | CultivationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CultivationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CultivationProgresses
    **/
    _count?: true | CultivationProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CultivationProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CultivationProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CultivationProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CultivationProgressMaxAggregateInputType
  }

  export type GetCultivationProgressAggregateType<T extends CultivationProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateCultivationProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCultivationProgress[P]>
      : GetScalarType<T[P], AggregateCultivationProgress[P]>
  }




  export type CultivationProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultivationProgressWhereInput
    orderBy?: CultivationProgressOrderByWithAggregationInput | CultivationProgressOrderByWithAggregationInput[]
    by: CultivationProgressScalarFieldEnum[] | CultivationProgressScalarFieldEnum
    having?: CultivationProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CultivationProgressCountAggregateInputType | true
    _avg?: CultivationProgressAvgAggregateInputType
    _sum?: CultivationProgressSumAggregateInputType
    _min?: CultivationProgressMinAggregateInputType
    _max?: CultivationProgressMaxAggregateInputType
  }

  export type CultivationProgressGroupByOutputType = {
    id: string
    userId: string
    currentTechniqueId: string | null
    qiAmount: bigint
    qiCapacity: bigint
    cultivationSpeed: number
    bottleneckProgress: number
    breakthroughAttempts: number
    stabilityPercentage: number
    isSessionActive: boolean
    sessionStartTime: Date | null
    sessionDuration: number
    sessionQiGained: bigint
    sessionExpGained: bigint
    lastCalculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CultivationProgressCountAggregateOutputType | null
    _avg: CultivationProgressAvgAggregateOutputType | null
    _sum: CultivationProgressSumAggregateOutputType | null
    _min: CultivationProgressMinAggregateOutputType | null
    _max: CultivationProgressMaxAggregateOutputType | null
  }

  type GetCultivationProgressGroupByPayload<T extends CultivationProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CultivationProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CultivationProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CultivationProgressGroupByOutputType[P]>
            : GetScalarType<T[P], CultivationProgressGroupByOutputType[P]>
        }
      >
    >


  export type CultivationProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentTechniqueId?: boolean
    qiAmount?: boolean
    qiCapacity?: boolean
    cultivationSpeed?: boolean
    bottleneckProgress?: boolean
    breakthroughAttempts?: boolean
    stabilityPercentage?: boolean
    isSessionActive?: boolean
    sessionStartTime?: boolean
    sessionDuration?: boolean
    sessionQiGained?: boolean
    sessionExpGained?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationProgress"]>

  export type CultivationProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentTechniqueId?: boolean
    qiAmount?: boolean
    qiCapacity?: boolean
    cultivationSpeed?: boolean
    bottleneckProgress?: boolean
    breakthroughAttempts?: boolean
    stabilityPercentage?: boolean
    isSessionActive?: boolean
    sessionStartTime?: boolean
    sessionDuration?: boolean
    sessionQiGained?: boolean
    sessionExpGained?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationProgress"]>

  export type CultivationProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentTechniqueId?: boolean
    qiAmount?: boolean
    qiCapacity?: boolean
    cultivationSpeed?: boolean
    bottleneckProgress?: boolean
    breakthroughAttempts?: boolean
    stabilityPercentage?: boolean
    isSessionActive?: boolean
    sessionStartTime?: boolean
    sessionDuration?: boolean
    sessionQiGained?: boolean
    sessionExpGained?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationProgress"]>

  export type CultivationProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    currentTechniqueId?: boolean
    qiAmount?: boolean
    qiCapacity?: boolean
    cultivationSpeed?: boolean
    bottleneckProgress?: boolean
    breakthroughAttempts?: boolean
    stabilityPercentage?: boolean
    isSessionActive?: boolean
    sessionStartTime?: boolean
    sessionDuration?: boolean
    sessionQiGained?: boolean
    sessionExpGained?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CultivationProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentTechniqueId" | "qiAmount" | "qiCapacity" | "cultivationSpeed" | "bottleneckProgress" | "breakthroughAttempts" | "stabilityPercentage" | "isSessionActive" | "sessionStartTime" | "sessionDuration" | "sessionQiGained" | "sessionExpGained" | "lastCalculatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["cultivationProgress"]>
  export type CultivationProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }
  export type CultivationProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }
  export type CultivationProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentTechnique?: boolean | CultivationProgress$currentTechniqueArgs<ExtArgs>
  }

  export type $CultivationProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CultivationProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      currentTechnique: Prisma.$CultivationTechniquePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentTechniqueId: string | null
      qiAmount: bigint
      qiCapacity: bigint
      cultivationSpeed: number
      bottleneckProgress: number
      breakthroughAttempts: number
      stabilityPercentage: number
      isSessionActive: boolean
      sessionStartTime: Date | null
      sessionDuration: number
      sessionQiGained: bigint
      sessionExpGained: bigint
      lastCalculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cultivationProgress"]>
    composites: {}
  }

  type CultivationProgressGetPayload<S extends boolean | null | undefined | CultivationProgressDefaultArgs> = $Result.GetResult<Prisma.$CultivationProgressPayload, S>

  type CultivationProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CultivationProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CultivationProgressCountAggregateInputType | true
    }

  export interface CultivationProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CultivationProgress'], meta: { name: 'CultivationProgress' } }
    /**
     * Find zero or one CultivationProgress that matches the filter.
     * @param {CultivationProgressFindUniqueArgs} args - Arguments to find a CultivationProgress
     * @example
     * // Get one CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CultivationProgressFindUniqueArgs>(args: SelectSubset<T, CultivationProgressFindUniqueArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CultivationProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CultivationProgressFindUniqueOrThrowArgs} args - Arguments to find a CultivationProgress
     * @example
     * // Get one CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CultivationProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, CultivationProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CultivationProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressFindFirstArgs} args - Arguments to find a CultivationProgress
     * @example
     * // Get one CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CultivationProgressFindFirstArgs>(args?: SelectSubset<T, CultivationProgressFindFirstArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CultivationProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressFindFirstOrThrowArgs} args - Arguments to find a CultivationProgress
     * @example
     * // Get one CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CultivationProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, CultivationProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CultivationProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CultivationProgresses
     * const cultivationProgresses = await prisma.cultivationProgress.findMany()
     * 
     * // Get first 10 CultivationProgresses
     * const cultivationProgresses = await prisma.cultivationProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cultivationProgressWithIdOnly = await prisma.cultivationProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CultivationProgressFindManyArgs>(args?: SelectSubset<T, CultivationProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CultivationProgress.
     * @param {CultivationProgressCreateArgs} args - Arguments to create a CultivationProgress.
     * @example
     * // Create one CultivationProgress
     * const CultivationProgress = await prisma.cultivationProgress.create({
     *   data: {
     *     // ... data to create a CultivationProgress
     *   }
     * })
     * 
     */
    create<T extends CultivationProgressCreateArgs>(args: SelectSubset<T, CultivationProgressCreateArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CultivationProgresses.
     * @param {CultivationProgressCreateManyArgs} args - Arguments to create many CultivationProgresses.
     * @example
     * // Create many CultivationProgresses
     * const cultivationProgress = await prisma.cultivationProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CultivationProgressCreateManyArgs>(args?: SelectSubset<T, CultivationProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CultivationProgresses and returns the data saved in the database.
     * @param {CultivationProgressCreateManyAndReturnArgs} args - Arguments to create many CultivationProgresses.
     * @example
     * // Create many CultivationProgresses
     * const cultivationProgress = await prisma.cultivationProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CultivationProgresses and only return the `id`
     * const cultivationProgressWithIdOnly = await prisma.cultivationProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CultivationProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, CultivationProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CultivationProgress.
     * @param {CultivationProgressDeleteArgs} args - Arguments to delete one CultivationProgress.
     * @example
     * // Delete one CultivationProgress
     * const CultivationProgress = await prisma.cultivationProgress.delete({
     *   where: {
     *     // ... filter to delete one CultivationProgress
     *   }
     * })
     * 
     */
    delete<T extends CultivationProgressDeleteArgs>(args: SelectSubset<T, CultivationProgressDeleteArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CultivationProgress.
     * @param {CultivationProgressUpdateArgs} args - Arguments to update one CultivationProgress.
     * @example
     * // Update one CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CultivationProgressUpdateArgs>(args: SelectSubset<T, CultivationProgressUpdateArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CultivationProgresses.
     * @param {CultivationProgressDeleteManyArgs} args - Arguments to filter CultivationProgresses to delete.
     * @example
     * // Delete a few CultivationProgresses
     * const { count } = await prisma.cultivationProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CultivationProgressDeleteManyArgs>(args?: SelectSubset<T, CultivationProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CultivationProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CultivationProgresses
     * const cultivationProgress = await prisma.cultivationProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CultivationProgressUpdateManyArgs>(args: SelectSubset<T, CultivationProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CultivationProgresses and returns the data updated in the database.
     * @param {CultivationProgressUpdateManyAndReturnArgs} args - Arguments to update many CultivationProgresses.
     * @example
     * // Update many CultivationProgresses
     * const cultivationProgress = await prisma.cultivationProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CultivationProgresses and only return the `id`
     * const cultivationProgressWithIdOnly = await prisma.cultivationProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CultivationProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, CultivationProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CultivationProgress.
     * @param {CultivationProgressUpsertArgs} args - Arguments to update or create a CultivationProgress.
     * @example
     * // Update or create a CultivationProgress
     * const cultivationProgress = await prisma.cultivationProgress.upsert({
     *   create: {
     *     // ... data to create a CultivationProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CultivationProgress we want to update
     *   }
     * })
     */
    upsert<T extends CultivationProgressUpsertArgs>(args: SelectSubset<T, CultivationProgressUpsertArgs<ExtArgs>>): Prisma__CultivationProgressClient<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CultivationProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressCountArgs} args - Arguments to filter CultivationProgresses to count.
     * @example
     * // Count the number of CultivationProgresses
     * const count = await prisma.cultivationProgress.count({
     *   where: {
     *     // ... the filter for the CultivationProgresses we want to count
     *   }
     * })
    **/
    count<T extends CultivationProgressCountArgs>(
      args?: Subset<T, CultivationProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CultivationProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CultivationProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CultivationProgressAggregateArgs>(args: Subset<T, CultivationProgressAggregateArgs>): Prisma.PrismaPromise<GetCultivationProgressAggregateType<T>>

    /**
     * Group by CultivationProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CultivationProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CultivationProgressGroupByArgs['orderBy'] }
        : { orderBy?: CultivationProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CultivationProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCultivationProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CultivationProgress model
   */
  readonly fields: CultivationProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CultivationProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CultivationProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentTechnique<T extends CultivationProgress$currentTechniqueArgs<ExtArgs> = {}>(args?: Subset<T, CultivationProgress$currentTechniqueArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CultivationProgress model
   */
  interface CultivationProgressFieldRefs {
    readonly id: FieldRef<"CultivationProgress", 'String'>
    readonly userId: FieldRef<"CultivationProgress", 'String'>
    readonly currentTechniqueId: FieldRef<"CultivationProgress", 'String'>
    readonly qiAmount: FieldRef<"CultivationProgress", 'BigInt'>
    readonly qiCapacity: FieldRef<"CultivationProgress", 'BigInt'>
    readonly cultivationSpeed: FieldRef<"CultivationProgress", 'Float'>
    readonly bottleneckProgress: FieldRef<"CultivationProgress", 'Float'>
    readonly breakthroughAttempts: FieldRef<"CultivationProgress", 'Int'>
    readonly stabilityPercentage: FieldRef<"CultivationProgress", 'Float'>
    readonly isSessionActive: FieldRef<"CultivationProgress", 'Boolean'>
    readonly sessionStartTime: FieldRef<"CultivationProgress", 'DateTime'>
    readonly sessionDuration: FieldRef<"CultivationProgress", 'Int'>
    readonly sessionQiGained: FieldRef<"CultivationProgress", 'BigInt'>
    readonly sessionExpGained: FieldRef<"CultivationProgress", 'BigInt'>
    readonly lastCalculatedAt: FieldRef<"CultivationProgress", 'DateTime'>
    readonly createdAt: FieldRef<"CultivationProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"CultivationProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CultivationProgress findUnique
   */
  export type CultivationProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter, which CultivationProgress to fetch.
     */
    where: CultivationProgressWhereUniqueInput
  }

  /**
   * CultivationProgress findUniqueOrThrow
   */
  export type CultivationProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter, which CultivationProgress to fetch.
     */
    where: CultivationProgressWhereUniqueInput
  }

  /**
   * CultivationProgress findFirst
   */
  export type CultivationProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter, which CultivationProgress to fetch.
     */
    where?: CultivationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationProgresses to fetch.
     */
    orderBy?: CultivationProgressOrderByWithRelationInput | CultivationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationProgresses.
     */
    cursor?: CultivationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationProgresses.
     */
    distinct?: CultivationProgressScalarFieldEnum | CultivationProgressScalarFieldEnum[]
  }

  /**
   * CultivationProgress findFirstOrThrow
   */
  export type CultivationProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter, which CultivationProgress to fetch.
     */
    where?: CultivationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationProgresses to fetch.
     */
    orderBy?: CultivationProgressOrderByWithRelationInput | CultivationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationProgresses.
     */
    cursor?: CultivationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationProgresses.
     */
    distinct?: CultivationProgressScalarFieldEnum | CultivationProgressScalarFieldEnum[]
  }

  /**
   * CultivationProgress findMany
   */
  export type CultivationProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter, which CultivationProgresses to fetch.
     */
    where?: CultivationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationProgresses to fetch.
     */
    orderBy?: CultivationProgressOrderByWithRelationInput | CultivationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CultivationProgresses.
     */
    cursor?: CultivationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationProgresses.
     */
    skip?: number
    distinct?: CultivationProgressScalarFieldEnum | CultivationProgressScalarFieldEnum[]
  }

  /**
   * CultivationProgress create
   */
  export type CultivationProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a CultivationProgress.
     */
    data: XOR<CultivationProgressCreateInput, CultivationProgressUncheckedCreateInput>
  }

  /**
   * CultivationProgress createMany
   */
  export type CultivationProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CultivationProgresses.
     */
    data: CultivationProgressCreateManyInput | CultivationProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CultivationProgress createManyAndReturn
   */
  export type CultivationProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * The data used to create many CultivationProgresses.
     */
    data: CultivationProgressCreateManyInput | CultivationProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CultivationProgress update
   */
  export type CultivationProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a CultivationProgress.
     */
    data: XOR<CultivationProgressUpdateInput, CultivationProgressUncheckedUpdateInput>
    /**
     * Choose, which CultivationProgress to update.
     */
    where: CultivationProgressWhereUniqueInput
  }

  /**
   * CultivationProgress updateMany
   */
  export type CultivationProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CultivationProgresses.
     */
    data: XOR<CultivationProgressUpdateManyMutationInput, CultivationProgressUncheckedUpdateManyInput>
    /**
     * Filter which CultivationProgresses to update
     */
    where?: CultivationProgressWhereInput
    /**
     * Limit how many CultivationProgresses to update.
     */
    limit?: number
  }

  /**
   * CultivationProgress updateManyAndReturn
   */
  export type CultivationProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * The data used to update CultivationProgresses.
     */
    data: XOR<CultivationProgressUpdateManyMutationInput, CultivationProgressUncheckedUpdateManyInput>
    /**
     * Filter which CultivationProgresses to update
     */
    where?: CultivationProgressWhereInput
    /**
     * Limit how many CultivationProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CultivationProgress upsert
   */
  export type CultivationProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the CultivationProgress to update in case it exists.
     */
    where: CultivationProgressWhereUniqueInput
    /**
     * In case the CultivationProgress found by the `where` argument doesn't exist, create a new CultivationProgress with this data.
     */
    create: XOR<CultivationProgressCreateInput, CultivationProgressUncheckedCreateInput>
    /**
     * In case the CultivationProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CultivationProgressUpdateInput, CultivationProgressUncheckedUpdateInput>
  }

  /**
   * CultivationProgress delete
   */
  export type CultivationProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    /**
     * Filter which CultivationProgress to delete.
     */
    where: CultivationProgressWhereUniqueInput
  }

  /**
   * CultivationProgress deleteMany
   */
  export type CultivationProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationProgresses to delete
     */
    where?: CultivationProgressWhereInput
    /**
     * Limit how many CultivationProgresses to delete.
     */
    limit?: number
  }

  /**
   * CultivationProgress.currentTechnique
   */
  export type CultivationProgress$currentTechniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    where?: CultivationTechniqueWhereInput
  }

  /**
   * CultivationProgress without action
   */
  export type CultivationProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
  }


  /**
   * Model CultivationTechnique
   */

  export type AggregateCultivationTechnique = {
    _count: CultivationTechniqueCountAggregateOutputType | null
    _avg: CultivationTechniqueAvgAggregateOutputType | null
    _sum: CultivationTechniqueSumAggregateOutputType | null
    _min: CultivationTechniqueMinAggregateOutputType | null
    _max: CultivationTechniqueMaxAggregateOutputType | null
  }

  export type CultivationTechniqueAvgAggregateOutputType = {
    minLevel: number | null
    baseSpeed: number | null
    qiEfficiency: number | null
    stabilityBonus: number | null
  }

  export type CultivationTechniqueSumAggregateOutputType = {
    minLevel: number | null
    baseSpeed: number | null
    qiEfficiency: number | null
    stabilityBonus: number | null
  }

  export type CultivationTechniqueMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TechniqueType | null
    element: $Enums.ElementType | null
    minRealm: $Enums.CultivationRealm | null
    minLevel: number | null
    baseSpeed: number | null
    qiEfficiency: number | null
    stabilityBonus: number | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultivationTechniqueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TechniqueType | null
    element: $Enums.ElementType | null
    minRealm: $Enums.CultivationRealm | null
    minLevel: number | null
    baseSpeed: number | null
    qiEfficiency: number | null
    stabilityBonus: number | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultivationTechniqueCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    element: number
    minRealm: number
    minLevel: number
    baseSpeed: number
    qiEfficiency: number
    stabilityBonus: number
    rarity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CultivationTechniqueAvgAggregateInputType = {
    minLevel?: true
    baseSpeed?: true
    qiEfficiency?: true
    stabilityBonus?: true
  }

  export type CultivationTechniqueSumAggregateInputType = {
    minLevel?: true
    baseSpeed?: true
    qiEfficiency?: true
    stabilityBonus?: true
  }

  export type CultivationTechniqueMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    element?: true
    minRealm?: true
    minLevel?: true
    baseSpeed?: true
    qiEfficiency?: true
    stabilityBonus?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultivationTechniqueMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    element?: true
    minRealm?: true
    minLevel?: true
    baseSpeed?: true
    qiEfficiency?: true
    stabilityBonus?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultivationTechniqueCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    element?: true
    minRealm?: true
    minLevel?: true
    baseSpeed?: true
    qiEfficiency?: true
    stabilityBonus?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CultivationTechniqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationTechnique to aggregate.
     */
    where?: CultivationTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationTechniques to fetch.
     */
    orderBy?: CultivationTechniqueOrderByWithRelationInput | CultivationTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CultivationTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CultivationTechniques
    **/
    _count?: true | CultivationTechniqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CultivationTechniqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CultivationTechniqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CultivationTechniqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CultivationTechniqueMaxAggregateInputType
  }

  export type GetCultivationTechniqueAggregateType<T extends CultivationTechniqueAggregateArgs> = {
        [P in keyof T & keyof AggregateCultivationTechnique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCultivationTechnique[P]>
      : GetScalarType<T[P], AggregateCultivationTechnique[P]>
  }




  export type CultivationTechniqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultivationTechniqueWhereInput
    orderBy?: CultivationTechniqueOrderByWithAggregationInput | CultivationTechniqueOrderByWithAggregationInput[]
    by: CultivationTechniqueScalarFieldEnum[] | CultivationTechniqueScalarFieldEnum
    having?: CultivationTechniqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CultivationTechniqueCountAggregateInputType | true
    _avg?: CultivationTechniqueAvgAggregateInputType
    _sum?: CultivationTechniqueSumAggregateInputType
    _min?: CultivationTechniqueMinAggregateInputType
    _max?: CultivationTechniqueMaxAggregateInputType
  }

  export type CultivationTechniqueGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.TechniqueType
    element: $Enums.ElementType
    minRealm: $Enums.CultivationRealm
    minLevel: number
    baseSpeed: number
    qiEfficiency: number
    stabilityBonus: number
    rarity: $Enums.ItemRarity
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CultivationTechniqueCountAggregateOutputType | null
    _avg: CultivationTechniqueAvgAggregateOutputType | null
    _sum: CultivationTechniqueSumAggregateOutputType | null
    _min: CultivationTechniqueMinAggregateOutputType | null
    _max: CultivationTechniqueMaxAggregateOutputType | null
  }

  type GetCultivationTechniqueGroupByPayload<T extends CultivationTechniqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CultivationTechniqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CultivationTechniqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CultivationTechniqueGroupByOutputType[P]>
            : GetScalarType<T[P], CultivationTechniqueGroupByOutputType[P]>
        }
      >
    >


  export type CultivationTechniqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    element?: boolean
    minRealm?: boolean
    minLevel?: boolean
    baseSpeed?: boolean
    qiEfficiency?: boolean
    stabilityBonus?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userProgress?: boolean | CultivationTechnique$userProgressArgs<ExtArgs>
    characterTechniques?: boolean | CultivationTechnique$characterTechniquesArgs<ExtArgs>
    _count?: boolean | CultivationTechniqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cultivationTechnique"]>

  export type CultivationTechniqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    element?: boolean
    minRealm?: boolean
    minLevel?: boolean
    baseSpeed?: boolean
    qiEfficiency?: boolean
    stabilityBonus?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cultivationTechnique"]>

  export type CultivationTechniqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    element?: boolean
    minRealm?: boolean
    minLevel?: boolean
    baseSpeed?: boolean
    qiEfficiency?: boolean
    stabilityBonus?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cultivationTechnique"]>

  export type CultivationTechniqueSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    element?: boolean
    minRealm?: boolean
    minLevel?: boolean
    baseSpeed?: boolean
    qiEfficiency?: boolean
    stabilityBonus?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CultivationTechniqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "element" | "minRealm" | "minLevel" | "baseSpeed" | "qiEfficiency" | "stabilityBonus" | "rarity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["cultivationTechnique"]>
  export type CultivationTechniqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProgress?: boolean | CultivationTechnique$userProgressArgs<ExtArgs>
    characterTechniques?: boolean | CultivationTechnique$characterTechniquesArgs<ExtArgs>
    _count?: boolean | CultivationTechniqueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CultivationTechniqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CultivationTechniqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CultivationTechniquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CultivationTechnique"
    objects: {
      userProgress: Prisma.$CultivationProgressPayload<ExtArgs>[]
      characterTechniques: Prisma.$CharacterTechniquePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.TechniqueType
      element: $Enums.ElementType
      minRealm: $Enums.CultivationRealm
      minLevel: number
      baseSpeed: number
      qiEfficiency: number
      stabilityBonus: number
      rarity: $Enums.ItemRarity
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cultivationTechnique"]>
    composites: {}
  }

  type CultivationTechniqueGetPayload<S extends boolean | null | undefined | CultivationTechniqueDefaultArgs> = $Result.GetResult<Prisma.$CultivationTechniquePayload, S>

  type CultivationTechniqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CultivationTechniqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CultivationTechniqueCountAggregateInputType | true
    }

  export interface CultivationTechniqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CultivationTechnique'], meta: { name: 'CultivationTechnique' } }
    /**
     * Find zero or one CultivationTechnique that matches the filter.
     * @param {CultivationTechniqueFindUniqueArgs} args - Arguments to find a CultivationTechnique
     * @example
     * // Get one CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CultivationTechniqueFindUniqueArgs>(args: SelectSubset<T, CultivationTechniqueFindUniqueArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CultivationTechnique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CultivationTechniqueFindUniqueOrThrowArgs} args - Arguments to find a CultivationTechnique
     * @example
     * // Get one CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CultivationTechniqueFindUniqueOrThrowArgs>(args: SelectSubset<T, CultivationTechniqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CultivationTechnique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueFindFirstArgs} args - Arguments to find a CultivationTechnique
     * @example
     * // Get one CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CultivationTechniqueFindFirstArgs>(args?: SelectSubset<T, CultivationTechniqueFindFirstArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CultivationTechnique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueFindFirstOrThrowArgs} args - Arguments to find a CultivationTechnique
     * @example
     * // Get one CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CultivationTechniqueFindFirstOrThrowArgs>(args?: SelectSubset<T, CultivationTechniqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CultivationTechniques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CultivationTechniques
     * const cultivationTechniques = await prisma.cultivationTechnique.findMany()
     * 
     * // Get first 10 CultivationTechniques
     * const cultivationTechniques = await prisma.cultivationTechnique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cultivationTechniqueWithIdOnly = await prisma.cultivationTechnique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CultivationTechniqueFindManyArgs>(args?: SelectSubset<T, CultivationTechniqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CultivationTechnique.
     * @param {CultivationTechniqueCreateArgs} args - Arguments to create a CultivationTechnique.
     * @example
     * // Create one CultivationTechnique
     * const CultivationTechnique = await prisma.cultivationTechnique.create({
     *   data: {
     *     // ... data to create a CultivationTechnique
     *   }
     * })
     * 
     */
    create<T extends CultivationTechniqueCreateArgs>(args: SelectSubset<T, CultivationTechniqueCreateArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CultivationTechniques.
     * @param {CultivationTechniqueCreateManyArgs} args - Arguments to create many CultivationTechniques.
     * @example
     * // Create many CultivationTechniques
     * const cultivationTechnique = await prisma.cultivationTechnique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CultivationTechniqueCreateManyArgs>(args?: SelectSubset<T, CultivationTechniqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CultivationTechniques and returns the data saved in the database.
     * @param {CultivationTechniqueCreateManyAndReturnArgs} args - Arguments to create many CultivationTechniques.
     * @example
     * // Create many CultivationTechniques
     * const cultivationTechnique = await prisma.cultivationTechnique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CultivationTechniques and only return the `id`
     * const cultivationTechniqueWithIdOnly = await prisma.cultivationTechnique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CultivationTechniqueCreateManyAndReturnArgs>(args?: SelectSubset<T, CultivationTechniqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CultivationTechnique.
     * @param {CultivationTechniqueDeleteArgs} args - Arguments to delete one CultivationTechnique.
     * @example
     * // Delete one CultivationTechnique
     * const CultivationTechnique = await prisma.cultivationTechnique.delete({
     *   where: {
     *     // ... filter to delete one CultivationTechnique
     *   }
     * })
     * 
     */
    delete<T extends CultivationTechniqueDeleteArgs>(args: SelectSubset<T, CultivationTechniqueDeleteArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CultivationTechnique.
     * @param {CultivationTechniqueUpdateArgs} args - Arguments to update one CultivationTechnique.
     * @example
     * // Update one CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CultivationTechniqueUpdateArgs>(args: SelectSubset<T, CultivationTechniqueUpdateArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CultivationTechniques.
     * @param {CultivationTechniqueDeleteManyArgs} args - Arguments to filter CultivationTechniques to delete.
     * @example
     * // Delete a few CultivationTechniques
     * const { count } = await prisma.cultivationTechnique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CultivationTechniqueDeleteManyArgs>(args?: SelectSubset<T, CultivationTechniqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CultivationTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CultivationTechniques
     * const cultivationTechnique = await prisma.cultivationTechnique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CultivationTechniqueUpdateManyArgs>(args: SelectSubset<T, CultivationTechniqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CultivationTechniques and returns the data updated in the database.
     * @param {CultivationTechniqueUpdateManyAndReturnArgs} args - Arguments to update many CultivationTechniques.
     * @example
     * // Update many CultivationTechniques
     * const cultivationTechnique = await prisma.cultivationTechnique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CultivationTechniques and only return the `id`
     * const cultivationTechniqueWithIdOnly = await prisma.cultivationTechnique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CultivationTechniqueUpdateManyAndReturnArgs>(args: SelectSubset<T, CultivationTechniqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CultivationTechnique.
     * @param {CultivationTechniqueUpsertArgs} args - Arguments to update or create a CultivationTechnique.
     * @example
     * // Update or create a CultivationTechnique
     * const cultivationTechnique = await prisma.cultivationTechnique.upsert({
     *   create: {
     *     // ... data to create a CultivationTechnique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CultivationTechnique we want to update
     *   }
     * })
     */
    upsert<T extends CultivationTechniqueUpsertArgs>(args: SelectSubset<T, CultivationTechniqueUpsertArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CultivationTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueCountArgs} args - Arguments to filter CultivationTechniques to count.
     * @example
     * // Count the number of CultivationTechniques
     * const count = await prisma.cultivationTechnique.count({
     *   where: {
     *     // ... the filter for the CultivationTechniques we want to count
     *   }
     * })
    **/
    count<T extends CultivationTechniqueCountArgs>(
      args?: Subset<T, CultivationTechniqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CultivationTechniqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CultivationTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CultivationTechniqueAggregateArgs>(args: Subset<T, CultivationTechniqueAggregateArgs>): Prisma.PrismaPromise<GetCultivationTechniqueAggregateType<T>>

    /**
     * Group by CultivationTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultivationTechniqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CultivationTechniqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CultivationTechniqueGroupByArgs['orderBy'] }
        : { orderBy?: CultivationTechniqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CultivationTechniqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCultivationTechniqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CultivationTechnique model
   */
  readonly fields: CultivationTechniqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CultivationTechnique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CultivationTechniqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProgress<T extends CultivationTechnique$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, CultivationTechnique$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultivationProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characterTechniques<T extends CultivationTechnique$characterTechniquesArgs<ExtArgs> = {}>(args?: Subset<T, CultivationTechnique$characterTechniquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CultivationTechnique model
   */
  interface CultivationTechniqueFieldRefs {
    readonly id: FieldRef<"CultivationTechnique", 'String'>
    readonly name: FieldRef<"CultivationTechnique", 'String'>
    readonly description: FieldRef<"CultivationTechnique", 'String'>
    readonly type: FieldRef<"CultivationTechnique", 'TechniqueType'>
    readonly element: FieldRef<"CultivationTechnique", 'ElementType'>
    readonly minRealm: FieldRef<"CultivationTechnique", 'CultivationRealm'>
    readonly minLevel: FieldRef<"CultivationTechnique", 'Int'>
    readonly baseSpeed: FieldRef<"CultivationTechnique", 'Float'>
    readonly qiEfficiency: FieldRef<"CultivationTechnique", 'Float'>
    readonly stabilityBonus: FieldRef<"CultivationTechnique", 'Float'>
    readonly rarity: FieldRef<"CultivationTechnique", 'ItemRarity'>
    readonly isActive: FieldRef<"CultivationTechnique", 'Boolean'>
    readonly createdAt: FieldRef<"CultivationTechnique", 'DateTime'>
    readonly updatedAt: FieldRef<"CultivationTechnique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CultivationTechnique findUnique
   */
  export type CultivationTechniqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CultivationTechnique to fetch.
     */
    where: CultivationTechniqueWhereUniqueInput
  }

  /**
   * CultivationTechnique findUniqueOrThrow
   */
  export type CultivationTechniqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CultivationTechnique to fetch.
     */
    where: CultivationTechniqueWhereUniqueInput
  }

  /**
   * CultivationTechnique findFirst
   */
  export type CultivationTechniqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CultivationTechnique to fetch.
     */
    where?: CultivationTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationTechniques to fetch.
     */
    orderBy?: CultivationTechniqueOrderByWithRelationInput | CultivationTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationTechniques.
     */
    cursor?: CultivationTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationTechniques.
     */
    distinct?: CultivationTechniqueScalarFieldEnum | CultivationTechniqueScalarFieldEnum[]
  }

  /**
   * CultivationTechnique findFirstOrThrow
   */
  export type CultivationTechniqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CultivationTechnique to fetch.
     */
    where?: CultivationTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationTechniques to fetch.
     */
    orderBy?: CultivationTechniqueOrderByWithRelationInput | CultivationTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CultivationTechniques.
     */
    cursor?: CultivationTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CultivationTechniques.
     */
    distinct?: CultivationTechniqueScalarFieldEnum | CultivationTechniqueScalarFieldEnum[]
  }

  /**
   * CultivationTechnique findMany
   */
  export type CultivationTechniqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CultivationTechniques to fetch.
     */
    where?: CultivationTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CultivationTechniques to fetch.
     */
    orderBy?: CultivationTechniqueOrderByWithRelationInput | CultivationTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CultivationTechniques.
     */
    cursor?: CultivationTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CultivationTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CultivationTechniques.
     */
    skip?: number
    distinct?: CultivationTechniqueScalarFieldEnum | CultivationTechniqueScalarFieldEnum[]
  }

  /**
   * CultivationTechnique create
   */
  export type CultivationTechniqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to create a CultivationTechnique.
     */
    data: XOR<CultivationTechniqueCreateInput, CultivationTechniqueUncheckedCreateInput>
  }

  /**
   * CultivationTechnique createMany
   */
  export type CultivationTechniqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CultivationTechniques.
     */
    data: CultivationTechniqueCreateManyInput | CultivationTechniqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CultivationTechnique createManyAndReturn
   */
  export type CultivationTechniqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * The data used to create many CultivationTechniques.
     */
    data: CultivationTechniqueCreateManyInput | CultivationTechniqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CultivationTechnique update
   */
  export type CultivationTechniqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to update a CultivationTechnique.
     */
    data: XOR<CultivationTechniqueUpdateInput, CultivationTechniqueUncheckedUpdateInput>
    /**
     * Choose, which CultivationTechnique to update.
     */
    where: CultivationTechniqueWhereUniqueInput
  }

  /**
   * CultivationTechnique updateMany
   */
  export type CultivationTechniqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CultivationTechniques.
     */
    data: XOR<CultivationTechniqueUpdateManyMutationInput, CultivationTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which CultivationTechniques to update
     */
    where?: CultivationTechniqueWhereInput
    /**
     * Limit how many CultivationTechniques to update.
     */
    limit?: number
  }

  /**
   * CultivationTechnique updateManyAndReturn
   */
  export type CultivationTechniqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * The data used to update CultivationTechniques.
     */
    data: XOR<CultivationTechniqueUpdateManyMutationInput, CultivationTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which CultivationTechniques to update
     */
    where?: CultivationTechniqueWhereInput
    /**
     * Limit how many CultivationTechniques to update.
     */
    limit?: number
  }

  /**
   * CultivationTechnique upsert
   */
  export type CultivationTechniqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * The filter to search for the CultivationTechnique to update in case it exists.
     */
    where: CultivationTechniqueWhereUniqueInput
    /**
     * In case the CultivationTechnique found by the `where` argument doesn't exist, create a new CultivationTechnique with this data.
     */
    create: XOR<CultivationTechniqueCreateInput, CultivationTechniqueUncheckedCreateInput>
    /**
     * In case the CultivationTechnique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CultivationTechniqueUpdateInput, CultivationTechniqueUncheckedUpdateInput>
  }

  /**
   * CultivationTechnique delete
   */
  export type CultivationTechniqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
    /**
     * Filter which CultivationTechnique to delete.
     */
    where: CultivationTechniqueWhereUniqueInput
  }

  /**
   * CultivationTechnique deleteMany
   */
  export type CultivationTechniqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CultivationTechniques to delete
     */
    where?: CultivationTechniqueWhereInput
    /**
     * Limit how many CultivationTechniques to delete.
     */
    limit?: number
  }

  /**
   * CultivationTechnique.userProgress
   */
  export type CultivationTechnique$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationProgress
     */
    select?: CultivationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationProgress
     */
    omit?: CultivationProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationProgressInclude<ExtArgs> | null
    where?: CultivationProgressWhereInput
    orderBy?: CultivationProgressOrderByWithRelationInput | CultivationProgressOrderByWithRelationInput[]
    cursor?: CultivationProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultivationProgressScalarFieldEnum | CultivationProgressScalarFieldEnum[]
  }

  /**
   * CultivationTechnique.characterTechniques
   */
  export type CultivationTechnique$characterTechniquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    where?: CharacterTechniqueWhereInput
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    cursor?: CharacterTechniqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterTechniqueScalarFieldEnum | CharacterTechniqueScalarFieldEnum[]
  }

  /**
   * CultivationTechnique without action
   */
  export type CultivationTechniqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultivationTechnique
     */
    select?: CultivationTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CultivationTechnique
     */
    omit?: CultivationTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultivationTechniqueInclude<ExtArgs> | null
  }


  /**
   * Model CharacterTechnique
   */

  export type AggregateCharacterTechnique = {
    _count: CharacterTechniqueCountAggregateOutputType | null
    _avg: CharacterTechniqueAvgAggregateOutputType | null
    _sum: CharacterTechniqueSumAggregateOutputType | null
    _min: CharacterTechniqueMinAggregateOutputType | null
    _max: CharacterTechniqueMaxAggregateOutputType | null
  }

  export type CharacterTechniqueAvgAggregateOutputType = {
    proficiency: number | null
    level: number | null
    experience: number | null
    masteryBonus: number | null
  }

  export type CharacterTechniqueSumAggregateOutputType = {
    proficiency: number | null
    level: number | null
    experience: bigint | null
    masteryBonus: number | null
  }

  export type CharacterTechniqueMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    techniqueId: string | null
    proficiency: number | null
    level: number | null
    experience: bigint | null
    masteryBonus: number | null
    learnedAt: Date | null
    lastUsedAt: Date | null
  }

  export type CharacterTechniqueMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    techniqueId: string | null
    proficiency: number | null
    level: number | null
    experience: bigint | null
    masteryBonus: number | null
    learnedAt: Date | null
    lastUsedAt: Date | null
  }

  export type CharacterTechniqueCountAggregateOutputType = {
    id: number
    characterId: number
    techniqueId: number
    proficiency: number
    level: number
    experience: number
    masteryBonus: number
    learnedAt: number
    lastUsedAt: number
    _all: number
  }


  export type CharacterTechniqueAvgAggregateInputType = {
    proficiency?: true
    level?: true
    experience?: true
    masteryBonus?: true
  }

  export type CharacterTechniqueSumAggregateInputType = {
    proficiency?: true
    level?: true
    experience?: true
    masteryBonus?: true
  }

  export type CharacterTechniqueMinAggregateInputType = {
    id?: true
    characterId?: true
    techniqueId?: true
    proficiency?: true
    level?: true
    experience?: true
    masteryBonus?: true
    learnedAt?: true
    lastUsedAt?: true
  }

  export type CharacterTechniqueMaxAggregateInputType = {
    id?: true
    characterId?: true
    techniqueId?: true
    proficiency?: true
    level?: true
    experience?: true
    masteryBonus?: true
    learnedAt?: true
    lastUsedAt?: true
  }

  export type CharacterTechniqueCountAggregateInputType = {
    id?: true
    characterId?: true
    techniqueId?: true
    proficiency?: true
    level?: true
    experience?: true
    masteryBonus?: true
    learnedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type CharacterTechniqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterTechnique to aggregate.
     */
    where?: CharacterTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTechniques to fetch.
     */
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterTechniques
    **/
    _count?: true | CharacterTechniqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterTechniqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterTechniqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterTechniqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterTechniqueMaxAggregateInputType
  }

  export type GetCharacterTechniqueAggregateType<T extends CharacterTechniqueAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterTechnique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterTechnique[P]>
      : GetScalarType<T[P], AggregateCharacterTechnique[P]>
  }




  export type CharacterTechniqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTechniqueWhereInput
    orderBy?: CharacterTechniqueOrderByWithAggregationInput | CharacterTechniqueOrderByWithAggregationInput[]
    by: CharacterTechniqueScalarFieldEnum[] | CharacterTechniqueScalarFieldEnum
    having?: CharacterTechniqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterTechniqueCountAggregateInputType | true
    _avg?: CharacterTechniqueAvgAggregateInputType
    _sum?: CharacterTechniqueSumAggregateInputType
    _min?: CharacterTechniqueMinAggregateInputType
    _max?: CharacterTechniqueMaxAggregateInputType
  }

  export type CharacterTechniqueGroupByOutputType = {
    id: string
    characterId: string
    techniqueId: string
    proficiency: number
    level: number
    experience: bigint
    masteryBonus: number
    learnedAt: Date
    lastUsedAt: Date
    _count: CharacterTechniqueCountAggregateOutputType | null
    _avg: CharacterTechniqueAvgAggregateOutputType | null
    _sum: CharacterTechniqueSumAggregateOutputType | null
    _min: CharacterTechniqueMinAggregateOutputType | null
    _max: CharacterTechniqueMaxAggregateOutputType | null
  }

  type GetCharacterTechniqueGroupByPayload<T extends CharacterTechniqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterTechniqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterTechniqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterTechniqueGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterTechniqueGroupByOutputType[P]>
        }
      >
    >


  export type CharacterTechniqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    techniqueId?: boolean
    proficiency?: boolean
    level?: boolean
    experience?: boolean
    masteryBonus?: boolean
    learnedAt?: boolean
    lastUsedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTechnique"]>

  export type CharacterTechniqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    techniqueId?: boolean
    proficiency?: boolean
    level?: boolean
    experience?: boolean
    masteryBonus?: boolean
    learnedAt?: boolean
    lastUsedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTechnique"]>

  export type CharacterTechniqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    techniqueId?: boolean
    proficiency?: boolean
    level?: boolean
    experience?: boolean
    masteryBonus?: boolean
    learnedAt?: boolean
    lastUsedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTechnique"]>

  export type CharacterTechniqueSelectScalar = {
    id?: boolean
    characterId?: boolean
    techniqueId?: boolean
    proficiency?: boolean
    level?: boolean
    experience?: boolean
    masteryBonus?: boolean
    learnedAt?: boolean
    lastUsedAt?: boolean
  }

  export type CharacterTechniqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "techniqueId" | "proficiency" | "level" | "experience" | "masteryBonus" | "learnedAt" | "lastUsedAt", ExtArgs["result"]["characterTechnique"]>
  export type CharacterTechniqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }
  export type CharacterTechniqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }
  export type CharacterTechniqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    technique?: boolean | CultivationTechniqueDefaultArgs<ExtArgs>
  }

  export type $CharacterTechniquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterTechnique"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      technique: Prisma.$CultivationTechniquePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      techniqueId: string
      proficiency: number
      level: number
      experience: bigint
      masteryBonus: number
      learnedAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["characterTechnique"]>
    composites: {}
  }

  type CharacterTechniqueGetPayload<S extends boolean | null | undefined | CharacterTechniqueDefaultArgs> = $Result.GetResult<Prisma.$CharacterTechniquePayload, S>

  type CharacterTechniqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterTechniqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterTechniqueCountAggregateInputType | true
    }

  export interface CharacterTechniqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterTechnique'], meta: { name: 'CharacterTechnique' } }
    /**
     * Find zero or one CharacterTechnique that matches the filter.
     * @param {CharacterTechniqueFindUniqueArgs} args - Arguments to find a CharacterTechnique
     * @example
     * // Get one CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterTechniqueFindUniqueArgs>(args: SelectSubset<T, CharacterTechniqueFindUniqueArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterTechnique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterTechniqueFindUniqueOrThrowArgs} args - Arguments to find a CharacterTechnique
     * @example
     * // Get one CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterTechniqueFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterTechniqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterTechnique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueFindFirstArgs} args - Arguments to find a CharacterTechnique
     * @example
     * // Get one CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterTechniqueFindFirstArgs>(args?: SelectSubset<T, CharacterTechniqueFindFirstArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterTechnique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueFindFirstOrThrowArgs} args - Arguments to find a CharacterTechnique
     * @example
     * // Get one CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterTechniqueFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterTechniqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterTechniques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterTechniques
     * const characterTechniques = await prisma.characterTechnique.findMany()
     * 
     * // Get first 10 CharacterTechniques
     * const characterTechniques = await prisma.characterTechnique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterTechniqueWithIdOnly = await prisma.characterTechnique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterTechniqueFindManyArgs>(args?: SelectSubset<T, CharacterTechniqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterTechnique.
     * @param {CharacterTechniqueCreateArgs} args - Arguments to create a CharacterTechnique.
     * @example
     * // Create one CharacterTechnique
     * const CharacterTechnique = await prisma.characterTechnique.create({
     *   data: {
     *     // ... data to create a CharacterTechnique
     *   }
     * })
     * 
     */
    create<T extends CharacterTechniqueCreateArgs>(args: SelectSubset<T, CharacterTechniqueCreateArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterTechniques.
     * @param {CharacterTechniqueCreateManyArgs} args - Arguments to create many CharacterTechniques.
     * @example
     * // Create many CharacterTechniques
     * const characterTechnique = await prisma.characterTechnique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterTechniqueCreateManyArgs>(args?: SelectSubset<T, CharacterTechniqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterTechniques and returns the data saved in the database.
     * @param {CharacterTechniqueCreateManyAndReturnArgs} args - Arguments to create many CharacterTechniques.
     * @example
     * // Create many CharacterTechniques
     * const characterTechnique = await prisma.characterTechnique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterTechniques and only return the `id`
     * const characterTechniqueWithIdOnly = await prisma.characterTechnique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterTechniqueCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterTechniqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterTechnique.
     * @param {CharacterTechniqueDeleteArgs} args - Arguments to delete one CharacterTechnique.
     * @example
     * // Delete one CharacterTechnique
     * const CharacterTechnique = await prisma.characterTechnique.delete({
     *   where: {
     *     // ... filter to delete one CharacterTechnique
     *   }
     * })
     * 
     */
    delete<T extends CharacterTechniqueDeleteArgs>(args: SelectSubset<T, CharacterTechniqueDeleteArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterTechnique.
     * @param {CharacterTechniqueUpdateArgs} args - Arguments to update one CharacterTechnique.
     * @example
     * // Update one CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterTechniqueUpdateArgs>(args: SelectSubset<T, CharacterTechniqueUpdateArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterTechniques.
     * @param {CharacterTechniqueDeleteManyArgs} args - Arguments to filter CharacterTechniques to delete.
     * @example
     * // Delete a few CharacterTechniques
     * const { count } = await prisma.characterTechnique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterTechniqueDeleteManyArgs>(args?: SelectSubset<T, CharacterTechniqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterTechniques
     * const characterTechnique = await prisma.characterTechnique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterTechniqueUpdateManyArgs>(args: SelectSubset<T, CharacterTechniqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterTechniques and returns the data updated in the database.
     * @param {CharacterTechniqueUpdateManyAndReturnArgs} args - Arguments to update many CharacterTechniques.
     * @example
     * // Update many CharacterTechniques
     * const characterTechnique = await prisma.characterTechnique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterTechniques and only return the `id`
     * const characterTechniqueWithIdOnly = await prisma.characterTechnique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterTechniqueUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterTechniqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterTechnique.
     * @param {CharacterTechniqueUpsertArgs} args - Arguments to update or create a CharacterTechnique.
     * @example
     * // Update or create a CharacterTechnique
     * const characterTechnique = await prisma.characterTechnique.upsert({
     *   create: {
     *     // ... data to create a CharacterTechnique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterTechnique we want to update
     *   }
     * })
     */
    upsert<T extends CharacterTechniqueUpsertArgs>(args: SelectSubset<T, CharacterTechniqueUpsertArgs<ExtArgs>>): Prisma__CharacterTechniqueClient<$Result.GetResult<Prisma.$CharacterTechniquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterTechniques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueCountArgs} args - Arguments to filter CharacterTechniques to count.
     * @example
     * // Count the number of CharacterTechniques
     * const count = await prisma.characterTechnique.count({
     *   where: {
     *     // ... the filter for the CharacterTechniques we want to count
     *   }
     * })
    **/
    count<T extends CharacterTechniqueCountArgs>(
      args?: Subset<T, CharacterTechniqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterTechniqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterTechniqueAggregateArgs>(args: Subset<T, CharacterTechniqueAggregateArgs>): Prisma.PrismaPromise<GetCharacterTechniqueAggregateType<T>>

    /**
     * Group by CharacterTechnique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTechniqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterTechniqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterTechniqueGroupByArgs['orderBy'] }
        : { orderBy?: CharacterTechniqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterTechniqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterTechniqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterTechnique model
   */
  readonly fields: CharacterTechniqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterTechnique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterTechniqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    technique<T extends CultivationTechniqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CultivationTechniqueDefaultArgs<ExtArgs>>): Prisma__CultivationTechniqueClient<$Result.GetResult<Prisma.$CultivationTechniquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterTechnique model
   */
  interface CharacterTechniqueFieldRefs {
    readonly id: FieldRef<"CharacterTechnique", 'String'>
    readonly characterId: FieldRef<"CharacterTechnique", 'String'>
    readonly techniqueId: FieldRef<"CharacterTechnique", 'String'>
    readonly proficiency: FieldRef<"CharacterTechnique", 'Float'>
    readonly level: FieldRef<"CharacterTechnique", 'Int'>
    readonly experience: FieldRef<"CharacterTechnique", 'BigInt'>
    readonly masteryBonus: FieldRef<"CharacterTechnique", 'Float'>
    readonly learnedAt: FieldRef<"CharacterTechnique", 'DateTime'>
    readonly lastUsedAt: FieldRef<"CharacterTechnique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterTechnique findUnique
   */
  export type CharacterTechniqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTechnique to fetch.
     */
    where: CharacterTechniqueWhereUniqueInput
  }

  /**
   * CharacterTechnique findUniqueOrThrow
   */
  export type CharacterTechniqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTechnique to fetch.
     */
    where: CharacterTechniqueWhereUniqueInput
  }

  /**
   * CharacterTechnique findFirst
   */
  export type CharacterTechniqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTechnique to fetch.
     */
    where?: CharacterTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTechniques to fetch.
     */
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterTechniques.
     */
    cursor?: CharacterTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterTechniques.
     */
    distinct?: CharacterTechniqueScalarFieldEnum | CharacterTechniqueScalarFieldEnum[]
  }

  /**
   * CharacterTechnique findFirstOrThrow
   */
  export type CharacterTechniqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTechnique to fetch.
     */
    where?: CharacterTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTechniques to fetch.
     */
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterTechniques.
     */
    cursor?: CharacterTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTechniques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterTechniques.
     */
    distinct?: CharacterTechniqueScalarFieldEnum | CharacterTechniqueScalarFieldEnum[]
  }

  /**
   * CharacterTechnique findMany
   */
  export type CharacterTechniqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTechniques to fetch.
     */
    where?: CharacterTechniqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTechniques to fetch.
     */
    orderBy?: CharacterTechniqueOrderByWithRelationInput | CharacterTechniqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterTechniques.
     */
    cursor?: CharacterTechniqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTechniques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTechniques.
     */
    skip?: number
    distinct?: CharacterTechniqueScalarFieldEnum | CharacterTechniqueScalarFieldEnum[]
  }

  /**
   * CharacterTechnique create
   */
  export type CharacterTechniqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterTechnique.
     */
    data: XOR<CharacterTechniqueCreateInput, CharacterTechniqueUncheckedCreateInput>
  }

  /**
   * CharacterTechnique createMany
   */
  export type CharacterTechniqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterTechniques.
     */
    data: CharacterTechniqueCreateManyInput | CharacterTechniqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterTechnique createManyAndReturn
   */
  export type CharacterTechniqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterTechniques.
     */
    data: CharacterTechniqueCreateManyInput | CharacterTechniqueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterTechnique update
   */
  export type CharacterTechniqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterTechnique.
     */
    data: XOR<CharacterTechniqueUpdateInput, CharacterTechniqueUncheckedUpdateInput>
    /**
     * Choose, which CharacterTechnique to update.
     */
    where: CharacterTechniqueWhereUniqueInput
  }

  /**
   * CharacterTechnique updateMany
   */
  export type CharacterTechniqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterTechniques.
     */
    data: XOR<CharacterTechniqueUpdateManyMutationInput, CharacterTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which CharacterTechniques to update
     */
    where?: CharacterTechniqueWhereInput
    /**
     * Limit how many CharacterTechniques to update.
     */
    limit?: number
  }

  /**
   * CharacterTechnique updateManyAndReturn
   */
  export type CharacterTechniqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * The data used to update CharacterTechniques.
     */
    data: XOR<CharacterTechniqueUpdateManyMutationInput, CharacterTechniqueUncheckedUpdateManyInput>
    /**
     * Filter which CharacterTechniques to update
     */
    where?: CharacterTechniqueWhereInput
    /**
     * Limit how many CharacterTechniques to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterTechnique upsert
   */
  export type CharacterTechniqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterTechnique to update in case it exists.
     */
    where: CharacterTechniqueWhereUniqueInput
    /**
     * In case the CharacterTechnique found by the `where` argument doesn't exist, create a new CharacterTechnique with this data.
     */
    create: XOR<CharacterTechniqueCreateInput, CharacterTechniqueUncheckedCreateInput>
    /**
     * In case the CharacterTechnique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterTechniqueUpdateInput, CharacterTechniqueUncheckedUpdateInput>
  }

  /**
   * CharacterTechnique delete
   */
  export type CharacterTechniqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
    /**
     * Filter which CharacterTechnique to delete.
     */
    where: CharacterTechniqueWhereUniqueInput
  }

  /**
   * CharacterTechnique deleteMany
   */
  export type CharacterTechniqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterTechniques to delete
     */
    where?: CharacterTechniqueWhereInput
    /**
     * Limit how many CharacterTechniques to delete.
     */
    limit?: number
  }

  /**
   * CharacterTechnique without action
   */
  export type CharacterTechniqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTechnique
     */
    select?: CharacterTechniqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTechnique
     */
    omit?: CharacterTechniqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTechniqueInclude<ExtArgs> | null
  }


  /**
   * Model Talent
   */

  export type AggregateTalent = {
    _count: TalentCountAggregateOutputType | null
    _min: TalentMinAggregateOutputType | null
    _max: TalentMaxAggregateOutputType | null
  }

  export type TalentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TalentType | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TalentType | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TalentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    effects: number
    requirements: number
    rarity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TalentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TalentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    effects?: true
    requirements?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TalentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Talent to aggregate.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Talents
    **/
    _count?: true | TalentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TalentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TalentMaxAggregateInputType
  }

  export type GetTalentAggregateType<T extends TalentAggregateArgs> = {
        [P in keyof T & keyof AggregateTalent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTalent[P]>
      : GetScalarType<T[P], AggregateTalent[P]>
  }




  export type TalentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TalentWhereInput
    orderBy?: TalentOrderByWithAggregationInput | TalentOrderByWithAggregationInput[]
    by: TalentScalarFieldEnum[] | TalentScalarFieldEnum
    having?: TalentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TalentCountAggregateInputType | true
    _min?: TalentMinAggregateInputType
    _max?: TalentMaxAggregateInputType
  }

  export type TalentGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.TalentType
    effects: JsonValue
    requirements: JsonValue
    rarity: $Enums.ItemRarity
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TalentCountAggregateOutputType | null
    _min: TalentMinAggregateOutputType | null
    _max: TalentMaxAggregateOutputType | null
  }

  type GetTalentGroupByPayload<T extends TalentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TalentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TalentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TalentGroupByOutputType[P]>
            : GetScalarType<T[P], TalentGroupByOutputType[P]>
        }
      >
    >


  export type TalentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    effects?: boolean
    requirements?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characterTalents?: boolean | Talent$characterTalentsArgs<ExtArgs>
    _count?: boolean | TalentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["talent"]>

  export type TalentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    effects?: boolean
    requirements?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["talent"]>

  export type TalentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    effects?: boolean
    requirements?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["talent"]>

  export type TalentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    effects?: boolean
    requirements?: boolean
    rarity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TalentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "effects" | "requirements" | "rarity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["talent"]>
  export type TalentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterTalents?: boolean | Talent$characterTalentsArgs<ExtArgs>
    _count?: boolean | TalentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TalentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TalentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TalentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Talent"
    objects: {
      characterTalents: Prisma.$CharacterTalentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.TalentType
      effects: Prisma.JsonValue
      requirements: Prisma.JsonValue
      rarity: $Enums.ItemRarity
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["talent"]>
    composites: {}
  }

  type TalentGetPayload<S extends boolean | null | undefined | TalentDefaultArgs> = $Result.GetResult<Prisma.$TalentPayload, S>

  type TalentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TalentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TalentCountAggregateInputType | true
    }

  export interface TalentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Talent'], meta: { name: 'Talent' } }
    /**
     * Find zero or one Talent that matches the filter.
     * @param {TalentFindUniqueArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TalentFindUniqueArgs>(args: SelectSubset<T, TalentFindUniqueArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Talent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TalentFindUniqueOrThrowArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TalentFindUniqueOrThrowArgs>(args: SelectSubset<T, TalentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Talent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindFirstArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TalentFindFirstArgs>(args?: SelectSubset<T, TalentFindFirstArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Talent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindFirstOrThrowArgs} args - Arguments to find a Talent
     * @example
     * // Get one Talent
     * const talent = await prisma.talent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TalentFindFirstOrThrowArgs>(args?: SelectSubset<T, TalentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Talents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Talents
     * const talents = await prisma.talent.findMany()
     * 
     * // Get first 10 Talents
     * const talents = await prisma.talent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const talentWithIdOnly = await prisma.talent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TalentFindManyArgs>(args?: SelectSubset<T, TalentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Talent.
     * @param {TalentCreateArgs} args - Arguments to create a Talent.
     * @example
     * // Create one Talent
     * const Talent = await prisma.talent.create({
     *   data: {
     *     // ... data to create a Talent
     *   }
     * })
     * 
     */
    create<T extends TalentCreateArgs>(args: SelectSubset<T, TalentCreateArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Talents.
     * @param {TalentCreateManyArgs} args - Arguments to create many Talents.
     * @example
     * // Create many Talents
     * const talent = await prisma.talent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TalentCreateManyArgs>(args?: SelectSubset<T, TalentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Talents and returns the data saved in the database.
     * @param {TalentCreateManyAndReturnArgs} args - Arguments to create many Talents.
     * @example
     * // Create many Talents
     * const talent = await prisma.talent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Talents and only return the `id`
     * const talentWithIdOnly = await prisma.talent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TalentCreateManyAndReturnArgs>(args?: SelectSubset<T, TalentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Talent.
     * @param {TalentDeleteArgs} args - Arguments to delete one Talent.
     * @example
     * // Delete one Talent
     * const Talent = await prisma.talent.delete({
     *   where: {
     *     // ... filter to delete one Talent
     *   }
     * })
     * 
     */
    delete<T extends TalentDeleteArgs>(args: SelectSubset<T, TalentDeleteArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Talent.
     * @param {TalentUpdateArgs} args - Arguments to update one Talent.
     * @example
     * // Update one Talent
     * const talent = await prisma.talent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TalentUpdateArgs>(args: SelectSubset<T, TalentUpdateArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Talents.
     * @param {TalentDeleteManyArgs} args - Arguments to filter Talents to delete.
     * @example
     * // Delete a few Talents
     * const { count } = await prisma.talent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TalentDeleteManyArgs>(args?: SelectSubset<T, TalentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Talents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Talents
     * const talent = await prisma.talent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TalentUpdateManyArgs>(args: SelectSubset<T, TalentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Talents and returns the data updated in the database.
     * @param {TalentUpdateManyAndReturnArgs} args - Arguments to update many Talents.
     * @example
     * // Update many Talents
     * const talent = await prisma.talent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Talents and only return the `id`
     * const talentWithIdOnly = await prisma.talent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TalentUpdateManyAndReturnArgs>(args: SelectSubset<T, TalentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Talent.
     * @param {TalentUpsertArgs} args - Arguments to update or create a Talent.
     * @example
     * // Update or create a Talent
     * const talent = await prisma.talent.upsert({
     *   create: {
     *     // ... data to create a Talent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Talent we want to update
     *   }
     * })
     */
    upsert<T extends TalentUpsertArgs>(args: SelectSubset<T, TalentUpsertArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Talents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentCountArgs} args - Arguments to filter Talents to count.
     * @example
     * // Count the number of Talents
     * const count = await prisma.talent.count({
     *   where: {
     *     // ... the filter for the Talents we want to count
     *   }
     * })
    **/
    count<T extends TalentCountArgs>(
      args?: Subset<T, TalentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TalentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Talent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TalentAggregateArgs>(args: Subset<T, TalentAggregateArgs>): Prisma.PrismaPromise<GetTalentAggregateType<T>>

    /**
     * Group by Talent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TalentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TalentGroupByArgs['orderBy'] }
        : { orderBy?: TalentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TalentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTalentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Talent model
   */
  readonly fields: TalentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Talent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TalentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characterTalents<T extends Talent$characterTalentsArgs<ExtArgs> = {}>(args?: Subset<T, Talent$characterTalentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Talent model
   */
  interface TalentFieldRefs {
    readonly id: FieldRef<"Talent", 'String'>
    readonly name: FieldRef<"Talent", 'String'>
    readonly description: FieldRef<"Talent", 'String'>
    readonly type: FieldRef<"Talent", 'TalentType'>
    readonly effects: FieldRef<"Talent", 'Json'>
    readonly requirements: FieldRef<"Talent", 'Json'>
    readonly rarity: FieldRef<"Talent", 'ItemRarity'>
    readonly isActive: FieldRef<"Talent", 'Boolean'>
    readonly createdAt: FieldRef<"Talent", 'DateTime'>
    readonly updatedAt: FieldRef<"Talent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Talent findUnique
   */
  export type TalentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent findUniqueOrThrow
   */
  export type TalentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent findFirst
   */
  export type TalentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Talents.
     */
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent findFirstOrThrow
   */
  export type TalentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talent to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Talents.
     */
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent findMany
   */
  export type TalentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter, which Talents to fetch.
     */
    where?: TalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Talents to fetch.
     */
    orderBy?: TalentOrderByWithRelationInput | TalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Talents.
     */
    cursor?: TalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Talents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Talents.
     */
    skip?: number
    distinct?: TalentScalarFieldEnum | TalentScalarFieldEnum[]
  }

  /**
   * Talent create
   */
  export type TalentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The data needed to create a Talent.
     */
    data: XOR<TalentCreateInput, TalentUncheckedCreateInput>
  }

  /**
   * Talent createMany
   */
  export type TalentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Talents.
     */
    data: TalentCreateManyInput | TalentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Talent createManyAndReturn
   */
  export type TalentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * The data used to create many Talents.
     */
    data: TalentCreateManyInput | TalentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Talent update
   */
  export type TalentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The data needed to update a Talent.
     */
    data: XOR<TalentUpdateInput, TalentUncheckedUpdateInput>
    /**
     * Choose, which Talent to update.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent updateMany
   */
  export type TalentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Talents.
     */
    data: XOR<TalentUpdateManyMutationInput, TalentUncheckedUpdateManyInput>
    /**
     * Filter which Talents to update
     */
    where?: TalentWhereInput
    /**
     * Limit how many Talents to update.
     */
    limit?: number
  }

  /**
   * Talent updateManyAndReturn
   */
  export type TalentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * The data used to update Talents.
     */
    data: XOR<TalentUpdateManyMutationInput, TalentUncheckedUpdateManyInput>
    /**
     * Filter which Talents to update
     */
    where?: TalentWhereInput
    /**
     * Limit how many Talents to update.
     */
    limit?: number
  }

  /**
   * Talent upsert
   */
  export type TalentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * The filter to search for the Talent to update in case it exists.
     */
    where: TalentWhereUniqueInput
    /**
     * In case the Talent found by the `where` argument doesn't exist, create a new Talent with this data.
     */
    create: XOR<TalentCreateInput, TalentUncheckedCreateInput>
    /**
     * In case the Talent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TalentUpdateInput, TalentUncheckedUpdateInput>
  }

  /**
   * Talent delete
   */
  export type TalentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
    /**
     * Filter which Talent to delete.
     */
    where: TalentWhereUniqueInput
  }

  /**
   * Talent deleteMany
   */
  export type TalentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Talents to delete
     */
    where?: TalentWhereInput
    /**
     * Limit how many Talents to delete.
     */
    limit?: number
  }

  /**
   * Talent.characterTalents
   */
  export type Talent$characterTalentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    where?: CharacterTalentWhereInput
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    cursor?: CharacterTalentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterTalentScalarFieldEnum | CharacterTalentScalarFieldEnum[]
  }

  /**
   * Talent without action
   */
  export type TalentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Talent
     */
    select?: TalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Talent
     */
    omit?: TalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TalentInclude<ExtArgs> | null
  }


  /**
   * Model CharacterTalent
   */

  export type AggregateCharacterTalent = {
    _count: CharacterTalentCountAggregateOutputType | null
    _min: CharacterTalentMinAggregateOutputType | null
    _max: CharacterTalentMaxAggregateOutputType | null
  }

  export type CharacterTalentMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    talentId: string | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
  }

  export type CharacterTalentMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    talentId: string | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
  }

  export type CharacterTalentCountAggregateOutputType = {
    id: number
    characterId: number
    talentId: number
    isUnlocked: number
    unlockedAt: number
    _all: number
  }


  export type CharacterTalentMinAggregateInputType = {
    id?: true
    characterId?: true
    talentId?: true
    isUnlocked?: true
    unlockedAt?: true
  }

  export type CharacterTalentMaxAggregateInputType = {
    id?: true
    characterId?: true
    talentId?: true
    isUnlocked?: true
    unlockedAt?: true
  }

  export type CharacterTalentCountAggregateInputType = {
    id?: true
    characterId?: true
    talentId?: true
    isUnlocked?: true
    unlockedAt?: true
    _all?: true
  }

  export type CharacterTalentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterTalent to aggregate.
     */
    where?: CharacterTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTalents to fetch.
     */
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterTalents
    **/
    _count?: true | CharacterTalentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterTalentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterTalentMaxAggregateInputType
  }

  export type GetCharacterTalentAggregateType<T extends CharacterTalentAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterTalent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterTalent[P]>
      : GetScalarType<T[P], AggregateCharacterTalent[P]>
  }




  export type CharacterTalentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterTalentWhereInput
    orderBy?: CharacterTalentOrderByWithAggregationInput | CharacterTalentOrderByWithAggregationInput[]
    by: CharacterTalentScalarFieldEnum[] | CharacterTalentScalarFieldEnum
    having?: CharacterTalentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterTalentCountAggregateInputType | true
    _min?: CharacterTalentMinAggregateInputType
    _max?: CharacterTalentMaxAggregateInputType
  }

  export type CharacterTalentGroupByOutputType = {
    id: string
    characterId: string
    talentId: string
    isUnlocked: boolean
    unlockedAt: Date | null
    _count: CharacterTalentCountAggregateOutputType | null
    _min: CharacterTalentMinAggregateOutputType | null
    _max: CharacterTalentMaxAggregateOutputType | null
  }

  type GetCharacterTalentGroupByPayload<T extends CharacterTalentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterTalentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterTalentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterTalentGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterTalentGroupByOutputType[P]>
        }
      >
    >


  export type CharacterTalentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    talentId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTalent"]>

  export type CharacterTalentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    talentId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTalent"]>

  export type CharacterTalentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    talentId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterTalent"]>

  export type CharacterTalentSelectScalar = {
    id?: boolean
    characterId?: boolean
    talentId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
  }

  export type CharacterTalentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "talentId" | "isUnlocked" | "unlockedAt", ExtArgs["result"]["characterTalent"]>
  export type CharacterTalentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }
  export type CharacterTalentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }
  export type CharacterTalentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    talent?: boolean | TalentDefaultArgs<ExtArgs>
  }

  export type $CharacterTalentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterTalent"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      talent: Prisma.$TalentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      talentId: string
      isUnlocked: boolean
      unlockedAt: Date | null
    }, ExtArgs["result"]["characterTalent"]>
    composites: {}
  }

  type CharacterTalentGetPayload<S extends boolean | null | undefined | CharacterTalentDefaultArgs> = $Result.GetResult<Prisma.$CharacterTalentPayload, S>

  type CharacterTalentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterTalentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterTalentCountAggregateInputType | true
    }

  export interface CharacterTalentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterTalent'], meta: { name: 'CharacterTalent' } }
    /**
     * Find zero or one CharacterTalent that matches the filter.
     * @param {CharacterTalentFindUniqueArgs} args - Arguments to find a CharacterTalent
     * @example
     * // Get one CharacterTalent
     * const characterTalent = await prisma.characterTalent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterTalentFindUniqueArgs>(args: SelectSubset<T, CharacterTalentFindUniqueArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterTalent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterTalentFindUniqueOrThrowArgs} args - Arguments to find a CharacterTalent
     * @example
     * // Get one CharacterTalent
     * const characterTalent = await prisma.characterTalent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterTalentFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterTalentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterTalent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentFindFirstArgs} args - Arguments to find a CharacterTalent
     * @example
     * // Get one CharacterTalent
     * const characterTalent = await prisma.characterTalent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterTalentFindFirstArgs>(args?: SelectSubset<T, CharacterTalentFindFirstArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterTalent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentFindFirstOrThrowArgs} args - Arguments to find a CharacterTalent
     * @example
     * // Get one CharacterTalent
     * const characterTalent = await prisma.characterTalent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterTalentFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterTalentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterTalents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterTalents
     * const characterTalents = await prisma.characterTalent.findMany()
     * 
     * // Get first 10 CharacterTalents
     * const characterTalents = await prisma.characterTalent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterTalentWithIdOnly = await prisma.characterTalent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterTalentFindManyArgs>(args?: SelectSubset<T, CharacterTalentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterTalent.
     * @param {CharacterTalentCreateArgs} args - Arguments to create a CharacterTalent.
     * @example
     * // Create one CharacterTalent
     * const CharacterTalent = await prisma.characterTalent.create({
     *   data: {
     *     // ... data to create a CharacterTalent
     *   }
     * })
     * 
     */
    create<T extends CharacterTalentCreateArgs>(args: SelectSubset<T, CharacterTalentCreateArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterTalents.
     * @param {CharacterTalentCreateManyArgs} args - Arguments to create many CharacterTalents.
     * @example
     * // Create many CharacterTalents
     * const characterTalent = await prisma.characterTalent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterTalentCreateManyArgs>(args?: SelectSubset<T, CharacterTalentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterTalents and returns the data saved in the database.
     * @param {CharacterTalentCreateManyAndReturnArgs} args - Arguments to create many CharacterTalents.
     * @example
     * // Create many CharacterTalents
     * const characterTalent = await prisma.characterTalent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterTalents and only return the `id`
     * const characterTalentWithIdOnly = await prisma.characterTalent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterTalentCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterTalentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterTalent.
     * @param {CharacterTalentDeleteArgs} args - Arguments to delete one CharacterTalent.
     * @example
     * // Delete one CharacterTalent
     * const CharacterTalent = await prisma.characterTalent.delete({
     *   where: {
     *     // ... filter to delete one CharacterTalent
     *   }
     * })
     * 
     */
    delete<T extends CharacterTalentDeleteArgs>(args: SelectSubset<T, CharacterTalentDeleteArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterTalent.
     * @param {CharacterTalentUpdateArgs} args - Arguments to update one CharacterTalent.
     * @example
     * // Update one CharacterTalent
     * const characterTalent = await prisma.characterTalent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterTalentUpdateArgs>(args: SelectSubset<T, CharacterTalentUpdateArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterTalents.
     * @param {CharacterTalentDeleteManyArgs} args - Arguments to filter CharacterTalents to delete.
     * @example
     * // Delete a few CharacterTalents
     * const { count } = await prisma.characterTalent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterTalentDeleteManyArgs>(args?: SelectSubset<T, CharacterTalentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterTalents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterTalents
     * const characterTalent = await prisma.characterTalent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterTalentUpdateManyArgs>(args: SelectSubset<T, CharacterTalentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterTalents and returns the data updated in the database.
     * @param {CharacterTalentUpdateManyAndReturnArgs} args - Arguments to update many CharacterTalents.
     * @example
     * // Update many CharacterTalents
     * const characterTalent = await prisma.characterTalent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterTalents and only return the `id`
     * const characterTalentWithIdOnly = await prisma.characterTalent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterTalentUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterTalentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterTalent.
     * @param {CharacterTalentUpsertArgs} args - Arguments to update or create a CharacterTalent.
     * @example
     * // Update or create a CharacterTalent
     * const characterTalent = await prisma.characterTalent.upsert({
     *   create: {
     *     // ... data to create a CharacterTalent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterTalent we want to update
     *   }
     * })
     */
    upsert<T extends CharacterTalentUpsertArgs>(args: SelectSubset<T, CharacterTalentUpsertArgs<ExtArgs>>): Prisma__CharacterTalentClient<$Result.GetResult<Prisma.$CharacterTalentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterTalents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentCountArgs} args - Arguments to filter CharacterTalents to count.
     * @example
     * // Count the number of CharacterTalents
     * const count = await prisma.characterTalent.count({
     *   where: {
     *     // ... the filter for the CharacterTalents we want to count
     *   }
     * })
    **/
    count<T extends CharacterTalentCountArgs>(
      args?: Subset<T, CharacterTalentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterTalentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterTalent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterTalentAggregateArgs>(args: Subset<T, CharacterTalentAggregateArgs>): Prisma.PrismaPromise<GetCharacterTalentAggregateType<T>>

    /**
     * Group by CharacterTalent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterTalentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterTalentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterTalentGroupByArgs['orderBy'] }
        : { orderBy?: CharacterTalentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterTalentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterTalentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterTalent model
   */
  readonly fields: CharacterTalentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterTalent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterTalentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    talent<T extends TalentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TalentDefaultArgs<ExtArgs>>): Prisma__TalentClient<$Result.GetResult<Prisma.$TalentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterTalent model
   */
  interface CharacterTalentFieldRefs {
    readonly id: FieldRef<"CharacterTalent", 'String'>
    readonly characterId: FieldRef<"CharacterTalent", 'String'>
    readonly talentId: FieldRef<"CharacterTalent", 'String'>
    readonly isUnlocked: FieldRef<"CharacterTalent", 'Boolean'>
    readonly unlockedAt: FieldRef<"CharacterTalent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterTalent findUnique
   */
  export type CharacterTalentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTalent to fetch.
     */
    where: CharacterTalentWhereUniqueInput
  }

  /**
   * CharacterTalent findUniqueOrThrow
   */
  export type CharacterTalentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTalent to fetch.
     */
    where: CharacterTalentWhereUniqueInput
  }

  /**
   * CharacterTalent findFirst
   */
  export type CharacterTalentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTalent to fetch.
     */
    where?: CharacterTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTalents to fetch.
     */
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterTalents.
     */
    cursor?: CharacterTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterTalents.
     */
    distinct?: CharacterTalentScalarFieldEnum | CharacterTalentScalarFieldEnum[]
  }

  /**
   * CharacterTalent findFirstOrThrow
   */
  export type CharacterTalentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTalent to fetch.
     */
    where?: CharacterTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTalents to fetch.
     */
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterTalents.
     */
    cursor?: CharacterTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTalents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterTalents.
     */
    distinct?: CharacterTalentScalarFieldEnum | CharacterTalentScalarFieldEnum[]
  }

  /**
   * CharacterTalent findMany
   */
  export type CharacterTalentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterTalents to fetch.
     */
    where?: CharacterTalentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterTalents to fetch.
     */
    orderBy?: CharacterTalentOrderByWithRelationInput | CharacterTalentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterTalents.
     */
    cursor?: CharacterTalentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterTalents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterTalents.
     */
    skip?: number
    distinct?: CharacterTalentScalarFieldEnum | CharacterTalentScalarFieldEnum[]
  }

  /**
   * CharacterTalent create
   */
  export type CharacterTalentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterTalent.
     */
    data: XOR<CharacterTalentCreateInput, CharacterTalentUncheckedCreateInput>
  }

  /**
   * CharacterTalent createMany
   */
  export type CharacterTalentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterTalents.
     */
    data: CharacterTalentCreateManyInput | CharacterTalentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterTalent createManyAndReturn
   */
  export type CharacterTalentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterTalents.
     */
    data: CharacterTalentCreateManyInput | CharacterTalentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterTalent update
   */
  export type CharacterTalentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterTalent.
     */
    data: XOR<CharacterTalentUpdateInput, CharacterTalentUncheckedUpdateInput>
    /**
     * Choose, which CharacterTalent to update.
     */
    where: CharacterTalentWhereUniqueInput
  }

  /**
   * CharacterTalent updateMany
   */
  export type CharacterTalentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterTalents.
     */
    data: XOR<CharacterTalentUpdateManyMutationInput, CharacterTalentUncheckedUpdateManyInput>
    /**
     * Filter which CharacterTalents to update
     */
    where?: CharacterTalentWhereInput
    /**
     * Limit how many CharacterTalents to update.
     */
    limit?: number
  }

  /**
   * CharacterTalent updateManyAndReturn
   */
  export type CharacterTalentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * The data used to update CharacterTalents.
     */
    data: XOR<CharacterTalentUpdateManyMutationInput, CharacterTalentUncheckedUpdateManyInput>
    /**
     * Filter which CharacterTalents to update
     */
    where?: CharacterTalentWhereInput
    /**
     * Limit how many CharacterTalents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterTalent upsert
   */
  export type CharacterTalentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterTalent to update in case it exists.
     */
    where: CharacterTalentWhereUniqueInput
    /**
     * In case the CharacterTalent found by the `where` argument doesn't exist, create a new CharacterTalent with this data.
     */
    create: XOR<CharacterTalentCreateInput, CharacterTalentUncheckedCreateInput>
    /**
     * In case the CharacterTalent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterTalentUpdateInput, CharacterTalentUncheckedUpdateInput>
  }

  /**
   * CharacterTalent delete
   */
  export type CharacterTalentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
    /**
     * Filter which CharacterTalent to delete.
     */
    where: CharacterTalentWhereUniqueInput
  }

  /**
   * CharacterTalent deleteMany
   */
  export type CharacterTalentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterTalents to delete
     */
    where?: CharacterTalentWhereInput
    /**
     * Limit how many CharacterTalents to delete.
     */
    limit?: number
  }

  /**
   * CharacterTalent without action
   */
  export type CharacterTalentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterTalent
     */
    select?: CharacterTalentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterTalent
     */
    omit?: CharacterTalentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterTalentInclude<ExtArgs> | null
  }


  /**
   * Model Bloodline
   */

  export type AggregateBloodline = {
    _count: BloodlineCountAggregateOutputType | null
    _min: BloodlineMinAggregateOutputType | null
    _max: BloodlineMaxAggregateOutputType | null
  }

  export type BloodlineMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BloodlineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rarity: $Enums.ItemRarity | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BloodlineCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rarity: number
    abilities: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BloodlineMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BloodlineMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rarity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BloodlineCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rarity?: true
    abilities?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BloodlineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bloodline to aggregate.
     */
    where?: BloodlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bloodlines to fetch.
     */
    orderBy?: BloodlineOrderByWithRelationInput | BloodlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BloodlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bloodlines
    **/
    _count?: true | BloodlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BloodlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BloodlineMaxAggregateInputType
  }

  export type GetBloodlineAggregateType<T extends BloodlineAggregateArgs> = {
        [P in keyof T & keyof AggregateBloodline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloodline[P]>
      : GetScalarType<T[P], AggregateBloodline[P]>
  }




  export type BloodlineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BloodlineWhereInput
    orderBy?: BloodlineOrderByWithAggregationInput | BloodlineOrderByWithAggregationInput[]
    by: BloodlineScalarFieldEnum[] | BloodlineScalarFieldEnum
    having?: BloodlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BloodlineCountAggregateInputType | true
    _min?: BloodlineMinAggregateInputType
    _max?: BloodlineMaxAggregateInputType
  }

  export type BloodlineGroupByOutputType = {
    id: string
    name: string
    description: string
    rarity: $Enums.ItemRarity
    abilities: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BloodlineCountAggregateOutputType | null
    _min: BloodlineMinAggregateOutputType | null
    _max: BloodlineMaxAggregateOutputType | null
  }

  type GetBloodlineGroupByPayload<T extends BloodlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BloodlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BloodlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BloodlineGroupByOutputType[P]>
            : GetScalarType<T[P], BloodlineGroupByOutputType[P]>
        }
      >
    >


  export type BloodlineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rarity?: boolean
    abilities?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characters?: boolean | Bloodline$charactersArgs<ExtArgs>
    _count?: boolean | BloodlineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodline"]>

  export type BloodlineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rarity?: boolean
    abilities?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bloodline"]>

  export type BloodlineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rarity?: boolean
    abilities?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bloodline"]>

  export type BloodlineSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rarity?: boolean
    abilities?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BloodlineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rarity" | "abilities" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["bloodline"]>
  export type BloodlineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | Bloodline$charactersArgs<ExtArgs>
    _count?: boolean | BloodlineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BloodlineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BloodlineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BloodlinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bloodline"
    objects: {
      characters: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      rarity: $Enums.ItemRarity
      abilities: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bloodline"]>
    composites: {}
  }

  type BloodlineGetPayload<S extends boolean | null | undefined | BloodlineDefaultArgs> = $Result.GetResult<Prisma.$BloodlinePayload, S>

  type BloodlineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BloodlineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BloodlineCountAggregateInputType | true
    }

  export interface BloodlineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bloodline'], meta: { name: 'Bloodline' } }
    /**
     * Find zero or one Bloodline that matches the filter.
     * @param {BloodlineFindUniqueArgs} args - Arguments to find a Bloodline
     * @example
     * // Get one Bloodline
     * const bloodline = await prisma.bloodline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BloodlineFindUniqueArgs>(args: SelectSubset<T, BloodlineFindUniqueArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bloodline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BloodlineFindUniqueOrThrowArgs} args - Arguments to find a Bloodline
     * @example
     * // Get one Bloodline
     * const bloodline = await prisma.bloodline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BloodlineFindUniqueOrThrowArgs>(args: SelectSubset<T, BloodlineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bloodline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineFindFirstArgs} args - Arguments to find a Bloodline
     * @example
     * // Get one Bloodline
     * const bloodline = await prisma.bloodline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BloodlineFindFirstArgs>(args?: SelectSubset<T, BloodlineFindFirstArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bloodline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineFindFirstOrThrowArgs} args - Arguments to find a Bloodline
     * @example
     * // Get one Bloodline
     * const bloodline = await prisma.bloodline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BloodlineFindFirstOrThrowArgs>(args?: SelectSubset<T, BloodlineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bloodlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bloodlines
     * const bloodlines = await prisma.bloodline.findMany()
     * 
     * // Get first 10 Bloodlines
     * const bloodlines = await prisma.bloodline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bloodlineWithIdOnly = await prisma.bloodline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BloodlineFindManyArgs>(args?: SelectSubset<T, BloodlineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bloodline.
     * @param {BloodlineCreateArgs} args - Arguments to create a Bloodline.
     * @example
     * // Create one Bloodline
     * const Bloodline = await prisma.bloodline.create({
     *   data: {
     *     // ... data to create a Bloodline
     *   }
     * })
     * 
     */
    create<T extends BloodlineCreateArgs>(args: SelectSubset<T, BloodlineCreateArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bloodlines.
     * @param {BloodlineCreateManyArgs} args - Arguments to create many Bloodlines.
     * @example
     * // Create many Bloodlines
     * const bloodline = await prisma.bloodline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BloodlineCreateManyArgs>(args?: SelectSubset<T, BloodlineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bloodlines and returns the data saved in the database.
     * @param {BloodlineCreateManyAndReturnArgs} args - Arguments to create many Bloodlines.
     * @example
     * // Create many Bloodlines
     * const bloodline = await prisma.bloodline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bloodlines and only return the `id`
     * const bloodlineWithIdOnly = await prisma.bloodline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BloodlineCreateManyAndReturnArgs>(args?: SelectSubset<T, BloodlineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bloodline.
     * @param {BloodlineDeleteArgs} args - Arguments to delete one Bloodline.
     * @example
     * // Delete one Bloodline
     * const Bloodline = await prisma.bloodline.delete({
     *   where: {
     *     // ... filter to delete one Bloodline
     *   }
     * })
     * 
     */
    delete<T extends BloodlineDeleteArgs>(args: SelectSubset<T, BloodlineDeleteArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bloodline.
     * @param {BloodlineUpdateArgs} args - Arguments to update one Bloodline.
     * @example
     * // Update one Bloodline
     * const bloodline = await prisma.bloodline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BloodlineUpdateArgs>(args: SelectSubset<T, BloodlineUpdateArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bloodlines.
     * @param {BloodlineDeleteManyArgs} args - Arguments to filter Bloodlines to delete.
     * @example
     * // Delete a few Bloodlines
     * const { count } = await prisma.bloodline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BloodlineDeleteManyArgs>(args?: SelectSubset<T, BloodlineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bloodlines
     * const bloodline = await prisma.bloodline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BloodlineUpdateManyArgs>(args: SelectSubset<T, BloodlineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bloodlines and returns the data updated in the database.
     * @param {BloodlineUpdateManyAndReturnArgs} args - Arguments to update many Bloodlines.
     * @example
     * // Update many Bloodlines
     * const bloodline = await prisma.bloodline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bloodlines and only return the `id`
     * const bloodlineWithIdOnly = await prisma.bloodline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BloodlineUpdateManyAndReturnArgs>(args: SelectSubset<T, BloodlineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bloodline.
     * @param {BloodlineUpsertArgs} args - Arguments to update or create a Bloodline.
     * @example
     * // Update or create a Bloodline
     * const bloodline = await prisma.bloodline.upsert({
     *   create: {
     *     // ... data to create a Bloodline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bloodline we want to update
     *   }
     * })
     */
    upsert<T extends BloodlineUpsertArgs>(args: SelectSubset<T, BloodlineUpsertArgs<ExtArgs>>): Prisma__BloodlineClient<$Result.GetResult<Prisma.$BloodlinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bloodlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineCountArgs} args - Arguments to filter Bloodlines to count.
     * @example
     * // Count the number of Bloodlines
     * const count = await prisma.bloodline.count({
     *   where: {
     *     // ... the filter for the Bloodlines we want to count
     *   }
     * })
    **/
    count<T extends BloodlineCountArgs>(
      args?: Subset<T, BloodlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BloodlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bloodline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BloodlineAggregateArgs>(args: Subset<T, BloodlineAggregateArgs>): Prisma.PrismaPromise<GetBloodlineAggregateType<T>>

    /**
     * Group by Bloodline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BloodlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BloodlineGroupByArgs['orderBy'] }
        : { orderBy?: BloodlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BloodlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBloodlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bloodline model
   */
  readonly fields: BloodlineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bloodline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BloodlineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends Bloodline$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Bloodline$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bloodline model
   */
  interface BloodlineFieldRefs {
    readonly id: FieldRef<"Bloodline", 'String'>
    readonly name: FieldRef<"Bloodline", 'String'>
    readonly description: FieldRef<"Bloodline", 'String'>
    readonly rarity: FieldRef<"Bloodline", 'ItemRarity'>
    readonly abilities: FieldRef<"Bloodline", 'Json'>
    readonly isActive: FieldRef<"Bloodline", 'Boolean'>
    readonly createdAt: FieldRef<"Bloodline", 'DateTime'>
    readonly updatedAt: FieldRef<"Bloodline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bloodline findUnique
   */
  export type BloodlineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter, which Bloodline to fetch.
     */
    where: BloodlineWhereUniqueInput
  }

  /**
   * Bloodline findUniqueOrThrow
   */
  export type BloodlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter, which Bloodline to fetch.
     */
    where: BloodlineWhereUniqueInput
  }

  /**
   * Bloodline findFirst
   */
  export type BloodlineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter, which Bloodline to fetch.
     */
    where?: BloodlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bloodlines to fetch.
     */
    orderBy?: BloodlineOrderByWithRelationInput | BloodlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bloodlines.
     */
    cursor?: BloodlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bloodlines.
     */
    distinct?: BloodlineScalarFieldEnum | BloodlineScalarFieldEnum[]
  }

  /**
   * Bloodline findFirstOrThrow
   */
  export type BloodlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter, which Bloodline to fetch.
     */
    where?: BloodlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bloodlines to fetch.
     */
    orderBy?: BloodlineOrderByWithRelationInput | BloodlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bloodlines.
     */
    cursor?: BloodlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bloodlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bloodlines.
     */
    distinct?: BloodlineScalarFieldEnum | BloodlineScalarFieldEnum[]
  }

  /**
   * Bloodline findMany
   */
  export type BloodlineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter, which Bloodlines to fetch.
     */
    where?: BloodlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bloodlines to fetch.
     */
    orderBy?: BloodlineOrderByWithRelationInput | BloodlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bloodlines.
     */
    cursor?: BloodlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bloodlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bloodlines.
     */
    skip?: number
    distinct?: BloodlineScalarFieldEnum | BloodlineScalarFieldEnum[]
  }

  /**
   * Bloodline create
   */
  export type BloodlineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * The data needed to create a Bloodline.
     */
    data: XOR<BloodlineCreateInput, BloodlineUncheckedCreateInput>
  }

  /**
   * Bloodline createMany
   */
  export type BloodlineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bloodlines.
     */
    data: BloodlineCreateManyInput | BloodlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bloodline createManyAndReturn
   */
  export type BloodlineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * The data used to create many Bloodlines.
     */
    data: BloodlineCreateManyInput | BloodlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bloodline update
   */
  export type BloodlineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * The data needed to update a Bloodline.
     */
    data: XOR<BloodlineUpdateInput, BloodlineUncheckedUpdateInput>
    /**
     * Choose, which Bloodline to update.
     */
    where: BloodlineWhereUniqueInput
  }

  /**
   * Bloodline updateMany
   */
  export type BloodlineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bloodlines.
     */
    data: XOR<BloodlineUpdateManyMutationInput, BloodlineUncheckedUpdateManyInput>
    /**
     * Filter which Bloodlines to update
     */
    where?: BloodlineWhereInput
    /**
     * Limit how many Bloodlines to update.
     */
    limit?: number
  }

  /**
   * Bloodline updateManyAndReturn
   */
  export type BloodlineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * The data used to update Bloodlines.
     */
    data: XOR<BloodlineUpdateManyMutationInput, BloodlineUncheckedUpdateManyInput>
    /**
     * Filter which Bloodlines to update
     */
    where?: BloodlineWhereInput
    /**
     * Limit how many Bloodlines to update.
     */
    limit?: number
  }

  /**
   * Bloodline upsert
   */
  export type BloodlineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * The filter to search for the Bloodline to update in case it exists.
     */
    where: BloodlineWhereUniqueInput
    /**
     * In case the Bloodline found by the `where` argument doesn't exist, create a new Bloodline with this data.
     */
    create: XOR<BloodlineCreateInput, BloodlineUncheckedCreateInput>
    /**
     * In case the Bloodline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BloodlineUpdateInput, BloodlineUncheckedUpdateInput>
  }

  /**
   * Bloodline delete
   */
  export type BloodlineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
    /**
     * Filter which Bloodline to delete.
     */
    where: BloodlineWhereUniqueInput
  }

  /**
   * Bloodline deleteMany
   */
  export type BloodlineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bloodlines to delete
     */
    where?: BloodlineWhereInput
    /**
     * Limit how many Bloodlines to delete.
     */
    limit?: number
  }

  /**
   * Bloodline.characters
   */
  export type Bloodline$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Bloodline without action
   */
  export type BloodlineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bloodline
     */
    select?: BloodlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bloodline
     */
    omit?: BloodlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodlineInclude<ExtArgs> | null
  }


  /**
   * Model Resources
   */

  export type AggregateResources = {
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  export type ResourcesAvgAggregateOutputType = {
    spiritStones: number | null
    gold: number | null
  }

  export type ResourcesSumAggregateOutputType = {
    spiritStones: bigint | null
    gold: bigint | null
  }

  export type ResourcesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    spiritStones: bigint | null
    gold: bigint | null
    lastUpdated: Date | null
  }

  export type ResourcesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    spiritStones: bigint | null
    gold: bigint | null
    lastUpdated: Date | null
  }

  export type ResourcesCountAggregateOutputType = {
    id: number
    userId: number
    spiritStones: number
    gold: number
    materials: number
    pills: number
    herbs: number
    lastUpdated: number
    _all: number
  }


  export type ResourcesAvgAggregateInputType = {
    spiritStones?: true
    gold?: true
  }

  export type ResourcesSumAggregateInputType = {
    spiritStones?: true
    gold?: true
  }

  export type ResourcesMinAggregateInputType = {
    id?: true
    userId?: true
    spiritStones?: true
    gold?: true
    lastUpdated?: true
  }

  export type ResourcesMaxAggregateInputType = {
    id?: true
    userId?: true
    spiritStones?: true
    gold?: true
    lastUpdated?: true
  }

  export type ResourcesCountAggregateInputType = {
    id?: true
    userId?: true
    spiritStones?: true
    gold?: true
    materials?: true
    pills?: true
    herbs?: true
    lastUpdated?: true
    _all?: true
  }

  export type ResourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to aggregate.
     */
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourcesOrderByWithRelationInput | ResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourcesMaxAggregateInputType
  }

  export type GetResourcesAggregateType<T extends ResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResources[P]>
      : GetScalarType<T[P], AggregateResources[P]>
  }




  export type ResourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourcesWhereInput
    orderBy?: ResourcesOrderByWithAggregationInput | ResourcesOrderByWithAggregationInput[]
    by: ResourcesScalarFieldEnum[] | ResourcesScalarFieldEnum
    having?: ResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourcesCountAggregateInputType | true
    _avg?: ResourcesAvgAggregateInputType
    _sum?: ResourcesSumAggregateInputType
    _min?: ResourcesMinAggregateInputType
    _max?: ResourcesMaxAggregateInputType
  }

  export type ResourcesGroupByOutputType = {
    id: string
    userId: string
    spiritStones: bigint
    gold: bigint
    materials: JsonValue
    pills: JsonValue
    herbs: JsonValue
    lastUpdated: Date
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  type GetResourcesGroupByPayload<T extends ResourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
        }
      >
    >


  export type ResourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    spiritStones?: boolean
    gold?: boolean
    materials?: boolean
    pills?: boolean
    herbs?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resources"]>

  export type ResourcesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    spiritStones?: boolean
    gold?: boolean
    materials?: boolean
    pills?: boolean
    herbs?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resources"]>

  export type ResourcesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    spiritStones?: boolean
    gold?: boolean
    materials?: boolean
    pills?: boolean
    herbs?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resources"]>

  export type ResourcesSelectScalar = {
    id?: boolean
    userId?: boolean
    spiritStones?: boolean
    gold?: boolean
    materials?: boolean
    pills?: boolean
    herbs?: boolean
    lastUpdated?: boolean
  }

  export type ResourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "spiritStones" | "gold" | "materials" | "pills" | "herbs" | "lastUpdated", ExtArgs["result"]["resources"]>
  export type ResourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourcesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResourcesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resources"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      spiritStones: bigint
      gold: bigint
      materials: Prisma.JsonValue
      pills: Prisma.JsonValue
      herbs: Prisma.JsonValue
      lastUpdated: Date
    }, ExtArgs["result"]["resources"]>
    composites: {}
  }

  type ResourcesGetPayload<S extends boolean | null | undefined | ResourcesDefaultArgs> = $Result.GetResult<Prisma.$ResourcesPayload, S>

  type ResourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourcesCountAggregateInputType | true
    }

  export interface ResourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resources'], meta: { name: 'Resources' } }
    /**
     * Find zero or one Resources that matches the filter.
     * @param {ResourcesFindUniqueArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourcesFindUniqueArgs>(args: SelectSubset<T, ResourcesFindUniqueArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourcesFindUniqueOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesFindFirstArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourcesFindFirstArgs>(args?: SelectSubset<T, ResourcesFindFirstArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesFindFirstOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resources.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourcesWithIdOnly = await prisma.resources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourcesFindManyArgs>(args?: SelectSubset<T, ResourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resources.
     * @param {ResourcesCreateArgs} args - Arguments to create a Resources.
     * @example
     * // Create one Resources
     * const Resources = await prisma.resources.create({
     *   data: {
     *     // ... data to create a Resources
     *   }
     * })
     * 
     */
    create<T extends ResourcesCreateArgs>(args: SelectSubset<T, ResourcesCreateArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourcesCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resources = await prisma.resources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourcesCreateManyArgs>(args?: SelectSubset<T, ResourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourcesCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resources = await prisma.resources.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourcesWithIdOnly = await prisma.resources.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourcesCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourcesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resources.
     * @param {ResourcesDeleteArgs} args - Arguments to delete one Resources.
     * @example
     * // Delete one Resources
     * const Resources = await prisma.resources.delete({
     *   where: {
     *     // ... filter to delete one Resources
     *   }
     * })
     * 
     */
    delete<T extends ResourcesDeleteArgs>(args: SelectSubset<T, ResourcesDeleteArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resources.
     * @param {ResourcesUpdateArgs} args - Arguments to update one Resources.
     * @example
     * // Update one Resources
     * const resources = await prisma.resources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourcesUpdateArgs>(args: SelectSubset<T, ResourcesUpdateArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourcesDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourcesDeleteManyArgs>(args?: SelectSubset<T, ResourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourcesUpdateManyArgs>(args: SelectSubset<T, ResourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourcesUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourcesWithIdOnly = await prisma.resources.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourcesUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourcesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resources.
     * @param {ResourcesUpsertArgs} args - Arguments to update or create a Resources.
     * @example
     * // Update or create a Resources
     * const resources = await prisma.resources.upsert({
     *   create: {
     *     // ... data to create a Resources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resources we want to update
     *   }
     * })
     */
    upsert<T extends ResourcesUpsertArgs>(args: SelectSubset<T, ResourcesUpsertArgs<ExtArgs>>): Prisma__ResourcesClient<$Result.GetResult<Prisma.$ResourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resources.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourcesCountArgs>(
      args?: Subset<T, ResourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourcesAggregateArgs>(args: Subset<T, ResourcesAggregateArgs>): Prisma.PrismaPromise<GetResourcesAggregateType<T>>

    /**
     * Group by Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourcesGroupByArgs['orderBy'] }
        : { orderBy?: ResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resources model
   */
  readonly fields: ResourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resources model
   */
  interface ResourcesFieldRefs {
    readonly id: FieldRef<"Resources", 'String'>
    readonly userId: FieldRef<"Resources", 'String'>
    readonly spiritStones: FieldRef<"Resources", 'BigInt'>
    readonly gold: FieldRef<"Resources", 'BigInt'>
    readonly materials: FieldRef<"Resources", 'Json'>
    readonly pills: FieldRef<"Resources", 'Json'>
    readonly herbs: FieldRef<"Resources", 'Json'>
    readonly lastUpdated: FieldRef<"Resources", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resources findUnique
   */
  export type ResourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where: ResourcesWhereUniqueInput
  }

  /**
   * Resources findUniqueOrThrow
   */
  export type ResourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where: ResourcesWhereUniqueInput
  }

  /**
   * Resources findFirst
   */
  export type ResourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourcesOrderByWithRelationInput | ResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * Resources findFirstOrThrow
   */
  export type ResourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourcesOrderByWithRelationInput | ResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * Resources findMany
   */
  export type ResourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourcesOrderByWithRelationInput | ResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * Resources create
   */
  export type ResourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a Resources.
     */
    data: XOR<ResourcesCreateInput, ResourcesUncheckedCreateInput>
  }

  /**
   * Resources createMany
   */
  export type ResourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourcesCreateManyInput | ResourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resources createManyAndReturn
   */
  export type ResourcesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourcesCreateManyInput | ResourcesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resources update
   */
  export type ResourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a Resources.
     */
    data: XOR<ResourcesUpdateInput, ResourcesUncheckedUpdateInput>
    /**
     * Choose, which Resources to update.
     */
    where: ResourcesWhereUniqueInput
  }

  /**
   * Resources updateMany
   */
  export type ResourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourcesUpdateManyMutationInput, ResourcesUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourcesWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resources updateManyAndReturn
   */
  export type ResourcesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourcesUpdateManyMutationInput, ResourcesUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourcesWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resources upsert
   */
  export type ResourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the Resources to update in case it exists.
     */
    where: ResourcesWhereUniqueInput
    /**
     * In case the Resources found by the `where` argument doesn't exist, create a new Resources with this data.
     */
    create: XOR<ResourcesCreateInput, ResourcesUncheckedCreateInput>
    /**
     * In case the Resources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourcesUpdateInput, ResourcesUncheckedUpdateInput>
  }

  /**
   * Resources delete
   */
  export type ResourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
    /**
     * Filter which Resources to delete.
     */
    where: ResourcesWhereUniqueInput
  }

  /**
   * Resources deleteMany
   */
  export type ResourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourcesWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resources without action
   */
  export type ResourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resources
     */
    select?: ResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resources
     */
    omit?: ResourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourcesInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    value: number | null
  }

  export type ItemSumAggregateOutputType = {
    value: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    rarity: $Enums.ItemRarity | null
    value: number | null
    stackable: boolean | null
    tradeable: boolean | null
    consumable: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    rarity: $Enums.ItemRarity | null
    value: number | null
    stackable: boolean | null
    tradeable: boolean | null
    consumable: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    rarity: number
    value: number
    stackable: number
    tradeable: number
    consumable: number
    effects: number
    requirements: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    value?: true
  }

  export type ItemSumAggregateInputType = {
    value?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    rarity?: true
    value?: true
    stackable?: true
    tradeable?: true
    consumable?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    rarity?: true
    value?: true
    stackable?: true
    tradeable?: true
    consumable?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    rarity?: true
    value?: true
    stackable?: true
    tradeable?: true
    consumable?: true
    effects?: true
    requirements?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    value: number
    stackable: boolean
    tradeable: boolean
    consumable: boolean
    effects: JsonValue
    requirements: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    rarity?: boolean
    value?: boolean
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    rarity?: boolean
    value?: boolean
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    rarity?: boolean
    value?: boolean
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    rarity?: boolean
    value?: boolean
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: boolean
    requirements?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "rarity" | "value" | "stackable" | "tradeable" | "consumable" | "effects" | "requirements" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Item$inventoryItemsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.ItemType
      rarity: $Enums.ItemRarity
      value: number
      stackable: boolean
      tradeable: boolean
      consumable: boolean
      effects: Prisma.JsonValue
      requirements: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Item$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly rarity: FieldRef<"Item", 'ItemRarity'>
    readonly value: FieldRef<"Item", 'Int'>
    readonly stackable: FieldRef<"Item", 'Boolean'>
    readonly tradeable: FieldRef<"Item", 'Boolean'>
    readonly consumable: FieldRef<"Item", 'Boolean'>
    readonly effects: FieldRef<"Item", 'Json'>
    readonly requirements: FieldRef<"Item", 'Json'>
    readonly isActive: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.inventoryItems
   */
  export type Item$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    quantity: number | null
    acquiredAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
    quantity: number | null
    acquiredAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    quantity: number
    metadata: number
    acquiredAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
    acquiredAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
    acquiredAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    quantity?: true
    metadata?: true
    acquiredAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    userId: string
    itemId: string
    quantity: number
    metadata: JsonValue
    acquiredAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
    quantity?: boolean
    metadata?: boolean
    acquiredAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itemId" | "quantity" | "metadata" | "acquiredAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemId: string
      quantity: number
      metadata: Prisma.JsonValue
      acquiredAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly userId: FieldRef<"InventoryItem", 'String'>
    readonly itemId: FieldRef<"InventoryItem", 'String'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly metadata: FieldRef<"InventoryItem", 'Json'>
    readonly acquiredAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model CombatStats
   */

  export type AggregateCombatStats = {
    _count: CombatStatsCountAggregateOutputType | null
    _avg: CombatStatsAvgAggregateOutputType | null
    _sum: CombatStatsSumAggregateOutputType | null
    _min: CombatStatsMinAggregateOutputType | null
    _max: CombatStatsMaxAggregateOutputType | null
  }

  export type CombatStatsAvgAggregateOutputType = {
    level: number | null
    health: number | null
    maxHealth: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    criticalChance: number | null
    criticalDamage: number | null
    combatExperience: number | null
    wins: number | null
    losses: number | null
    draws: number | null
  }

  export type CombatStatsSumAggregateOutputType = {
    level: number | null
    health: number | null
    maxHealth: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    criticalChance: number | null
    criticalDamage: number | null
    combatExperience: bigint | null
    wins: number | null
    losses: number | null
    draws: number | null
  }

  export type CombatStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    level: number | null
    health: number | null
    maxHealth: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    criticalChance: number | null
    criticalDamage: number | null
    combatExperience: bigint | null
    wins: number | null
    losses: number | null
    draws: number | null
    lastCombatAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CombatStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    level: number | null
    health: number | null
    maxHealth: number | null
    attack: number | null
    defense: number | null
    speed: number | null
    criticalChance: number | null
    criticalDamage: number | null
    combatExperience: bigint | null
    wins: number | null
    losses: number | null
    draws: number | null
    lastCombatAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CombatStatsCountAggregateOutputType = {
    id: number
    userId: number
    level: number
    health: number
    maxHealth: number
    attack: number
    defense: number
    speed: number
    criticalChance: number
    criticalDamage: number
    combatExperience: number
    wins: number
    losses: number
    draws: number
    lastCombatAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CombatStatsAvgAggregateInputType = {
    level?: true
    health?: true
    maxHealth?: true
    attack?: true
    defense?: true
    speed?: true
    criticalChance?: true
    criticalDamage?: true
    combatExperience?: true
    wins?: true
    losses?: true
    draws?: true
  }

  export type CombatStatsSumAggregateInputType = {
    level?: true
    health?: true
    maxHealth?: true
    attack?: true
    defense?: true
    speed?: true
    criticalChance?: true
    criticalDamage?: true
    combatExperience?: true
    wins?: true
    losses?: true
    draws?: true
  }

  export type CombatStatsMinAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    health?: true
    maxHealth?: true
    attack?: true
    defense?: true
    speed?: true
    criticalChance?: true
    criticalDamage?: true
    combatExperience?: true
    wins?: true
    losses?: true
    draws?: true
    lastCombatAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CombatStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    health?: true
    maxHealth?: true
    attack?: true
    defense?: true
    speed?: true
    criticalChance?: true
    criticalDamage?: true
    combatExperience?: true
    wins?: true
    losses?: true
    draws?: true
    lastCombatAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CombatStatsCountAggregateInputType = {
    id?: true
    userId?: true
    level?: true
    health?: true
    maxHealth?: true
    attack?: true
    defense?: true
    speed?: true
    criticalChance?: true
    criticalDamage?: true
    combatExperience?: true
    wins?: true
    losses?: true
    draws?: true
    lastCombatAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CombatStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatStats to aggregate.
     */
    where?: CombatStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatStats to fetch.
     */
    orderBy?: CombatStatsOrderByWithRelationInput | CombatStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombatStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombatStats
    **/
    _count?: true | CombatStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombatStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombatStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombatStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombatStatsMaxAggregateInputType
  }

  export type GetCombatStatsAggregateType<T extends CombatStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateCombatStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombatStats[P]>
      : GetScalarType<T[P], AggregateCombatStats[P]>
  }




  export type CombatStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatStatsWhereInput
    orderBy?: CombatStatsOrderByWithAggregationInput | CombatStatsOrderByWithAggregationInput[]
    by: CombatStatsScalarFieldEnum[] | CombatStatsScalarFieldEnum
    having?: CombatStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombatStatsCountAggregateInputType | true
    _avg?: CombatStatsAvgAggregateInputType
    _sum?: CombatStatsSumAggregateInputType
    _min?: CombatStatsMinAggregateInputType
    _max?: CombatStatsMaxAggregateInputType
  }

  export type CombatStatsGroupByOutputType = {
    id: string
    userId: string
    level: number
    health: number
    maxHealth: number
    attack: number
    defense: number
    speed: number
    criticalChance: number
    criticalDamage: number
    combatExperience: bigint
    wins: number
    losses: number
    draws: number
    lastCombatAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CombatStatsCountAggregateOutputType | null
    _avg: CombatStatsAvgAggregateOutputType | null
    _sum: CombatStatsSumAggregateOutputType | null
    _min: CombatStatsMinAggregateOutputType | null
    _max: CombatStatsMaxAggregateOutputType | null
  }

  type GetCombatStatsGroupByPayload<T extends CombatStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombatStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombatStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombatStatsGroupByOutputType[P]>
            : GetScalarType<T[P], CombatStatsGroupByOutputType[P]>
        }
      >
    >


  export type CombatStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    health?: boolean
    maxHealth?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    criticalChance?: boolean
    criticalDamage?: boolean
    combatExperience?: boolean
    wins?: boolean
    losses?: boolean
    draws?: boolean
    lastCombatAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatStats"]>

  export type CombatStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    health?: boolean
    maxHealth?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    criticalChance?: boolean
    criticalDamage?: boolean
    combatExperience?: boolean
    wins?: boolean
    losses?: boolean
    draws?: boolean
    lastCombatAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatStats"]>

  export type CombatStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    level?: boolean
    health?: boolean
    maxHealth?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    criticalChance?: boolean
    criticalDamage?: boolean
    combatExperience?: boolean
    wins?: boolean
    losses?: boolean
    draws?: boolean
    lastCombatAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatStats"]>

  export type CombatStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    level?: boolean
    health?: boolean
    maxHealth?: boolean
    attack?: boolean
    defense?: boolean
    speed?: boolean
    criticalChance?: boolean
    criticalDamage?: boolean
    combatExperience?: boolean
    wins?: boolean
    losses?: boolean
    draws?: boolean
    lastCombatAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CombatStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "level" | "health" | "maxHealth" | "attack" | "defense" | "speed" | "criticalChance" | "criticalDamage" | "combatExperience" | "wins" | "losses" | "draws" | "lastCombatAt" | "createdAt" | "updatedAt", ExtArgs["result"]["combatStats"]>
  export type CombatStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CombatStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CombatStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CombatStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombatStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      level: number
      health: number
      maxHealth: number
      attack: number
      defense: number
      speed: number
      criticalChance: number
      criticalDamage: number
      combatExperience: bigint
      wins: number
      losses: number
      draws: number
      lastCombatAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["combatStats"]>
    composites: {}
  }

  type CombatStatsGetPayload<S extends boolean | null | undefined | CombatStatsDefaultArgs> = $Result.GetResult<Prisma.$CombatStatsPayload, S>

  type CombatStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CombatStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CombatStatsCountAggregateInputType | true
    }

  export interface CombatStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombatStats'], meta: { name: 'CombatStats' } }
    /**
     * Find zero or one CombatStats that matches the filter.
     * @param {CombatStatsFindUniqueArgs} args - Arguments to find a CombatStats
     * @example
     * // Get one CombatStats
     * const combatStats = await prisma.combatStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombatStatsFindUniqueArgs>(args: SelectSubset<T, CombatStatsFindUniqueArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CombatStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CombatStatsFindUniqueOrThrowArgs} args - Arguments to find a CombatStats
     * @example
     * // Get one CombatStats
     * const combatStats = await prisma.combatStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombatStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, CombatStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsFindFirstArgs} args - Arguments to find a CombatStats
     * @example
     * // Get one CombatStats
     * const combatStats = await prisma.combatStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombatStatsFindFirstArgs>(args?: SelectSubset<T, CombatStatsFindFirstArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsFindFirstOrThrowArgs} args - Arguments to find a CombatStats
     * @example
     * // Get one CombatStats
     * const combatStats = await prisma.combatStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombatStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, CombatStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CombatStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombatStats
     * const combatStats = await prisma.combatStats.findMany()
     * 
     * // Get first 10 CombatStats
     * const combatStats = await prisma.combatStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combatStatsWithIdOnly = await prisma.combatStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombatStatsFindManyArgs>(args?: SelectSubset<T, CombatStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CombatStats.
     * @param {CombatStatsCreateArgs} args - Arguments to create a CombatStats.
     * @example
     * // Create one CombatStats
     * const CombatStats = await prisma.combatStats.create({
     *   data: {
     *     // ... data to create a CombatStats
     *   }
     * })
     * 
     */
    create<T extends CombatStatsCreateArgs>(args: SelectSubset<T, CombatStatsCreateArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CombatStats.
     * @param {CombatStatsCreateManyArgs} args - Arguments to create many CombatStats.
     * @example
     * // Create many CombatStats
     * const combatStats = await prisma.combatStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombatStatsCreateManyArgs>(args?: SelectSubset<T, CombatStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CombatStats and returns the data saved in the database.
     * @param {CombatStatsCreateManyAndReturnArgs} args - Arguments to create many CombatStats.
     * @example
     * // Create many CombatStats
     * const combatStats = await prisma.combatStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CombatStats and only return the `id`
     * const combatStatsWithIdOnly = await prisma.combatStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CombatStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, CombatStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CombatStats.
     * @param {CombatStatsDeleteArgs} args - Arguments to delete one CombatStats.
     * @example
     * // Delete one CombatStats
     * const CombatStats = await prisma.combatStats.delete({
     *   where: {
     *     // ... filter to delete one CombatStats
     *   }
     * })
     * 
     */
    delete<T extends CombatStatsDeleteArgs>(args: SelectSubset<T, CombatStatsDeleteArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CombatStats.
     * @param {CombatStatsUpdateArgs} args - Arguments to update one CombatStats.
     * @example
     * // Update one CombatStats
     * const combatStats = await prisma.combatStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombatStatsUpdateArgs>(args: SelectSubset<T, CombatStatsUpdateArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CombatStats.
     * @param {CombatStatsDeleteManyArgs} args - Arguments to filter CombatStats to delete.
     * @example
     * // Delete a few CombatStats
     * const { count } = await prisma.combatStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombatStatsDeleteManyArgs>(args?: SelectSubset<T, CombatStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombatStats
     * const combatStats = await prisma.combatStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombatStatsUpdateManyArgs>(args: SelectSubset<T, CombatStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatStats and returns the data updated in the database.
     * @param {CombatStatsUpdateManyAndReturnArgs} args - Arguments to update many CombatStats.
     * @example
     * // Update many CombatStats
     * const combatStats = await prisma.combatStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CombatStats and only return the `id`
     * const combatStatsWithIdOnly = await prisma.combatStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CombatStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, CombatStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CombatStats.
     * @param {CombatStatsUpsertArgs} args - Arguments to update or create a CombatStats.
     * @example
     * // Update or create a CombatStats
     * const combatStats = await prisma.combatStats.upsert({
     *   create: {
     *     // ... data to create a CombatStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombatStats we want to update
     *   }
     * })
     */
    upsert<T extends CombatStatsUpsertArgs>(args: SelectSubset<T, CombatStatsUpsertArgs<ExtArgs>>): Prisma__CombatStatsClient<$Result.GetResult<Prisma.$CombatStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CombatStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsCountArgs} args - Arguments to filter CombatStats to count.
     * @example
     * // Count the number of CombatStats
     * const count = await prisma.combatStats.count({
     *   where: {
     *     // ... the filter for the CombatStats we want to count
     *   }
     * })
    **/
    count<T extends CombatStatsCountArgs>(
      args?: Subset<T, CombatStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombatStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombatStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombatStatsAggregateArgs>(args: Subset<T, CombatStatsAggregateArgs>): Prisma.PrismaPromise<GetCombatStatsAggregateType<T>>

    /**
     * Group by CombatStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombatStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombatStatsGroupByArgs['orderBy'] }
        : { orderBy?: CombatStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombatStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombatStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombatStats model
   */
  readonly fields: CombatStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombatStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombatStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombatStats model
   */
  interface CombatStatsFieldRefs {
    readonly id: FieldRef<"CombatStats", 'String'>
    readonly userId: FieldRef<"CombatStats", 'String'>
    readonly level: FieldRef<"CombatStats", 'Int'>
    readonly health: FieldRef<"CombatStats", 'Int'>
    readonly maxHealth: FieldRef<"CombatStats", 'Int'>
    readonly attack: FieldRef<"CombatStats", 'Int'>
    readonly defense: FieldRef<"CombatStats", 'Int'>
    readonly speed: FieldRef<"CombatStats", 'Int'>
    readonly criticalChance: FieldRef<"CombatStats", 'Float'>
    readonly criticalDamage: FieldRef<"CombatStats", 'Float'>
    readonly combatExperience: FieldRef<"CombatStats", 'BigInt'>
    readonly wins: FieldRef<"CombatStats", 'Int'>
    readonly losses: FieldRef<"CombatStats", 'Int'>
    readonly draws: FieldRef<"CombatStats", 'Int'>
    readonly lastCombatAt: FieldRef<"CombatStats", 'DateTime'>
    readonly createdAt: FieldRef<"CombatStats", 'DateTime'>
    readonly updatedAt: FieldRef<"CombatStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CombatStats findUnique
   */
  export type CombatStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter, which CombatStats to fetch.
     */
    where: CombatStatsWhereUniqueInput
  }

  /**
   * CombatStats findUniqueOrThrow
   */
  export type CombatStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter, which CombatStats to fetch.
     */
    where: CombatStatsWhereUniqueInput
  }

  /**
   * CombatStats findFirst
   */
  export type CombatStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter, which CombatStats to fetch.
     */
    where?: CombatStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatStats to fetch.
     */
    orderBy?: CombatStatsOrderByWithRelationInput | CombatStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatStats.
     */
    cursor?: CombatStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatStats.
     */
    distinct?: CombatStatsScalarFieldEnum | CombatStatsScalarFieldEnum[]
  }

  /**
   * CombatStats findFirstOrThrow
   */
  export type CombatStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter, which CombatStats to fetch.
     */
    where?: CombatStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatStats to fetch.
     */
    orderBy?: CombatStatsOrderByWithRelationInput | CombatStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatStats.
     */
    cursor?: CombatStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatStats.
     */
    distinct?: CombatStatsScalarFieldEnum | CombatStatsScalarFieldEnum[]
  }

  /**
   * CombatStats findMany
   */
  export type CombatStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter, which CombatStats to fetch.
     */
    where?: CombatStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatStats to fetch.
     */
    orderBy?: CombatStatsOrderByWithRelationInput | CombatStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombatStats.
     */
    cursor?: CombatStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatStats.
     */
    skip?: number
    distinct?: CombatStatsScalarFieldEnum | CombatStatsScalarFieldEnum[]
  }

  /**
   * CombatStats create
   */
  export type CombatStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a CombatStats.
     */
    data: XOR<CombatStatsCreateInput, CombatStatsUncheckedCreateInput>
  }

  /**
   * CombatStats createMany
   */
  export type CombatStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombatStats.
     */
    data: CombatStatsCreateManyInput | CombatStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombatStats createManyAndReturn
   */
  export type CombatStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * The data used to create many CombatStats.
     */
    data: CombatStatsCreateManyInput | CombatStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatStats update
   */
  export type CombatStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a CombatStats.
     */
    data: XOR<CombatStatsUpdateInput, CombatStatsUncheckedUpdateInput>
    /**
     * Choose, which CombatStats to update.
     */
    where: CombatStatsWhereUniqueInput
  }

  /**
   * CombatStats updateMany
   */
  export type CombatStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombatStats.
     */
    data: XOR<CombatStatsUpdateManyMutationInput, CombatStatsUncheckedUpdateManyInput>
    /**
     * Filter which CombatStats to update
     */
    where?: CombatStatsWhereInput
    /**
     * Limit how many CombatStats to update.
     */
    limit?: number
  }

  /**
   * CombatStats updateManyAndReturn
   */
  export type CombatStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * The data used to update CombatStats.
     */
    data: XOR<CombatStatsUpdateManyMutationInput, CombatStatsUncheckedUpdateManyInput>
    /**
     * Filter which CombatStats to update
     */
    where?: CombatStatsWhereInput
    /**
     * Limit how many CombatStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatStats upsert
   */
  export type CombatStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the CombatStats to update in case it exists.
     */
    where: CombatStatsWhereUniqueInput
    /**
     * In case the CombatStats found by the `where` argument doesn't exist, create a new CombatStats with this data.
     */
    create: XOR<CombatStatsCreateInput, CombatStatsUncheckedCreateInput>
    /**
     * In case the CombatStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombatStatsUpdateInput, CombatStatsUncheckedUpdateInput>
  }

  /**
   * CombatStats delete
   */
  export type CombatStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
    /**
     * Filter which CombatStats to delete.
     */
    where: CombatStatsWhereUniqueInput
  }

  /**
   * CombatStats deleteMany
   */
  export type CombatStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatStats to delete
     */
    where?: CombatStatsWhereInput
    /**
     * Limit how many CombatStats to delete.
     */
    limit?: number
  }

  /**
   * CombatStats without action
   */
  export type CombatStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatStats
     */
    select?: CombatStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatStats
     */
    omit?: CombatStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatStatsInclude<ExtArgs> | null
  }


  /**
   * Model CombatLog
   */

  export type AggregateCombatLog = {
    _count: CombatLogCountAggregateOutputType | null
    _avg: CombatLogAvgAggregateOutputType | null
    _sum: CombatLogSumAggregateOutputType | null
    _min: CombatLogMinAggregateOutputType | null
    _max: CombatLogMaxAggregateOutputType | null
  }

  export type CombatLogAvgAggregateOutputType = {
    duration: number | null
    damageDealt: number | null
    damageReceived: number | null
    experienceGained: number | null
  }

  export type CombatLogSumAggregateOutputType = {
    duration: number | null
    damageDealt: number | null
    damageReceived: number | null
    experienceGained: bigint | null
  }

  export type CombatLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    opponentName: string | null
    result: $Enums.CombatResult | null
    duration: number | null
    damageDealt: number | null
    damageReceived: number | null
    experienceGained: bigint | null
    foughtAt: Date | null
  }

  export type CombatLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    opponentName: string | null
    result: $Enums.CombatResult | null
    duration: number | null
    damageDealt: number | null
    damageReceived: number | null
    experienceGained: bigint | null
    foughtAt: Date | null
  }

  export type CombatLogCountAggregateOutputType = {
    id: number
    userId: number
    opponentName: number
    result: number
    duration: number
    damageDealt: number
    damageReceived: number
    experienceGained: number
    lootGained: number
    combatDetails: number
    foughtAt: number
    _all: number
  }


  export type CombatLogAvgAggregateInputType = {
    duration?: true
    damageDealt?: true
    damageReceived?: true
    experienceGained?: true
  }

  export type CombatLogSumAggregateInputType = {
    duration?: true
    damageDealt?: true
    damageReceived?: true
    experienceGained?: true
  }

  export type CombatLogMinAggregateInputType = {
    id?: true
    userId?: true
    opponentName?: true
    result?: true
    duration?: true
    damageDealt?: true
    damageReceived?: true
    experienceGained?: true
    foughtAt?: true
  }

  export type CombatLogMaxAggregateInputType = {
    id?: true
    userId?: true
    opponentName?: true
    result?: true
    duration?: true
    damageDealt?: true
    damageReceived?: true
    experienceGained?: true
    foughtAt?: true
  }

  export type CombatLogCountAggregateInputType = {
    id?: true
    userId?: true
    opponentName?: true
    result?: true
    duration?: true
    damageDealt?: true
    damageReceived?: true
    experienceGained?: true
    lootGained?: true
    combatDetails?: true
    foughtAt?: true
    _all?: true
  }

  export type CombatLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatLog to aggregate.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombatLogs
    **/
    _count?: true | CombatLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombatLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombatLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombatLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombatLogMaxAggregateInputType
  }

  export type GetCombatLogAggregateType<T extends CombatLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCombatLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombatLog[P]>
      : GetScalarType<T[P], AggregateCombatLog[P]>
  }




  export type CombatLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatLogWhereInput
    orderBy?: CombatLogOrderByWithAggregationInput | CombatLogOrderByWithAggregationInput[]
    by: CombatLogScalarFieldEnum[] | CombatLogScalarFieldEnum
    having?: CombatLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombatLogCountAggregateInputType | true
    _avg?: CombatLogAvgAggregateInputType
    _sum?: CombatLogSumAggregateInputType
    _min?: CombatLogMinAggregateInputType
    _max?: CombatLogMaxAggregateInputType
  }

  export type CombatLogGroupByOutputType = {
    id: string
    userId: string
    opponentName: string
    result: $Enums.CombatResult
    duration: number
    damageDealt: number
    damageReceived: number
    experienceGained: bigint
    lootGained: JsonValue
    combatDetails: JsonValue
    foughtAt: Date
    _count: CombatLogCountAggregateOutputType | null
    _avg: CombatLogAvgAggregateOutputType | null
    _sum: CombatLogSumAggregateOutputType | null
    _min: CombatLogMinAggregateOutputType | null
    _max: CombatLogMaxAggregateOutputType | null
  }

  type GetCombatLogGroupByPayload<T extends CombatLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombatLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombatLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombatLogGroupByOutputType[P]>
            : GetScalarType<T[P], CombatLogGroupByOutputType[P]>
        }
      >
    >


  export type CombatLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opponentName?: boolean
    result?: boolean
    duration?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    experienceGained?: boolean
    lootGained?: boolean
    combatDetails?: boolean
    foughtAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opponentName?: boolean
    result?: boolean
    duration?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    experienceGained?: boolean
    lootGained?: boolean
    combatDetails?: boolean
    foughtAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opponentName?: boolean
    result?: boolean
    duration?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    experienceGained?: boolean
    lootGained?: boolean
    combatDetails?: boolean
    foughtAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatLog"]>

  export type CombatLogSelectScalar = {
    id?: boolean
    userId?: boolean
    opponentName?: boolean
    result?: boolean
    duration?: boolean
    damageDealt?: boolean
    damageReceived?: boolean
    experienceGained?: boolean
    lootGained?: boolean
    combatDetails?: boolean
    foughtAt?: boolean
  }

  export type CombatLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "opponentName" | "result" | "duration" | "damageDealt" | "damageReceived" | "experienceGained" | "lootGained" | "combatDetails" | "foughtAt", ExtArgs["result"]["combatLog"]>
  export type CombatLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CombatLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CombatLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CombatLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombatLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      opponentName: string
      result: $Enums.CombatResult
      duration: number
      damageDealt: number
      damageReceived: number
      experienceGained: bigint
      lootGained: Prisma.JsonValue
      combatDetails: Prisma.JsonValue
      foughtAt: Date
    }, ExtArgs["result"]["combatLog"]>
    composites: {}
  }

  type CombatLogGetPayload<S extends boolean | null | undefined | CombatLogDefaultArgs> = $Result.GetResult<Prisma.$CombatLogPayload, S>

  type CombatLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CombatLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CombatLogCountAggregateInputType | true
    }

  export interface CombatLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombatLog'], meta: { name: 'CombatLog' } }
    /**
     * Find zero or one CombatLog that matches the filter.
     * @param {CombatLogFindUniqueArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombatLogFindUniqueArgs>(args: SelectSubset<T, CombatLogFindUniqueArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CombatLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CombatLogFindUniqueOrThrowArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombatLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CombatLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindFirstArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombatLogFindFirstArgs>(args?: SelectSubset<T, CombatLogFindFirstArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombatLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindFirstOrThrowArgs} args - Arguments to find a CombatLog
     * @example
     * // Get one CombatLog
     * const combatLog = await prisma.combatLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombatLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CombatLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CombatLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombatLogs
     * const combatLogs = await prisma.combatLog.findMany()
     * 
     * // Get first 10 CombatLogs
     * const combatLogs = await prisma.combatLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombatLogFindManyArgs>(args?: SelectSubset<T, CombatLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CombatLog.
     * @param {CombatLogCreateArgs} args - Arguments to create a CombatLog.
     * @example
     * // Create one CombatLog
     * const CombatLog = await prisma.combatLog.create({
     *   data: {
     *     // ... data to create a CombatLog
     *   }
     * })
     * 
     */
    create<T extends CombatLogCreateArgs>(args: SelectSubset<T, CombatLogCreateArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CombatLogs.
     * @param {CombatLogCreateManyArgs} args - Arguments to create many CombatLogs.
     * @example
     * // Create many CombatLogs
     * const combatLog = await prisma.combatLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombatLogCreateManyArgs>(args?: SelectSubset<T, CombatLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CombatLogs and returns the data saved in the database.
     * @param {CombatLogCreateManyAndReturnArgs} args - Arguments to create many CombatLogs.
     * @example
     * // Create many CombatLogs
     * const combatLog = await prisma.combatLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CombatLogs and only return the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CombatLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CombatLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CombatLog.
     * @param {CombatLogDeleteArgs} args - Arguments to delete one CombatLog.
     * @example
     * // Delete one CombatLog
     * const CombatLog = await prisma.combatLog.delete({
     *   where: {
     *     // ... filter to delete one CombatLog
     *   }
     * })
     * 
     */
    delete<T extends CombatLogDeleteArgs>(args: SelectSubset<T, CombatLogDeleteArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CombatLog.
     * @param {CombatLogUpdateArgs} args - Arguments to update one CombatLog.
     * @example
     * // Update one CombatLog
     * const combatLog = await prisma.combatLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombatLogUpdateArgs>(args: SelectSubset<T, CombatLogUpdateArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CombatLogs.
     * @param {CombatLogDeleteManyArgs} args - Arguments to filter CombatLogs to delete.
     * @example
     * // Delete a few CombatLogs
     * const { count } = await prisma.combatLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombatLogDeleteManyArgs>(args?: SelectSubset<T, CombatLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombatLogs
     * const combatLog = await prisma.combatLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombatLogUpdateManyArgs>(args: SelectSubset<T, CombatLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatLogs and returns the data updated in the database.
     * @param {CombatLogUpdateManyAndReturnArgs} args - Arguments to update many CombatLogs.
     * @example
     * // Update many CombatLogs
     * const combatLog = await prisma.combatLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CombatLogs and only return the `id`
     * const combatLogWithIdOnly = await prisma.combatLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CombatLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CombatLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CombatLog.
     * @param {CombatLogUpsertArgs} args - Arguments to update or create a CombatLog.
     * @example
     * // Update or create a CombatLog
     * const combatLog = await prisma.combatLog.upsert({
     *   create: {
     *     // ... data to create a CombatLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombatLog we want to update
     *   }
     * })
     */
    upsert<T extends CombatLogUpsertArgs>(args: SelectSubset<T, CombatLogUpsertArgs<ExtArgs>>): Prisma__CombatLogClient<$Result.GetResult<Prisma.$CombatLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CombatLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogCountArgs} args - Arguments to filter CombatLogs to count.
     * @example
     * // Count the number of CombatLogs
     * const count = await prisma.combatLog.count({
     *   where: {
     *     // ... the filter for the CombatLogs we want to count
     *   }
     * })
    **/
    count<T extends CombatLogCountArgs>(
      args?: Subset<T, CombatLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombatLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombatLogAggregateArgs>(args: Subset<T, CombatLogAggregateArgs>): Prisma.PrismaPromise<GetCombatLogAggregateType<T>>

    /**
     * Group by CombatLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombatLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombatLogGroupByArgs['orderBy'] }
        : { orderBy?: CombatLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombatLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombatLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombatLog model
   */
  readonly fields: CombatLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombatLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombatLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombatLog model
   */
  interface CombatLogFieldRefs {
    readonly id: FieldRef<"CombatLog", 'String'>
    readonly userId: FieldRef<"CombatLog", 'String'>
    readonly opponentName: FieldRef<"CombatLog", 'String'>
    readonly result: FieldRef<"CombatLog", 'CombatResult'>
    readonly duration: FieldRef<"CombatLog", 'Int'>
    readonly damageDealt: FieldRef<"CombatLog", 'Int'>
    readonly damageReceived: FieldRef<"CombatLog", 'Int'>
    readonly experienceGained: FieldRef<"CombatLog", 'BigInt'>
    readonly lootGained: FieldRef<"CombatLog", 'Json'>
    readonly combatDetails: FieldRef<"CombatLog", 'Json'>
    readonly foughtAt: FieldRef<"CombatLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CombatLog findUnique
   */
  export type CombatLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog findUniqueOrThrow
   */
  export type CombatLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog findFirst
   */
  export type CombatLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatLogs.
     */
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog findFirstOrThrow
   */
  export type CombatLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLog to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatLogs.
     */
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog findMany
   */
  export type CombatLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter, which CombatLogs to fetch.
     */
    where?: CombatLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatLogs to fetch.
     */
    orderBy?: CombatLogOrderByWithRelationInput | CombatLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombatLogs.
     */
    cursor?: CombatLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatLogs.
     */
    skip?: number
    distinct?: CombatLogScalarFieldEnum | CombatLogScalarFieldEnum[]
  }

  /**
   * CombatLog create
   */
  export type CombatLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CombatLog.
     */
    data: XOR<CombatLogCreateInput, CombatLogUncheckedCreateInput>
  }

  /**
   * CombatLog createMany
   */
  export type CombatLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombatLogs.
     */
    data: CombatLogCreateManyInput | CombatLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombatLog createManyAndReturn
   */
  export type CombatLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * The data used to create many CombatLogs.
     */
    data: CombatLogCreateManyInput | CombatLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatLog update
   */
  export type CombatLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CombatLog.
     */
    data: XOR<CombatLogUpdateInput, CombatLogUncheckedUpdateInput>
    /**
     * Choose, which CombatLog to update.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog updateMany
   */
  export type CombatLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombatLogs.
     */
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyInput>
    /**
     * Filter which CombatLogs to update
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to update.
     */
    limit?: number
  }

  /**
   * CombatLog updateManyAndReturn
   */
  export type CombatLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * The data used to update CombatLogs.
     */
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyInput>
    /**
     * Filter which CombatLogs to update
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatLog upsert
   */
  export type CombatLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CombatLog to update in case it exists.
     */
    where: CombatLogWhereUniqueInput
    /**
     * In case the CombatLog found by the `where` argument doesn't exist, create a new CombatLog with this data.
     */
    create: XOR<CombatLogCreateInput, CombatLogUncheckedCreateInput>
    /**
     * In case the CombatLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombatLogUpdateInput, CombatLogUncheckedUpdateInput>
  }

  /**
   * CombatLog delete
   */
  export type CombatLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
    /**
     * Filter which CombatLog to delete.
     */
    where: CombatLogWhereUniqueInput
  }

  /**
   * CombatLog deleteMany
   */
  export type CombatLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatLogs to delete
     */
    where?: CombatLogWhereInput
    /**
     * Limit how many CombatLogs to delete.
     */
    limit?: number
  }

  /**
   * CombatLog without action
   */
  export type CombatLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatLog
     */
    select?: CombatLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombatLog
     */
    omit?: CombatLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatLogInclude<ExtArgs> | null
  }


  /**
   * Model Sect
   */

  export type AggregateSect = {
    _count: SectCountAggregateOutputType | null
    _avg: SectAvgAggregateOutputType | null
    _sum: SectSumAggregateOutputType | null
    _min: SectMinAggregateOutputType | null
    _max: SectMaxAggregateOutputType | null
  }

  export type SectAvgAggregateOutputType = {
    level: number | null
    experience: number | null
    spiritStones: number | null
    reputation: number | null
    influence: number | null
    territory: number | null
  }

  export type SectSumAggregateOutputType = {
    level: number | null
    experience: bigint | null
    spiritStones: bigint | null
    reputation: number | null
    influence: number | null
    territory: number | null
  }

  export type SectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    level: number | null
    experience: bigint | null
    leaderId: string | null
    spiritStones: bigint | null
    reputation: number | null
    influence: number | null
    territory: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    level: number | null
    experience: bigint | null
    leaderId: string | null
    spiritStones: bigint | null
    reputation: number | null
    influence: number | null
    territory: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    level: number
    experience: number
    leaderId: number
    spiritStones: number
    reputation: number
    influence: number
    territory: number
    buildings: number
    alliances: number
    enemies: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectAvgAggregateInputType = {
    level?: true
    experience?: true
    spiritStones?: true
    reputation?: true
    influence?: true
    territory?: true
  }

  export type SectSumAggregateInputType = {
    level?: true
    experience?: true
    spiritStones?: true
    reputation?: true
    influence?: true
    territory?: true
  }

  export type SectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    experience?: true
    leaderId?: true
    spiritStones?: true
    reputation?: true
    influence?: true
    territory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    experience?: true
    leaderId?: true
    spiritStones?: true
    reputation?: true
    influence?: true
    territory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    experience?: true
    leaderId?: true
    spiritStones?: true
    reputation?: true
    influence?: true
    territory?: true
    buildings?: true
    alliances?: true
    enemies?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sect to aggregate.
     */
    where?: SectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sects to fetch.
     */
    orderBy?: SectOrderByWithRelationInput | SectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sects
    **/
    _count?: true | SectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectMaxAggregateInputType
  }

  export type GetSectAggregateType<T extends SectAggregateArgs> = {
        [P in keyof T & keyof AggregateSect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSect[P]>
      : GetScalarType<T[P], AggregateSect[P]>
  }




  export type SectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectWhereInput
    orderBy?: SectOrderByWithAggregationInput | SectOrderByWithAggregationInput[]
    by: SectScalarFieldEnum[] | SectScalarFieldEnum
    having?: SectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectCountAggregateInputType | true
    _avg?: SectAvgAggregateInputType
    _sum?: SectSumAggregateInputType
    _min?: SectMinAggregateInputType
    _max?: SectMaxAggregateInputType
  }

  export type SectGroupByOutputType = {
    id: string
    name: string
    description: string
    level: number
    experience: bigint
    leaderId: string
    spiritStones: bigint
    reputation: number
    influence: number
    territory: number
    buildings: JsonValue
    alliances: JsonValue
    enemies: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SectCountAggregateOutputType | null
    _avg: SectAvgAggregateOutputType | null
    _sum: SectSumAggregateOutputType | null
    _min: SectMinAggregateOutputType | null
    _max: SectMaxAggregateOutputType | null
  }

  type GetSectGroupByPayload<T extends SectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectGroupByOutputType[P]>
            : GetScalarType<T[P], SectGroupByOutputType[P]>
        }
      >
    >


  export type SectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    experience?: boolean
    leaderId?: boolean
    spiritStones?: boolean
    reputation?: boolean
    influence?: boolean
    territory?: boolean
    buildings?: boolean
    alliances?: boolean
    enemies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Sect$membersArgs<ExtArgs>
    _count?: boolean | SectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sect"]>

  export type SectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    experience?: boolean
    leaderId?: boolean
    spiritStones?: boolean
    reputation?: boolean
    influence?: boolean
    territory?: boolean
    buildings?: boolean
    alliances?: boolean
    enemies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sect"]>

  export type SectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    experience?: boolean
    leaderId?: boolean
    spiritStones?: boolean
    reputation?: boolean
    influence?: boolean
    territory?: boolean
    buildings?: boolean
    alliances?: boolean
    enemies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sect"]>

  export type SectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    experience?: boolean
    leaderId?: boolean
    spiritStones?: boolean
    reputation?: boolean
    influence?: boolean
    territory?: boolean
    buildings?: boolean
    alliances?: boolean
    enemies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "level" | "experience" | "leaderId" | "spiritStones" | "reputation" | "influence" | "territory" | "buildings" | "alliances" | "enemies" | "createdAt" | "updatedAt", ExtArgs["result"]["sect"]>
  export type SectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Sect$membersArgs<ExtArgs>
    _count?: boolean | SectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sect"
    objects: {
      members: Prisma.$SectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      level: number
      experience: bigint
      leaderId: string
      spiritStones: bigint
      reputation: number
      influence: number
      territory: number
      buildings: Prisma.JsonValue
      alliances: Prisma.JsonValue
      enemies: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sect"]>
    composites: {}
  }

  type SectGetPayload<S extends boolean | null | undefined | SectDefaultArgs> = $Result.GetResult<Prisma.$SectPayload, S>

  type SectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectCountAggregateInputType | true
    }

  export interface SectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sect'], meta: { name: 'Sect' } }
    /**
     * Find zero or one Sect that matches the filter.
     * @param {SectFindUniqueArgs} args - Arguments to find a Sect
     * @example
     * // Get one Sect
     * const sect = await prisma.sect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectFindUniqueArgs>(args: SelectSubset<T, SectFindUniqueArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sect that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectFindUniqueOrThrowArgs} args - Arguments to find a Sect
     * @example
     * // Get one Sect
     * const sect = await prisma.sect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectFindUniqueOrThrowArgs>(args: SelectSubset<T, SectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectFindFirstArgs} args - Arguments to find a Sect
     * @example
     * // Get one Sect
     * const sect = await prisma.sect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectFindFirstArgs>(args?: SelectSubset<T, SectFindFirstArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectFindFirstOrThrowArgs} args - Arguments to find a Sect
     * @example
     * // Get one Sect
     * const sect = await prisma.sect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectFindFirstOrThrowArgs>(args?: SelectSubset<T, SectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sects
     * const sects = await prisma.sect.findMany()
     * 
     * // Get first 10 Sects
     * const sects = await prisma.sect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectWithIdOnly = await prisma.sect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectFindManyArgs>(args?: SelectSubset<T, SectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sect.
     * @param {SectCreateArgs} args - Arguments to create a Sect.
     * @example
     * // Create one Sect
     * const Sect = await prisma.sect.create({
     *   data: {
     *     // ... data to create a Sect
     *   }
     * })
     * 
     */
    create<T extends SectCreateArgs>(args: SelectSubset<T, SectCreateArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sects.
     * @param {SectCreateManyArgs} args - Arguments to create many Sects.
     * @example
     * // Create many Sects
     * const sect = await prisma.sect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectCreateManyArgs>(args?: SelectSubset<T, SectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sects and returns the data saved in the database.
     * @param {SectCreateManyAndReturnArgs} args - Arguments to create many Sects.
     * @example
     * // Create many Sects
     * const sect = await prisma.sect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sects and only return the `id`
     * const sectWithIdOnly = await prisma.sect.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectCreateManyAndReturnArgs>(args?: SelectSubset<T, SectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sect.
     * @param {SectDeleteArgs} args - Arguments to delete one Sect.
     * @example
     * // Delete one Sect
     * const Sect = await prisma.sect.delete({
     *   where: {
     *     // ... filter to delete one Sect
     *   }
     * })
     * 
     */
    delete<T extends SectDeleteArgs>(args: SelectSubset<T, SectDeleteArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sect.
     * @param {SectUpdateArgs} args - Arguments to update one Sect.
     * @example
     * // Update one Sect
     * const sect = await prisma.sect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectUpdateArgs>(args: SelectSubset<T, SectUpdateArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sects.
     * @param {SectDeleteManyArgs} args - Arguments to filter Sects to delete.
     * @example
     * // Delete a few Sects
     * const { count } = await prisma.sect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectDeleteManyArgs>(args?: SelectSubset<T, SectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sects
     * const sect = await prisma.sect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectUpdateManyArgs>(args: SelectSubset<T, SectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sects and returns the data updated in the database.
     * @param {SectUpdateManyAndReturnArgs} args - Arguments to update many Sects.
     * @example
     * // Update many Sects
     * const sect = await prisma.sect.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sects and only return the `id`
     * const sectWithIdOnly = await prisma.sect.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectUpdateManyAndReturnArgs>(args: SelectSubset<T, SectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sect.
     * @param {SectUpsertArgs} args - Arguments to update or create a Sect.
     * @example
     * // Update or create a Sect
     * const sect = await prisma.sect.upsert({
     *   create: {
     *     // ... data to create a Sect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sect we want to update
     *   }
     * })
     */
    upsert<T extends SectUpsertArgs>(args: SelectSubset<T, SectUpsertArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectCountArgs} args - Arguments to filter Sects to count.
     * @example
     * // Count the number of Sects
     * const count = await prisma.sect.count({
     *   where: {
     *     // ... the filter for the Sects we want to count
     *   }
     * })
    **/
    count<T extends SectCountArgs>(
      args?: Subset<T, SectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectAggregateArgs>(args: Subset<T, SectAggregateArgs>): Prisma.PrismaPromise<GetSectAggregateType<T>>

    /**
     * Group by Sect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectGroupByArgs['orderBy'] }
        : { orderBy?: SectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sect model
   */
  readonly fields: SectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Sect$membersArgs<ExtArgs> = {}>(args?: Subset<T, Sect$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sect model
   */
  interface SectFieldRefs {
    readonly id: FieldRef<"Sect", 'String'>
    readonly name: FieldRef<"Sect", 'String'>
    readonly description: FieldRef<"Sect", 'String'>
    readonly level: FieldRef<"Sect", 'Int'>
    readonly experience: FieldRef<"Sect", 'BigInt'>
    readonly leaderId: FieldRef<"Sect", 'String'>
    readonly spiritStones: FieldRef<"Sect", 'BigInt'>
    readonly reputation: FieldRef<"Sect", 'Int'>
    readonly influence: FieldRef<"Sect", 'Int'>
    readonly territory: FieldRef<"Sect", 'Int'>
    readonly buildings: FieldRef<"Sect", 'Json'>
    readonly alliances: FieldRef<"Sect", 'Json'>
    readonly enemies: FieldRef<"Sect", 'Json'>
    readonly createdAt: FieldRef<"Sect", 'DateTime'>
    readonly updatedAt: FieldRef<"Sect", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sect findUnique
   */
  export type SectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter, which Sect to fetch.
     */
    where: SectWhereUniqueInput
  }

  /**
   * Sect findUniqueOrThrow
   */
  export type SectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter, which Sect to fetch.
     */
    where: SectWhereUniqueInput
  }

  /**
   * Sect findFirst
   */
  export type SectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter, which Sect to fetch.
     */
    where?: SectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sects to fetch.
     */
    orderBy?: SectOrderByWithRelationInput | SectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sects.
     */
    cursor?: SectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sects.
     */
    distinct?: SectScalarFieldEnum | SectScalarFieldEnum[]
  }

  /**
   * Sect findFirstOrThrow
   */
  export type SectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter, which Sect to fetch.
     */
    where?: SectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sects to fetch.
     */
    orderBy?: SectOrderByWithRelationInput | SectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sects.
     */
    cursor?: SectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sects.
     */
    distinct?: SectScalarFieldEnum | SectScalarFieldEnum[]
  }

  /**
   * Sect findMany
   */
  export type SectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter, which Sects to fetch.
     */
    where?: SectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sects to fetch.
     */
    orderBy?: SectOrderByWithRelationInput | SectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sects.
     */
    cursor?: SectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sects.
     */
    skip?: number
    distinct?: SectScalarFieldEnum | SectScalarFieldEnum[]
  }

  /**
   * Sect create
   */
  export type SectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * The data needed to create a Sect.
     */
    data: XOR<SectCreateInput, SectUncheckedCreateInput>
  }

  /**
   * Sect createMany
   */
  export type SectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sects.
     */
    data: SectCreateManyInput | SectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sect createManyAndReturn
   */
  export type SectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * The data used to create many Sects.
     */
    data: SectCreateManyInput | SectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sect update
   */
  export type SectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * The data needed to update a Sect.
     */
    data: XOR<SectUpdateInput, SectUncheckedUpdateInput>
    /**
     * Choose, which Sect to update.
     */
    where: SectWhereUniqueInput
  }

  /**
   * Sect updateMany
   */
  export type SectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sects.
     */
    data: XOR<SectUpdateManyMutationInput, SectUncheckedUpdateManyInput>
    /**
     * Filter which Sects to update
     */
    where?: SectWhereInput
    /**
     * Limit how many Sects to update.
     */
    limit?: number
  }

  /**
   * Sect updateManyAndReturn
   */
  export type SectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * The data used to update Sects.
     */
    data: XOR<SectUpdateManyMutationInput, SectUncheckedUpdateManyInput>
    /**
     * Filter which Sects to update
     */
    where?: SectWhereInput
    /**
     * Limit how many Sects to update.
     */
    limit?: number
  }

  /**
   * Sect upsert
   */
  export type SectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * The filter to search for the Sect to update in case it exists.
     */
    where: SectWhereUniqueInput
    /**
     * In case the Sect found by the `where` argument doesn't exist, create a new Sect with this data.
     */
    create: XOR<SectCreateInput, SectUncheckedCreateInput>
    /**
     * In case the Sect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectUpdateInput, SectUncheckedUpdateInput>
  }

  /**
   * Sect delete
   */
  export type SectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
    /**
     * Filter which Sect to delete.
     */
    where: SectWhereUniqueInput
  }

  /**
   * Sect deleteMany
   */
  export type SectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sects to delete
     */
    where?: SectWhereInput
    /**
     * Limit how many Sects to delete.
     */
    limit?: number
  }

  /**
   * Sect.members
   */
  export type Sect$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    where?: SectMemberWhereInput
    orderBy?: SectMemberOrderByWithRelationInput | SectMemberOrderByWithRelationInput[]
    cursor?: SectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectMemberScalarFieldEnum | SectMemberScalarFieldEnum[]
  }

  /**
   * Sect without action
   */
  export type SectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sect
     */
    select?: SectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sect
     */
    omit?: SectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectInclude<ExtArgs> | null
  }


  /**
   * Model SectMember
   */

  export type AggregateSectMember = {
    _count: SectMemberCountAggregateOutputType | null
    _avg: SectMemberAvgAggregateOutputType | null
    _sum: SectMemberSumAggregateOutputType | null
    _min: SectMemberMinAggregateOutputType | null
    _max: SectMemberMaxAggregateOutputType | null
  }

  export type SectMemberAvgAggregateOutputType = {
    contribution: number | null
  }

  export type SectMemberSumAggregateOutputType = {
    contribution: bigint | null
  }

  export type SectMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sectId: string | null
    role: $Enums.SectRole | null
    contribution: bigint | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type SectMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sectId: string | null
    role: $Enums.SectRole | null
    contribution: bigint | null
    joinedAt: Date | null
    lastActiveAt: Date | null
  }

  export type SectMemberCountAggregateOutputType = {
    id: number
    userId: number
    sectId: number
    role: number
    contribution: number
    permissions: number
    joinedAt: number
    lastActiveAt: number
    _all: number
  }


  export type SectMemberAvgAggregateInputType = {
    contribution?: true
  }

  export type SectMemberSumAggregateInputType = {
    contribution?: true
  }

  export type SectMemberMinAggregateInputType = {
    id?: true
    userId?: true
    sectId?: true
    role?: true
    contribution?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type SectMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    sectId?: true
    role?: true
    contribution?: true
    joinedAt?: true
    lastActiveAt?: true
  }

  export type SectMemberCountAggregateInputType = {
    id?: true
    userId?: true
    sectId?: true
    role?: true
    contribution?: true
    permissions?: true
    joinedAt?: true
    lastActiveAt?: true
    _all?: true
  }

  export type SectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectMember to aggregate.
     */
    where?: SectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectMembers to fetch.
     */
    orderBy?: SectMemberOrderByWithRelationInput | SectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectMembers
    **/
    _count?: true | SectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectMemberMaxAggregateInputType
  }

  export type GetSectMemberAggregateType<T extends SectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectMember[P]>
      : GetScalarType<T[P], AggregateSectMember[P]>
  }




  export type SectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectMemberWhereInput
    orderBy?: SectMemberOrderByWithAggregationInput | SectMemberOrderByWithAggregationInput[]
    by: SectMemberScalarFieldEnum[] | SectMemberScalarFieldEnum
    having?: SectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectMemberCountAggregateInputType | true
    _avg?: SectMemberAvgAggregateInputType
    _sum?: SectMemberSumAggregateInputType
    _min?: SectMemberMinAggregateInputType
    _max?: SectMemberMaxAggregateInputType
  }

  export type SectMemberGroupByOutputType = {
    id: string
    userId: string
    sectId: string
    role: $Enums.SectRole
    contribution: bigint
    permissions: JsonValue
    joinedAt: Date
    lastActiveAt: Date
    _count: SectMemberCountAggregateOutputType | null
    _avg: SectMemberAvgAggregateOutputType | null
    _sum: SectMemberSumAggregateOutputType | null
    _min: SectMemberMinAggregateOutputType | null
    _max: SectMemberMaxAggregateOutputType | null
  }

  type GetSectMemberGroupByPayload<T extends SectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SectMemberGroupByOutputType[P]>
        }
      >
    >


  export type SectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectId?: boolean
    role?: boolean
    contribution?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectMember"]>

  export type SectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectId?: boolean
    role?: boolean
    contribution?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectMember"]>

  export type SectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sectId?: boolean
    role?: boolean
    contribution?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectMember"]>

  export type SectMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    sectId?: boolean
    role?: boolean
    contribution?: boolean
    permissions?: boolean
    joinedAt?: boolean
    lastActiveAt?: boolean
  }

  export type SectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sectId" | "role" | "contribution" | "permissions" | "joinedAt" | "lastActiveAt", ExtArgs["result"]["sectMember"]>
  export type SectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }
  export type SectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }
  export type SectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sect?: boolean | SectDefaultArgs<ExtArgs>
  }

  export type $SectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sect: Prisma.$SectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sectId: string
      role: $Enums.SectRole
      contribution: bigint
      permissions: Prisma.JsonValue
      joinedAt: Date
      lastActiveAt: Date
    }, ExtArgs["result"]["sectMember"]>
    composites: {}
  }

  type SectMemberGetPayload<S extends boolean | null | undefined | SectMemberDefaultArgs> = $Result.GetResult<Prisma.$SectMemberPayload, S>

  type SectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectMemberCountAggregateInputType | true
    }

  export interface SectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectMember'], meta: { name: 'SectMember' } }
    /**
     * Find zero or one SectMember that matches the filter.
     * @param {SectMemberFindUniqueArgs} args - Arguments to find a SectMember
     * @example
     * // Get one SectMember
     * const sectMember = await prisma.sectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectMemberFindUniqueArgs>(args: SelectSubset<T, SectMemberFindUniqueArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectMemberFindUniqueOrThrowArgs} args - Arguments to find a SectMember
     * @example
     * // Get one SectMember
     * const sectMember = await prisma.sectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, SectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberFindFirstArgs} args - Arguments to find a SectMember
     * @example
     * // Get one SectMember
     * const sectMember = await prisma.sectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectMemberFindFirstArgs>(args?: SelectSubset<T, SectMemberFindFirstArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberFindFirstOrThrowArgs} args - Arguments to find a SectMember
     * @example
     * // Get one SectMember
     * const sectMember = await prisma.sectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, SectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectMembers
     * const sectMembers = await prisma.sectMember.findMany()
     * 
     * // Get first 10 SectMembers
     * const sectMembers = await prisma.sectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectMemberWithIdOnly = await prisma.sectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectMemberFindManyArgs>(args?: SelectSubset<T, SectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SectMember.
     * @param {SectMemberCreateArgs} args - Arguments to create a SectMember.
     * @example
     * // Create one SectMember
     * const SectMember = await prisma.sectMember.create({
     *   data: {
     *     // ... data to create a SectMember
     *   }
     * })
     * 
     */
    create<T extends SectMemberCreateArgs>(args: SelectSubset<T, SectMemberCreateArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SectMembers.
     * @param {SectMemberCreateManyArgs} args - Arguments to create many SectMembers.
     * @example
     * // Create many SectMembers
     * const sectMember = await prisma.sectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectMemberCreateManyArgs>(args?: SelectSubset<T, SectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SectMembers and returns the data saved in the database.
     * @param {SectMemberCreateManyAndReturnArgs} args - Arguments to create many SectMembers.
     * @example
     * // Create many SectMembers
     * const sectMember = await prisma.sectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SectMembers and only return the `id`
     * const sectMemberWithIdOnly = await prisma.sectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, SectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SectMember.
     * @param {SectMemberDeleteArgs} args - Arguments to delete one SectMember.
     * @example
     * // Delete one SectMember
     * const SectMember = await prisma.sectMember.delete({
     *   where: {
     *     // ... filter to delete one SectMember
     *   }
     * })
     * 
     */
    delete<T extends SectMemberDeleteArgs>(args: SelectSubset<T, SectMemberDeleteArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SectMember.
     * @param {SectMemberUpdateArgs} args - Arguments to update one SectMember.
     * @example
     * // Update one SectMember
     * const sectMember = await prisma.sectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectMemberUpdateArgs>(args: SelectSubset<T, SectMemberUpdateArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SectMembers.
     * @param {SectMemberDeleteManyArgs} args - Arguments to filter SectMembers to delete.
     * @example
     * // Delete a few SectMembers
     * const { count } = await prisma.sectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectMemberDeleteManyArgs>(args?: SelectSubset<T, SectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectMembers
     * const sectMember = await prisma.sectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectMemberUpdateManyArgs>(args: SelectSubset<T, SectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectMembers and returns the data updated in the database.
     * @param {SectMemberUpdateManyAndReturnArgs} args - Arguments to update many SectMembers.
     * @example
     * // Update many SectMembers
     * const sectMember = await prisma.sectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SectMembers and only return the `id`
     * const sectMemberWithIdOnly = await prisma.sectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, SectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SectMember.
     * @param {SectMemberUpsertArgs} args - Arguments to update or create a SectMember.
     * @example
     * // Update or create a SectMember
     * const sectMember = await prisma.sectMember.upsert({
     *   create: {
     *     // ... data to create a SectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectMember we want to update
     *   }
     * })
     */
    upsert<T extends SectMemberUpsertArgs>(args: SelectSubset<T, SectMemberUpsertArgs<ExtArgs>>): Prisma__SectMemberClient<$Result.GetResult<Prisma.$SectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberCountArgs} args - Arguments to filter SectMembers to count.
     * @example
     * // Count the number of SectMembers
     * const count = await prisma.sectMember.count({
     *   where: {
     *     // ... the filter for the SectMembers we want to count
     *   }
     * })
    **/
    count<T extends SectMemberCountArgs>(
      args?: Subset<T, SectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectMemberAggregateArgs>(args: Subset<T, SectMemberAggregateArgs>): Prisma.PrismaPromise<GetSectMemberAggregateType<T>>

    /**
     * Group by SectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectMemberGroupByArgs['orderBy'] }
        : { orderBy?: SectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectMember model
   */
  readonly fields: SectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sect<T extends SectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectDefaultArgs<ExtArgs>>): Prisma__SectClient<$Result.GetResult<Prisma.$SectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectMember model
   */
  interface SectMemberFieldRefs {
    readonly id: FieldRef<"SectMember", 'String'>
    readonly userId: FieldRef<"SectMember", 'String'>
    readonly sectId: FieldRef<"SectMember", 'String'>
    readonly role: FieldRef<"SectMember", 'SectRole'>
    readonly contribution: FieldRef<"SectMember", 'BigInt'>
    readonly permissions: FieldRef<"SectMember", 'Json'>
    readonly joinedAt: FieldRef<"SectMember", 'DateTime'>
    readonly lastActiveAt: FieldRef<"SectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SectMember findUnique
   */
  export type SectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter, which SectMember to fetch.
     */
    where: SectMemberWhereUniqueInput
  }

  /**
   * SectMember findUniqueOrThrow
   */
  export type SectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter, which SectMember to fetch.
     */
    where: SectMemberWhereUniqueInput
  }

  /**
   * SectMember findFirst
   */
  export type SectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter, which SectMember to fetch.
     */
    where?: SectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectMembers to fetch.
     */
    orderBy?: SectMemberOrderByWithRelationInput | SectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectMembers.
     */
    cursor?: SectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectMembers.
     */
    distinct?: SectMemberScalarFieldEnum | SectMemberScalarFieldEnum[]
  }

  /**
   * SectMember findFirstOrThrow
   */
  export type SectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter, which SectMember to fetch.
     */
    where?: SectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectMembers to fetch.
     */
    orderBy?: SectMemberOrderByWithRelationInput | SectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectMembers.
     */
    cursor?: SectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectMembers.
     */
    distinct?: SectMemberScalarFieldEnum | SectMemberScalarFieldEnum[]
  }

  /**
   * SectMember findMany
   */
  export type SectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter, which SectMembers to fetch.
     */
    where?: SectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectMembers to fetch.
     */
    orderBy?: SectMemberOrderByWithRelationInput | SectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectMembers.
     */
    cursor?: SectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectMembers.
     */
    skip?: number
    distinct?: SectMemberScalarFieldEnum | SectMemberScalarFieldEnum[]
  }

  /**
   * SectMember create
   */
  export type SectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SectMember.
     */
    data: XOR<SectMemberCreateInput, SectMemberUncheckedCreateInput>
  }

  /**
   * SectMember createMany
   */
  export type SectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectMembers.
     */
    data: SectMemberCreateManyInput | SectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectMember createManyAndReturn
   */
  export type SectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many SectMembers.
     */
    data: SectMemberCreateManyInput | SectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SectMember update
   */
  export type SectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SectMember.
     */
    data: XOR<SectMemberUpdateInput, SectMemberUncheckedUpdateInput>
    /**
     * Choose, which SectMember to update.
     */
    where: SectMemberWhereUniqueInput
  }

  /**
   * SectMember updateMany
   */
  export type SectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectMembers.
     */
    data: XOR<SectMemberUpdateManyMutationInput, SectMemberUncheckedUpdateManyInput>
    /**
     * Filter which SectMembers to update
     */
    where?: SectMemberWhereInput
    /**
     * Limit how many SectMembers to update.
     */
    limit?: number
  }

  /**
   * SectMember updateManyAndReturn
   */
  export type SectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * The data used to update SectMembers.
     */
    data: XOR<SectMemberUpdateManyMutationInput, SectMemberUncheckedUpdateManyInput>
    /**
     * Filter which SectMembers to update
     */
    where?: SectMemberWhereInput
    /**
     * Limit how many SectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SectMember upsert
   */
  export type SectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SectMember to update in case it exists.
     */
    where: SectMemberWhereUniqueInput
    /**
     * In case the SectMember found by the `where` argument doesn't exist, create a new SectMember with this data.
     */
    create: XOR<SectMemberCreateInput, SectMemberUncheckedCreateInput>
    /**
     * In case the SectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectMemberUpdateInput, SectMemberUncheckedUpdateInput>
  }

  /**
   * SectMember delete
   */
  export type SectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
    /**
     * Filter which SectMember to delete.
     */
    where: SectMemberWhereUniqueInput
  }

  /**
   * SectMember deleteMany
   */
  export type SectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectMembers to delete
     */
    where?: SectMemberWhereInput
    /**
     * Limit how many SectMembers to delete.
     */
    limit?: number
  }

  /**
   * SectMember without action
   */
  export type SectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectMember
     */
    select?: SectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectMember
     */
    omit?: SectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    maxProgress: number | null
  }

  export type AchievementSumAggregateOutputType = {
    maxProgress: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AchievementCategory | null
    maxProgress: number | null
    isHidden: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AchievementCategory | null
    maxProgress: number | null
    isHidden: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    maxProgress: number
    rewards: number
    isHidden: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    maxProgress?: true
  }

  export type AchievementSumAggregateInputType = {
    maxProgress?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    maxProgress?: true
    isHidden?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    maxProgress?: true
    isHidden?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    maxProgress?: true
    rewards?: true
    isHidden?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    category: $Enums.AchievementCategory
    maxProgress: number
    rewards: JsonValue
    isHidden: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    maxProgress?: boolean
    rewards?: boolean
    isHidden?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    maxProgress?: boolean
    rewards?: boolean
    isHidden?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    maxProgress?: boolean
    rewards?: boolean
    isHidden?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    maxProgress?: boolean
    rewards?: boolean
    isHidden?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "maxProgress" | "rewards" | "isHidden" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: $Enums.AchievementCategory
      maxProgress: number
      rewards: Prisma.JsonValue
      isHidden: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
    readonly maxProgress: FieldRef<"Achievement", 'Int'>
    readonly rewards: FieldRef<"Achievement", 'Json'>
    readonly isHidden: FieldRef<"Achievement", 'Boolean'>
    readonly isActive: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    isCompleted: boolean | null
    completedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    isCompleted: boolean | null
    completedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    progress: number
    isCompleted: number
    completedAt: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    isCompleted?: true
    completedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    progress: number
    isCompleted: boolean
    completedAt: Date | null
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    isCompleted?: boolean
    completedAt?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "progress" | "isCompleted" | "completedAt", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      progress: number
      isCompleted: boolean
      completedAt: Date | null
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly progress: FieldRef<"UserAchievement", 'Int'>
    readonly isCompleted: FieldRef<"UserAchievement", 'Boolean'>
    readonly completedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model GameStatistics
   */

  export type AggregateGameStatistics = {
    _count: GameStatisticsCountAggregateOutputType | null
    _avg: GameStatisticsAvgAggregateOutputType | null
    _sum: GameStatisticsSumAggregateOutputType | null
    _min: GameStatisticsMinAggregateOutputType | null
    _max: GameStatisticsMaxAggregateOutputType | null
  }

  export type GameStatisticsAvgAggregateOutputType = {
    totalPlayTime: number | null
    cultivationTime: number | null
    combatWins: number | null
    combatLosses: number | null
    itemsCrafted: number | null
    achievementsUnlocked: number | null
    realmBreakthroughs: number | null
    sectContribution: number | null
  }

  export type GameStatisticsSumAggregateOutputType = {
    totalPlayTime: bigint | null
    cultivationTime: bigint | null
    combatWins: number | null
    combatLosses: number | null
    itemsCrafted: number | null
    achievementsUnlocked: number | null
    realmBreakthroughs: number | null
    sectContribution: bigint | null
  }

  export type GameStatisticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPlayTime: bigint | null
    cultivationTime: bigint | null
    combatWins: number | null
    combatLosses: number | null
    itemsCrafted: number | null
    achievementsUnlocked: number | null
    realmBreakthroughs: number | null
    sectContribution: bigint | null
    lastUpdated: Date | null
  }

  export type GameStatisticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPlayTime: bigint | null
    cultivationTime: bigint | null
    combatWins: number | null
    combatLosses: number | null
    itemsCrafted: number | null
    achievementsUnlocked: number | null
    realmBreakthroughs: number | null
    sectContribution: bigint | null
    lastUpdated: Date | null
  }

  export type GameStatisticsCountAggregateOutputType = {
    id: number
    userId: number
    totalPlayTime: number
    cultivationTime: number
    combatWins: number
    combatLosses: number
    itemsCrafted: number
    achievementsUnlocked: number
    realmBreakthroughs: number
    sectContribution: number
    resourcesEarned: number
    lastUpdated: number
    _all: number
  }


  export type GameStatisticsAvgAggregateInputType = {
    totalPlayTime?: true
    cultivationTime?: true
    combatWins?: true
    combatLosses?: true
    itemsCrafted?: true
    achievementsUnlocked?: true
    realmBreakthroughs?: true
    sectContribution?: true
  }

  export type GameStatisticsSumAggregateInputType = {
    totalPlayTime?: true
    cultivationTime?: true
    combatWins?: true
    combatLosses?: true
    itemsCrafted?: true
    achievementsUnlocked?: true
    realmBreakthroughs?: true
    sectContribution?: true
  }

  export type GameStatisticsMinAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    cultivationTime?: true
    combatWins?: true
    combatLosses?: true
    itemsCrafted?: true
    achievementsUnlocked?: true
    realmBreakthroughs?: true
    sectContribution?: true
    lastUpdated?: true
  }

  export type GameStatisticsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    cultivationTime?: true
    combatWins?: true
    combatLosses?: true
    itemsCrafted?: true
    achievementsUnlocked?: true
    realmBreakthroughs?: true
    sectContribution?: true
    lastUpdated?: true
  }

  export type GameStatisticsCountAggregateInputType = {
    id?: true
    userId?: true
    totalPlayTime?: true
    cultivationTime?: true
    combatWins?: true
    combatLosses?: true
    itemsCrafted?: true
    achievementsUnlocked?: true
    realmBreakthroughs?: true
    sectContribution?: true
    resourcesEarned?: true
    lastUpdated?: true
    _all?: true
  }

  export type GameStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStatistics to aggregate.
     */
    where?: GameStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatistics to fetch.
     */
    orderBy?: GameStatisticsOrderByWithRelationInput | GameStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameStatistics
    **/
    _count?: true | GameStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameStatisticsMaxAggregateInputType
  }

  export type GetGameStatisticsAggregateType<T extends GameStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateGameStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameStatistics[P]>
      : GetScalarType<T[P], AggregateGameStatistics[P]>
  }




  export type GameStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatisticsWhereInput
    orderBy?: GameStatisticsOrderByWithAggregationInput | GameStatisticsOrderByWithAggregationInput[]
    by: GameStatisticsScalarFieldEnum[] | GameStatisticsScalarFieldEnum
    having?: GameStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameStatisticsCountAggregateInputType | true
    _avg?: GameStatisticsAvgAggregateInputType
    _sum?: GameStatisticsSumAggregateInputType
    _min?: GameStatisticsMinAggregateInputType
    _max?: GameStatisticsMaxAggregateInputType
  }

  export type GameStatisticsGroupByOutputType = {
    id: string
    userId: string
    totalPlayTime: bigint
    cultivationTime: bigint
    combatWins: number
    combatLosses: number
    itemsCrafted: number
    achievementsUnlocked: number
    realmBreakthroughs: number
    sectContribution: bigint
    resourcesEarned: JsonValue
    lastUpdated: Date
    _count: GameStatisticsCountAggregateOutputType | null
    _avg: GameStatisticsAvgAggregateOutputType | null
    _sum: GameStatisticsSumAggregateOutputType | null
    _min: GameStatisticsMinAggregateOutputType | null
    _max: GameStatisticsMaxAggregateOutputType | null
  }

  type GetGameStatisticsGroupByPayload<T extends GameStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], GameStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type GameStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    cultivationTime?: boolean
    combatWins?: boolean
    combatLosses?: boolean
    itemsCrafted?: boolean
    achievementsUnlocked?: boolean
    realmBreakthroughs?: boolean
    sectContribution?: boolean
    resourcesEarned?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatistics"]>

  export type GameStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    cultivationTime?: boolean
    combatWins?: boolean
    combatLosses?: boolean
    itemsCrafted?: boolean
    achievementsUnlocked?: boolean
    realmBreakthroughs?: boolean
    sectContribution?: boolean
    resourcesEarned?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatistics"]>

  export type GameStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    cultivationTime?: boolean
    combatWins?: boolean
    combatLosses?: boolean
    itemsCrafted?: boolean
    achievementsUnlocked?: boolean
    realmBreakthroughs?: boolean
    sectContribution?: boolean
    resourcesEarned?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStatistics"]>

  export type GameStatisticsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalPlayTime?: boolean
    cultivationTime?: boolean
    combatWins?: boolean
    combatLosses?: boolean
    itemsCrafted?: boolean
    achievementsUnlocked?: boolean
    realmBreakthroughs?: boolean
    sectContribution?: boolean
    resourcesEarned?: boolean
    lastUpdated?: boolean
  }

  export type GameStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalPlayTime" | "cultivationTime" | "combatWins" | "combatLosses" | "itemsCrafted" | "achievementsUnlocked" | "realmBreakthroughs" | "sectContribution" | "resourcesEarned" | "lastUpdated", ExtArgs["result"]["gameStatistics"]>
  export type GameStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameStatisticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameStatistics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalPlayTime: bigint
      cultivationTime: bigint
      combatWins: number
      combatLosses: number
      itemsCrafted: number
      achievementsUnlocked: number
      realmBreakthroughs: number
      sectContribution: bigint
      resourcesEarned: Prisma.JsonValue
      lastUpdated: Date
    }, ExtArgs["result"]["gameStatistics"]>
    composites: {}
  }

  type GameStatisticsGetPayload<S extends boolean | null | undefined | GameStatisticsDefaultArgs> = $Result.GetResult<Prisma.$GameStatisticsPayload, S>

  type GameStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameStatisticsCountAggregateInputType | true
    }

  export interface GameStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameStatistics'], meta: { name: 'GameStatistics' } }
    /**
     * Find zero or one GameStatistics that matches the filter.
     * @param {GameStatisticsFindUniqueArgs} args - Arguments to find a GameStatistics
     * @example
     * // Get one GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameStatisticsFindUniqueArgs>(args: SelectSubset<T, GameStatisticsFindUniqueArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameStatisticsFindUniqueOrThrowArgs} args - Arguments to find a GameStatistics
     * @example
     * // Get one GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, GameStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsFindFirstArgs} args - Arguments to find a GameStatistics
     * @example
     * // Get one GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameStatisticsFindFirstArgs>(args?: SelectSubset<T, GameStatisticsFindFirstArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsFindFirstOrThrowArgs} args - Arguments to find a GameStatistics
     * @example
     * // Get one GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, GameStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findMany()
     * 
     * // Get first 10 GameStatistics
     * const gameStatistics = await prisma.gameStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameStatisticsWithIdOnly = await prisma.gameStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameStatisticsFindManyArgs>(args?: SelectSubset<T, GameStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameStatistics.
     * @param {GameStatisticsCreateArgs} args - Arguments to create a GameStatistics.
     * @example
     * // Create one GameStatistics
     * const GameStatistics = await prisma.gameStatistics.create({
     *   data: {
     *     // ... data to create a GameStatistics
     *   }
     * })
     * 
     */
    create<T extends GameStatisticsCreateArgs>(args: SelectSubset<T, GameStatisticsCreateArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameStatistics.
     * @param {GameStatisticsCreateManyArgs} args - Arguments to create many GameStatistics.
     * @example
     * // Create many GameStatistics
     * const gameStatistics = await prisma.gameStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameStatisticsCreateManyArgs>(args?: SelectSubset<T, GameStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameStatistics and returns the data saved in the database.
     * @param {GameStatisticsCreateManyAndReturnArgs} args - Arguments to create many GameStatistics.
     * @example
     * // Create many GameStatistics
     * const gameStatistics = await prisma.gameStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameStatistics and only return the `id`
     * const gameStatisticsWithIdOnly = await prisma.gameStatistics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, GameStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameStatistics.
     * @param {GameStatisticsDeleteArgs} args - Arguments to delete one GameStatistics.
     * @example
     * // Delete one GameStatistics
     * const GameStatistics = await prisma.gameStatistics.delete({
     *   where: {
     *     // ... filter to delete one GameStatistics
     *   }
     * })
     * 
     */
    delete<T extends GameStatisticsDeleteArgs>(args: SelectSubset<T, GameStatisticsDeleteArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameStatistics.
     * @param {GameStatisticsUpdateArgs} args - Arguments to update one GameStatistics.
     * @example
     * // Update one GameStatistics
     * const gameStatistics = await prisma.gameStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameStatisticsUpdateArgs>(args: SelectSubset<T, GameStatisticsUpdateArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameStatistics.
     * @param {GameStatisticsDeleteManyArgs} args - Arguments to filter GameStatistics to delete.
     * @example
     * // Delete a few GameStatistics
     * const { count } = await prisma.gameStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameStatisticsDeleteManyArgs>(args?: SelectSubset<T, GameStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameStatistics
     * const gameStatistics = await prisma.gameStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameStatisticsUpdateManyArgs>(args: SelectSubset<T, GameStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStatistics and returns the data updated in the database.
     * @param {GameStatisticsUpdateManyAndReturnArgs} args - Arguments to update many GameStatistics.
     * @example
     * // Update many GameStatistics
     * const gameStatistics = await prisma.gameStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameStatistics and only return the `id`
     * const gameStatisticsWithIdOnly = await prisma.gameStatistics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, GameStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameStatistics.
     * @param {GameStatisticsUpsertArgs} args - Arguments to update or create a GameStatistics.
     * @example
     * // Update or create a GameStatistics
     * const gameStatistics = await prisma.gameStatistics.upsert({
     *   create: {
     *     // ... data to create a GameStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameStatistics we want to update
     *   }
     * })
     */
    upsert<T extends GameStatisticsUpsertArgs>(args: SelectSubset<T, GameStatisticsUpsertArgs<ExtArgs>>): Prisma__GameStatisticsClient<$Result.GetResult<Prisma.$GameStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsCountArgs} args - Arguments to filter GameStatistics to count.
     * @example
     * // Count the number of GameStatistics
     * const count = await prisma.gameStatistics.count({
     *   where: {
     *     // ... the filter for the GameStatistics we want to count
     *   }
     * })
    **/
    count<T extends GameStatisticsCountArgs>(
      args?: Subset<T, GameStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameStatisticsAggregateArgs>(args: Subset<T, GameStatisticsAggregateArgs>): Prisma.PrismaPromise<GetGameStatisticsAggregateType<T>>

    /**
     * Group by GameStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: GameStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameStatistics model
   */
  readonly fields: GameStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameStatistics model
   */
  interface GameStatisticsFieldRefs {
    readonly id: FieldRef<"GameStatistics", 'String'>
    readonly userId: FieldRef<"GameStatistics", 'String'>
    readonly totalPlayTime: FieldRef<"GameStatistics", 'BigInt'>
    readonly cultivationTime: FieldRef<"GameStatistics", 'BigInt'>
    readonly combatWins: FieldRef<"GameStatistics", 'Int'>
    readonly combatLosses: FieldRef<"GameStatistics", 'Int'>
    readonly itemsCrafted: FieldRef<"GameStatistics", 'Int'>
    readonly achievementsUnlocked: FieldRef<"GameStatistics", 'Int'>
    readonly realmBreakthroughs: FieldRef<"GameStatistics", 'Int'>
    readonly sectContribution: FieldRef<"GameStatistics", 'BigInt'>
    readonly resourcesEarned: FieldRef<"GameStatistics", 'Json'>
    readonly lastUpdated: FieldRef<"GameStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameStatistics findUnique
   */
  export type GameStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GameStatistics to fetch.
     */
    where: GameStatisticsWhereUniqueInput
  }

  /**
   * GameStatistics findUniqueOrThrow
   */
  export type GameStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GameStatistics to fetch.
     */
    where: GameStatisticsWhereUniqueInput
  }

  /**
   * GameStatistics findFirst
   */
  export type GameStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GameStatistics to fetch.
     */
    where?: GameStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatistics to fetch.
     */
    orderBy?: GameStatisticsOrderByWithRelationInput | GameStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStatistics.
     */
    cursor?: GameStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStatistics.
     */
    distinct?: GameStatisticsScalarFieldEnum | GameStatisticsScalarFieldEnum[]
  }

  /**
   * GameStatistics findFirstOrThrow
   */
  export type GameStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GameStatistics to fetch.
     */
    where?: GameStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatistics to fetch.
     */
    orderBy?: GameStatisticsOrderByWithRelationInput | GameStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStatistics.
     */
    cursor?: GameStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStatistics.
     */
    distinct?: GameStatisticsScalarFieldEnum | GameStatisticsScalarFieldEnum[]
  }

  /**
   * GameStatistics findMany
   */
  export type GameStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GameStatistics to fetch.
     */
    where?: GameStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStatistics to fetch.
     */
    orderBy?: GameStatisticsOrderByWithRelationInput | GameStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameStatistics.
     */
    cursor?: GameStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStatistics.
     */
    skip?: number
    distinct?: GameStatisticsScalarFieldEnum | GameStatisticsScalarFieldEnum[]
  }

  /**
   * GameStatistics create
   */
  export type GameStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a GameStatistics.
     */
    data: XOR<GameStatisticsCreateInput, GameStatisticsUncheckedCreateInput>
  }

  /**
   * GameStatistics createMany
   */
  export type GameStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameStatistics.
     */
    data: GameStatisticsCreateManyInput | GameStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameStatistics createManyAndReturn
   */
  export type GameStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many GameStatistics.
     */
    data: GameStatisticsCreateManyInput | GameStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStatistics update
   */
  export type GameStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a GameStatistics.
     */
    data: XOR<GameStatisticsUpdateInput, GameStatisticsUncheckedUpdateInput>
    /**
     * Choose, which GameStatistics to update.
     */
    where: GameStatisticsWhereUniqueInput
  }

  /**
   * GameStatistics updateMany
   */
  export type GameStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameStatistics.
     */
    data: XOR<GameStatisticsUpdateManyMutationInput, GameStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which GameStatistics to update
     */
    where?: GameStatisticsWhereInput
    /**
     * Limit how many GameStatistics to update.
     */
    limit?: number
  }

  /**
   * GameStatistics updateManyAndReturn
   */
  export type GameStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update GameStatistics.
     */
    data: XOR<GameStatisticsUpdateManyMutationInput, GameStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which GameStatistics to update
     */
    where?: GameStatisticsWhereInput
    /**
     * Limit how many GameStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStatistics upsert
   */
  export type GameStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the GameStatistics to update in case it exists.
     */
    where: GameStatisticsWhereUniqueInput
    /**
     * In case the GameStatistics found by the `where` argument doesn't exist, create a new GameStatistics with this data.
     */
    create: XOR<GameStatisticsCreateInput, GameStatisticsUncheckedCreateInput>
    /**
     * In case the GameStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameStatisticsUpdateInput, GameStatisticsUncheckedUpdateInput>
  }

  /**
   * GameStatistics delete
   */
  export type GameStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
    /**
     * Filter which GameStatistics to delete.
     */
    where: GameStatisticsWhereUniqueInput
  }

  /**
   * GameStatistics deleteMany
   */
  export type GameStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStatistics to delete
     */
    where?: GameStatisticsWhereInput
    /**
     * Limit how many GameStatistics to delete.
     */
    limit?: number
  }

  /**
   * GameStatistics without action
   */
  export type GameStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStatistics
     */
    select?: GameStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStatistics
     */
    omit?: GameStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model GameEvent
   */

  export type AggregateGameEvent = {
    _count: GameEventCountAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  export type GameEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.GameEventType | null
    processed: boolean | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type GameEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.GameEventType | null
    processed: boolean | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type GameEventCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    data: number
    processed: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type GameEventMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    processed?: true
    createdAt?: true
    processedAt?: true
  }

  export type GameEventMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    processed?: true
    createdAt?: true
    processedAt?: true
  }

  export type GameEventCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    data?: true
    processed?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type GameEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvent to aggregate.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameEvents
    **/
    _count?: true | GameEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameEventMaxAggregateInputType
  }

  export type GetGameEventAggregateType<T extends GameEventAggregateArgs> = {
        [P in keyof T & keyof AggregateGameEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameEvent[P]>
      : GetScalarType<T[P], AggregateGameEvent[P]>
  }




  export type GameEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithAggregationInput | GameEventOrderByWithAggregationInput[]
    by: GameEventScalarFieldEnum[] | GameEventScalarFieldEnum
    having?: GameEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameEventCountAggregateInputType | true
    _min?: GameEventMinAggregateInputType
    _max?: GameEventMaxAggregateInputType
  }

  export type GameEventGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.GameEventType
    data: JsonValue
    processed: boolean
    createdAt: Date
    processedAt: Date | null
    _count: GameEventCountAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  type GetGameEventGroupByPayload<T extends GameEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameEventGroupByOutputType[P]>
            : GetScalarType<T[P], GameEventGroupByOutputType[P]>
        }
      >
    >


  export type GameEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    processed?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    processed?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    processed?: boolean
    createdAt?: boolean
    processedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    processed?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type GameEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "data" | "processed" | "createdAt" | "processedAt", ExtArgs["result"]["gameEvent"]>
  export type GameEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.GameEventType
      data: Prisma.JsonValue
      processed: boolean
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["gameEvent"]>
    composites: {}
  }

  type GameEventGetPayload<S extends boolean | null | undefined | GameEventDefaultArgs> = $Result.GetResult<Prisma.$GameEventPayload, S>

  type GameEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameEventCountAggregateInputType | true
    }

  export interface GameEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameEvent'], meta: { name: 'GameEvent' } }
    /**
     * Find zero or one GameEvent that matches the filter.
     * @param {GameEventFindUniqueArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameEventFindUniqueArgs>(args: SelectSubset<T, GameEventFindUniqueArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameEventFindUniqueOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameEventFindUniqueOrThrowArgs>(args: SelectSubset<T, GameEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameEventFindFirstArgs>(args?: SelectSubset<T, GameEventFindFirstArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameEventFindFirstOrThrowArgs>(args?: SelectSubset<T, GameEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameEvents
     * const gameEvents = await prisma.gameEvent.findMany()
     * 
     * // Get first 10 GameEvents
     * const gameEvents = await prisma.gameEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameEventFindManyArgs>(args?: SelectSubset<T, GameEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameEvent.
     * @param {GameEventCreateArgs} args - Arguments to create a GameEvent.
     * @example
     * // Create one GameEvent
     * const GameEvent = await prisma.gameEvent.create({
     *   data: {
     *     // ... data to create a GameEvent
     *   }
     * })
     * 
     */
    create<T extends GameEventCreateArgs>(args: SelectSubset<T, GameEventCreateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameEvents.
     * @param {GameEventCreateManyArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameEventCreateManyArgs>(args?: SelectSubset<T, GameEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameEvents and returns the data saved in the database.
     * @param {GameEventCreateManyAndReturnArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameEventCreateManyAndReturnArgs>(args?: SelectSubset<T, GameEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameEvent.
     * @param {GameEventDeleteArgs} args - Arguments to delete one GameEvent.
     * @example
     * // Delete one GameEvent
     * const GameEvent = await prisma.gameEvent.delete({
     *   where: {
     *     // ... filter to delete one GameEvent
     *   }
     * })
     * 
     */
    delete<T extends GameEventDeleteArgs>(args: SelectSubset<T, GameEventDeleteArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameEvent.
     * @param {GameEventUpdateArgs} args - Arguments to update one GameEvent.
     * @example
     * // Update one GameEvent
     * const gameEvent = await prisma.gameEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameEventUpdateArgs>(args: SelectSubset<T, GameEventUpdateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameEvents.
     * @param {GameEventDeleteManyArgs} args - Arguments to filter GameEvents to delete.
     * @example
     * // Delete a few GameEvents
     * const { count } = await prisma.gameEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameEventDeleteManyArgs>(args?: SelectSubset<T, GameEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameEventUpdateManyArgs>(args: SelectSubset<T, GameEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents and returns the data updated in the database.
     * @param {GameEventUpdateManyAndReturnArgs} args - Arguments to update many GameEvents.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameEventUpdateManyAndReturnArgs>(args: SelectSubset<T, GameEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameEvent.
     * @param {GameEventUpsertArgs} args - Arguments to update or create a GameEvent.
     * @example
     * // Update or create a GameEvent
     * const gameEvent = await prisma.gameEvent.upsert({
     *   create: {
     *     // ... data to create a GameEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameEvent we want to update
     *   }
     * })
     */
    upsert<T extends GameEventUpsertArgs>(args: SelectSubset<T, GameEventUpsertArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventCountArgs} args - Arguments to filter GameEvents to count.
     * @example
     * // Count the number of GameEvents
     * const count = await prisma.gameEvent.count({
     *   where: {
     *     // ... the filter for the GameEvents we want to count
     *   }
     * })
    **/
    count<T extends GameEventCountArgs>(
      args?: Subset<T, GameEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameEventAggregateArgs>(args: Subset<T, GameEventAggregateArgs>): Prisma.PrismaPromise<GetGameEventAggregateType<T>>

    /**
     * Group by GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameEventGroupByArgs['orderBy'] }
        : { orderBy?: GameEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameEvent model
   */
  readonly fields: GameEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameEvent model
   */
  interface GameEventFieldRefs {
    readonly id: FieldRef<"GameEvent", 'String'>
    readonly userId: FieldRef<"GameEvent", 'String'>
    readonly type: FieldRef<"GameEvent", 'GameEventType'>
    readonly data: FieldRef<"GameEvent", 'Json'>
    readonly processed: FieldRef<"GameEvent", 'Boolean'>
    readonly createdAt: FieldRef<"GameEvent", 'DateTime'>
    readonly processedAt: FieldRef<"GameEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameEvent findUnique
   */
  export type GameEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findUniqueOrThrow
   */
  export type GameEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findFirst
   */
  export type GameEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findFirstOrThrow
   */
  export type GameEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findMany
   */
  export type GameEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter, which GameEvents to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent create
   */
  export type GameEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to create a GameEvent.
     */
    data: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
  }

  /**
   * GameEvent createMany
   */
  export type GameEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameEvent createManyAndReturn
   */
  export type GameEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameEvent update
   */
  export type GameEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The data needed to update a GameEvent.
     */
    data: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
    /**
     * Choose, which GameEvent to update.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent updateMany
   */
  export type GameEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to update.
     */
    limit?: number
  }

  /**
   * GameEvent updateManyAndReturn
   */
  export type GameEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameEvent upsert
   */
  export type GameEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * The filter to search for the GameEvent to update in case it exists.
     */
    where: GameEventWhereUniqueInput
    /**
     * In case the GameEvent found by the `where` argument doesn't exist, create a new GameEvent with this data.
     */
    create: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
    /**
     * In case the GameEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
  }

  /**
   * GameEvent delete
   */
  export type GameEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
    /**
     * Filter which GameEvent to delete.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent deleteMany
   */
  export type GameEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvents to delete
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to delete.
     */
    limit?: number
  }

  /**
   * GameEvent without action
   */
  export type GameEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    avatar: 'avatar',
    title: 'title',
    biography: 'biography',
    autoSave: 'autoSave',
    notifications: 'notifications',
    soundEnabled: 'soundEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastActiveAt: 'lastActiveAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    realm: 'realm',
    level: 'level',
    experience: 'experience',
    experienceToNext: 'experienceToNext',
    strength: 'strength',
    agility: 'agility',
    intelligence: 'intelligence',
    constitution: 'constitution',
    perception: 'perception',
    luck: 'luck',
    spiritualElement: 'spiritualElement',
    spiritualPurity: 'spiritualPurity',
    spiritualGrade: 'spiritualGrade',
    bloodlineId: 'bloodlineId',
    bloodlineAwakening: 'bloodlineAwakening',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CultivationProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentTechniqueId: 'currentTechniqueId',
    qiAmount: 'qiAmount',
    qiCapacity: 'qiCapacity',
    cultivationSpeed: 'cultivationSpeed',
    bottleneckProgress: 'bottleneckProgress',
    breakthroughAttempts: 'breakthroughAttempts',
    stabilityPercentage: 'stabilityPercentage',
    isSessionActive: 'isSessionActive',
    sessionStartTime: 'sessionStartTime',
    sessionDuration: 'sessionDuration',
    sessionQiGained: 'sessionQiGained',
    sessionExpGained: 'sessionExpGained',
    lastCalculatedAt: 'lastCalculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CultivationProgressScalarFieldEnum = (typeof CultivationProgressScalarFieldEnum)[keyof typeof CultivationProgressScalarFieldEnum]


  export const CultivationTechniqueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    element: 'element',
    minRealm: 'minRealm',
    minLevel: 'minLevel',
    baseSpeed: 'baseSpeed',
    qiEfficiency: 'qiEfficiency',
    stabilityBonus: 'stabilityBonus',
    rarity: 'rarity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CultivationTechniqueScalarFieldEnum = (typeof CultivationTechniqueScalarFieldEnum)[keyof typeof CultivationTechniqueScalarFieldEnum]


  export const CharacterTechniqueScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    techniqueId: 'techniqueId',
    proficiency: 'proficiency',
    level: 'level',
    experience: 'experience',
    masteryBonus: 'masteryBonus',
    learnedAt: 'learnedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type CharacterTechniqueScalarFieldEnum = (typeof CharacterTechniqueScalarFieldEnum)[keyof typeof CharacterTechniqueScalarFieldEnum]


  export const TalentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    effects: 'effects',
    requirements: 'requirements',
    rarity: 'rarity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TalentScalarFieldEnum = (typeof TalentScalarFieldEnum)[keyof typeof TalentScalarFieldEnum]


  export const CharacterTalentScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    talentId: 'talentId',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt'
  };

  export type CharacterTalentScalarFieldEnum = (typeof CharacterTalentScalarFieldEnum)[keyof typeof CharacterTalentScalarFieldEnum]


  export const BloodlineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rarity: 'rarity',
    abilities: 'abilities',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BloodlineScalarFieldEnum = (typeof BloodlineScalarFieldEnum)[keyof typeof BloodlineScalarFieldEnum]


  export const ResourcesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    spiritStones: 'spiritStones',
    gold: 'gold',
    materials: 'materials',
    pills: 'pills',
    herbs: 'herbs',
    lastUpdated: 'lastUpdated'
  };

  export type ResourcesScalarFieldEnum = (typeof ResourcesScalarFieldEnum)[keyof typeof ResourcesScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    rarity: 'rarity',
    value: 'value',
    stackable: 'stackable',
    tradeable: 'tradeable',
    consumable: 'consumable',
    effects: 'effects',
    requirements: 'requirements',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId',
    quantity: 'quantity',
    metadata: 'metadata',
    acquiredAt: 'acquiredAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const CombatStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    level: 'level',
    health: 'health',
    maxHealth: 'maxHealth',
    attack: 'attack',
    defense: 'defense',
    speed: 'speed',
    criticalChance: 'criticalChance',
    criticalDamage: 'criticalDamage',
    combatExperience: 'combatExperience',
    wins: 'wins',
    losses: 'losses',
    draws: 'draws',
    lastCombatAt: 'lastCombatAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CombatStatsScalarFieldEnum = (typeof CombatStatsScalarFieldEnum)[keyof typeof CombatStatsScalarFieldEnum]


  export const CombatLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    opponentName: 'opponentName',
    result: 'result',
    duration: 'duration',
    damageDealt: 'damageDealt',
    damageReceived: 'damageReceived',
    experienceGained: 'experienceGained',
    lootGained: 'lootGained',
    combatDetails: 'combatDetails',
    foughtAt: 'foughtAt'
  };

  export type CombatLogScalarFieldEnum = (typeof CombatLogScalarFieldEnum)[keyof typeof CombatLogScalarFieldEnum]


  export const SectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    level: 'level',
    experience: 'experience',
    leaderId: 'leaderId',
    spiritStones: 'spiritStones',
    reputation: 'reputation',
    influence: 'influence',
    territory: 'territory',
    buildings: 'buildings',
    alliances: 'alliances',
    enemies: 'enemies',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectScalarFieldEnum = (typeof SectScalarFieldEnum)[keyof typeof SectScalarFieldEnum]


  export const SectMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sectId: 'sectId',
    role: 'role',
    contribution: 'contribution',
    permissions: 'permissions',
    joinedAt: 'joinedAt',
    lastActiveAt: 'lastActiveAt'
  };

  export type SectMemberScalarFieldEnum = (typeof SectMemberScalarFieldEnum)[keyof typeof SectMemberScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    maxProgress: 'maxProgress',
    rewards: 'rewards',
    isHidden: 'isHidden',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    progress: 'progress',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const GameStatisticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalPlayTime: 'totalPlayTime',
    cultivationTime: 'cultivationTime',
    combatWins: 'combatWins',
    combatLosses: 'combatLosses',
    itemsCrafted: 'itemsCrafted',
    achievementsUnlocked: 'achievementsUnlocked',
    realmBreakthroughs: 'realmBreakthroughs',
    sectContribution: 'sectContribution',
    resourcesEarned: 'resourcesEarned',
    lastUpdated: 'lastUpdated'
  };

  export type GameStatisticsScalarFieldEnum = (typeof GameStatisticsScalarFieldEnum)[keyof typeof GameStatisticsScalarFieldEnum]


  export const GameEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    data: 'data',
    processed: 'processed',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type GameEventScalarFieldEnum = (typeof GameEventScalarFieldEnum)[keyof typeof GameEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CultivationRealm'
   */
  export type EnumCultivationRealmFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CultivationRealm'>
    


  /**
   * Reference to a field of type 'CultivationRealm[]'
   */
  export type ListEnumCultivationRealmFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CultivationRealm[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ElementType'
   */
  export type EnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType'>
    


  /**
   * Reference to a field of type 'ElementType[]'
   */
  export type ListEnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType[]'>
    


  /**
   * Reference to a field of type 'SpiritualGrade'
   */
  export type EnumSpiritualGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpiritualGrade'>
    


  /**
   * Reference to a field of type 'SpiritualGrade[]'
   */
  export type ListEnumSpiritualGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpiritualGrade[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TechniqueType'
   */
  export type EnumTechniqueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechniqueType'>
    


  /**
   * Reference to a field of type 'TechniqueType[]'
   */
  export type ListEnumTechniqueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechniqueType[]'>
    


  /**
   * Reference to a field of type 'ItemRarity'
   */
  export type EnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity'>
    


  /**
   * Reference to a field of type 'ItemRarity[]'
   */
  export type ListEnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity[]'>
    


  /**
   * Reference to a field of type 'TalentType'
   */
  export type EnumTalentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TalentType'>
    


  /**
   * Reference to a field of type 'TalentType[]'
   */
  export type ListEnumTalentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TalentType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'CombatResult'
   */
  export type EnumCombatResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CombatResult'>
    


  /**
   * Reference to a field of type 'CombatResult[]'
   */
  export type ListEnumCombatResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CombatResult[]'>
    


  /**
   * Reference to a field of type 'SectRole'
   */
  export type EnumSectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SectRole'>
    


  /**
   * Reference to a field of type 'SectRole[]'
   */
  export type ListEnumSectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SectRole[]'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    


  /**
   * Reference to a field of type 'GameEventType'
   */
  export type EnumGameEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameEventType'>
    


  /**
   * Reference to a field of type 'GameEventType[]'
   */
  export type ListEnumGameEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameEventType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    biography?: StringNullableFilter<"User"> | string | null
    autoSave?: BoolFilter<"User"> | boolean
    notifications?: BoolFilter<"User"> | boolean
    soundEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    character?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    resources?: XOR<ResourcesNullableScalarRelationFilter, ResourcesWhereInput> | null
    inventory?: InventoryItemListRelationFilter
    cultivation?: XOR<CultivationProgressNullableScalarRelationFilter, CultivationProgressWhereInput> | null
    combat?: XOR<CombatStatsNullableScalarRelationFilter, CombatStatsWhereInput> | null
    sectMembership?: XOR<SectMemberNullableScalarRelationFilter, SectMemberWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    statistics?: XOR<GameStatisticsNullableScalarRelationFilter, GameStatisticsWhereInput> | null
    gameEvents?: GameEventListRelationFilter
    combatLogs?: CombatLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    autoSave?: SortOrder
    notifications?: SortOrder
    soundEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
    resources?: ResourcesOrderByWithRelationInput
    inventory?: InventoryItemOrderByRelationAggregateInput
    cultivation?: CultivationProgressOrderByWithRelationInput
    combat?: CombatStatsOrderByWithRelationInput
    sectMembership?: SectMemberOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    statistics?: GameStatisticsOrderByWithRelationInput
    gameEvents?: GameEventOrderByRelationAggregateInput
    combatLogs?: CombatLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    biography?: StringNullableFilter<"User"> | string | null
    autoSave?: BoolFilter<"User"> | boolean
    notifications?: BoolFilter<"User"> | boolean
    soundEnabled?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActiveAt?: DateTimeFilter<"User"> | Date | string
    character?: XOR<CharacterNullableScalarRelationFilter, CharacterWhereInput> | null
    resources?: XOR<ResourcesNullableScalarRelationFilter, ResourcesWhereInput> | null
    inventory?: InventoryItemListRelationFilter
    cultivation?: XOR<CultivationProgressNullableScalarRelationFilter, CultivationProgressWhereInput> | null
    combat?: XOR<CombatStatsNullableScalarRelationFilter, CombatStatsWhereInput> | null
    sectMembership?: XOR<SectMemberNullableScalarRelationFilter, SectMemberWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    statistics?: XOR<GameStatisticsNullableScalarRelationFilter, GameStatisticsWhereInput> | null
    gameEvents?: GameEventListRelationFilter
    combatLogs?: CombatLogListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    autoSave?: SortOrder
    notifications?: SortOrder
    soundEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    title?: StringNullableWithAggregatesFilter<"User"> | string | null
    biography?: StringNullableWithAggregatesFilter<"User"> | string | null
    autoSave?: BoolWithAggregatesFilter<"User"> | boolean
    notifications?: BoolWithAggregatesFilter<"User"> | boolean
    soundEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    userId?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    realm?: EnumCultivationRealmFilter<"Character"> | $Enums.CultivationRealm
    level?: IntFilter<"Character"> | number
    experience?: BigIntFilter<"Character"> | bigint | number
    experienceToNext?: BigIntFilter<"Character"> | bigint | number
    strength?: IntFilter<"Character"> | number
    agility?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    perception?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    spiritualElement?: EnumElementTypeFilter<"Character"> | $Enums.ElementType
    spiritualPurity?: IntFilter<"Character"> | number
    spiritualGrade?: EnumSpiritualGradeFilter<"Character"> | $Enums.SpiritualGrade
    bloodlineId?: StringNullableFilter<"Character"> | string | null
    bloodlineAwakening?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bloodline?: XOR<BloodlineNullableScalarRelationFilter, BloodlineWhereInput> | null
    techniques?: CharacterTechniqueListRelationFilter
    talents?: CharacterTalentListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualElement?: SortOrder
    spiritualPurity?: SortOrder
    spiritualGrade?: SortOrder
    bloodlineId?: SortOrderInput | SortOrder
    bloodlineAwakening?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bloodline?: BloodlineOrderByWithRelationInput
    techniques?: CharacterTechniqueOrderByRelationAggregateInput
    talents?: CharacterTalentOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    realm?: EnumCultivationRealmFilter<"Character"> | $Enums.CultivationRealm
    level?: IntFilter<"Character"> | number
    experience?: BigIntFilter<"Character"> | bigint | number
    experienceToNext?: BigIntFilter<"Character"> | bigint | number
    strength?: IntFilter<"Character"> | number
    agility?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    perception?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    spiritualElement?: EnumElementTypeFilter<"Character"> | $Enums.ElementType
    spiritualPurity?: IntFilter<"Character"> | number
    spiritualGrade?: EnumSpiritualGradeFilter<"Character"> | $Enums.SpiritualGrade
    bloodlineId?: StringNullableFilter<"Character"> | string | null
    bloodlineAwakening?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bloodline?: XOR<BloodlineNullableScalarRelationFilter, BloodlineWhereInput> | null
    techniques?: CharacterTechniqueListRelationFilter
    talents?: CharacterTalentListRelationFilter
  }, "id" | "userId">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualElement?: SortOrder
    spiritualPurity?: SortOrder
    spiritualGrade?: SortOrder
    bloodlineId?: SortOrderInput | SortOrder
    bloodlineAwakening?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    userId?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    realm?: EnumCultivationRealmWithAggregatesFilter<"Character"> | $Enums.CultivationRealm
    level?: IntWithAggregatesFilter<"Character"> | number
    experience?: BigIntWithAggregatesFilter<"Character"> | bigint | number
    experienceToNext?: BigIntWithAggregatesFilter<"Character"> | bigint | number
    strength?: IntWithAggregatesFilter<"Character"> | number
    agility?: IntWithAggregatesFilter<"Character"> | number
    intelligence?: IntWithAggregatesFilter<"Character"> | number
    constitution?: IntWithAggregatesFilter<"Character"> | number
    perception?: IntWithAggregatesFilter<"Character"> | number
    luck?: IntWithAggregatesFilter<"Character"> | number
    spiritualElement?: EnumElementTypeWithAggregatesFilter<"Character"> | $Enums.ElementType
    spiritualPurity?: IntWithAggregatesFilter<"Character"> | number
    spiritualGrade?: EnumSpiritualGradeWithAggregatesFilter<"Character"> | $Enums.SpiritualGrade
    bloodlineId?: StringNullableWithAggregatesFilter<"Character"> | string | null
    bloodlineAwakening?: IntWithAggregatesFilter<"Character"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type CultivationProgressWhereInput = {
    AND?: CultivationProgressWhereInput | CultivationProgressWhereInput[]
    OR?: CultivationProgressWhereInput[]
    NOT?: CultivationProgressWhereInput | CultivationProgressWhereInput[]
    id?: StringFilter<"CultivationProgress"> | string
    userId?: StringFilter<"CultivationProgress"> | string
    currentTechniqueId?: StringNullableFilter<"CultivationProgress"> | string | null
    qiAmount?: BigIntFilter<"CultivationProgress"> | bigint | number
    qiCapacity?: BigIntFilter<"CultivationProgress"> | bigint | number
    cultivationSpeed?: FloatFilter<"CultivationProgress"> | number
    bottleneckProgress?: FloatFilter<"CultivationProgress"> | number
    breakthroughAttempts?: IntFilter<"CultivationProgress"> | number
    stabilityPercentage?: FloatFilter<"CultivationProgress"> | number
    isSessionActive?: BoolFilter<"CultivationProgress"> | boolean
    sessionStartTime?: DateTimeNullableFilter<"CultivationProgress"> | Date | string | null
    sessionDuration?: IntFilter<"CultivationProgress"> | number
    sessionQiGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    sessionExpGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    lastCalculatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    createdAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentTechnique?: XOR<CultivationTechniqueNullableScalarRelationFilter, CultivationTechniqueWhereInput> | null
  }

  export type CultivationProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentTechniqueId?: SortOrderInput | SortOrder
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    isSessionActive?: SortOrder
    sessionStartTime?: SortOrderInput | SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    currentTechnique?: CultivationTechniqueOrderByWithRelationInput
  }

  export type CultivationProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CultivationProgressWhereInput | CultivationProgressWhereInput[]
    OR?: CultivationProgressWhereInput[]
    NOT?: CultivationProgressWhereInput | CultivationProgressWhereInput[]
    currentTechniqueId?: StringNullableFilter<"CultivationProgress"> | string | null
    qiAmount?: BigIntFilter<"CultivationProgress"> | bigint | number
    qiCapacity?: BigIntFilter<"CultivationProgress"> | bigint | number
    cultivationSpeed?: FloatFilter<"CultivationProgress"> | number
    bottleneckProgress?: FloatFilter<"CultivationProgress"> | number
    breakthroughAttempts?: IntFilter<"CultivationProgress"> | number
    stabilityPercentage?: FloatFilter<"CultivationProgress"> | number
    isSessionActive?: BoolFilter<"CultivationProgress"> | boolean
    sessionStartTime?: DateTimeNullableFilter<"CultivationProgress"> | Date | string | null
    sessionDuration?: IntFilter<"CultivationProgress"> | number
    sessionQiGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    sessionExpGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    lastCalculatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    createdAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentTechnique?: XOR<CultivationTechniqueNullableScalarRelationFilter, CultivationTechniqueWhereInput> | null
  }, "id" | "userId">

  export type CultivationProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentTechniqueId?: SortOrderInput | SortOrder
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    isSessionActive?: SortOrder
    sessionStartTime?: SortOrderInput | SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CultivationProgressCountOrderByAggregateInput
    _avg?: CultivationProgressAvgOrderByAggregateInput
    _max?: CultivationProgressMaxOrderByAggregateInput
    _min?: CultivationProgressMinOrderByAggregateInput
    _sum?: CultivationProgressSumOrderByAggregateInput
  }

  export type CultivationProgressScalarWhereWithAggregatesInput = {
    AND?: CultivationProgressScalarWhereWithAggregatesInput | CultivationProgressScalarWhereWithAggregatesInput[]
    OR?: CultivationProgressScalarWhereWithAggregatesInput[]
    NOT?: CultivationProgressScalarWhereWithAggregatesInput | CultivationProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CultivationProgress"> | string
    userId?: StringWithAggregatesFilter<"CultivationProgress"> | string
    currentTechniqueId?: StringNullableWithAggregatesFilter<"CultivationProgress"> | string | null
    qiAmount?: BigIntWithAggregatesFilter<"CultivationProgress"> | bigint | number
    qiCapacity?: BigIntWithAggregatesFilter<"CultivationProgress"> | bigint | number
    cultivationSpeed?: FloatWithAggregatesFilter<"CultivationProgress"> | number
    bottleneckProgress?: FloatWithAggregatesFilter<"CultivationProgress"> | number
    breakthroughAttempts?: IntWithAggregatesFilter<"CultivationProgress"> | number
    stabilityPercentage?: FloatWithAggregatesFilter<"CultivationProgress"> | number
    isSessionActive?: BoolWithAggregatesFilter<"CultivationProgress"> | boolean
    sessionStartTime?: DateTimeNullableWithAggregatesFilter<"CultivationProgress"> | Date | string | null
    sessionDuration?: IntWithAggregatesFilter<"CultivationProgress"> | number
    sessionQiGained?: BigIntWithAggregatesFilter<"CultivationProgress"> | bigint | number
    sessionExpGained?: BigIntWithAggregatesFilter<"CultivationProgress"> | bigint | number
    lastCalculatedAt?: DateTimeWithAggregatesFilter<"CultivationProgress"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CultivationProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CultivationProgress"> | Date | string
  }

  export type CultivationTechniqueWhereInput = {
    AND?: CultivationTechniqueWhereInput | CultivationTechniqueWhereInput[]
    OR?: CultivationTechniqueWhereInput[]
    NOT?: CultivationTechniqueWhereInput | CultivationTechniqueWhereInput[]
    id?: StringFilter<"CultivationTechnique"> | string
    name?: StringFilter<"CultivationTechnique"> | string
    description?: StringFilter<"CultivationTechnique"> | string
    type?: EnumTechniqueTypeFilter<"CultivationTechnique"> | $Enums.TechniqueType
    element?: EnumElementTypeFilter<"CultivationTechnique"> | $Enums.ElementType
    minRealm?: EnumCultivationRealmFilter<"CultivationTechnique"> | $Enums.CultivationRealm
    minLevel?: IntFilter<"CultivationTechnique"> | number
    baseSpeed?: FloatFilter<"CultivationTechnique"> | number
    qiEfficiency?: FloatFilter<"CultivationTechnique"> | number
    stabilityBonus?: FloatFilter<"CultivationTechnique"> | number
    rarity?: EnumItemRarityFilter<"CultivationTechnique"> | $Enums.ItemRarity
    isActive?: BoolFilter<"CultivationTechnique"> | boolean
    createdAt?: DateTimeFilter<"CultivationTechnique"> | Date | string
    updatedAt?: DateTimeFilter<"CultivationTechnique"> | Date | string
    userProgress?: CultivationProgressListRelationFilter
    characterTechniques?: CharacterTechniqueListRelationFilter
  }

  export type CultivationTechniqueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    element?: SortOrder
    minRealm?: SortOrder
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userProgress?: CultivationProgressOrderByRelationAggregateInput
    characterTechniques?: CharacterTechniqueOrderByRelationAggregateInput
  }

  export type CultivationTechniqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CultivationTechniqueWhereInput | CultivationTechniqueWhereInput[]
    OR?: CultivationTechniqueWhereInput[]
    NOT?: CultivationTechniqueWhereInput | CultivationTechniqueWhereInput[]
    description?: StringFilter<"CultivationTechnique"> | string
    type?: EnumTechniqueTypeFilter<"CultivationTechnique"> | $Enums.TechniqueType
    element?: EnumElementTypeFilter<"CultivationTechnique"> | $Enums.ElementType
    minRealm?: EnumCultivationRealmFilter<"CultivationTechnique"> | $Enums.CultivationRealm
    minLevel?: IntFilter<"CultivationTechnique"> | number
    baseSpeed?: FloatFilter<"CultivationTechnique"> | number
    qiEfficiency?: FloatFilter<"CultivationTechnique"> | number
    stabilityBonus?: FloatFilter<"CultivationTechnique"> | number
    rarity?: EnumItemRarityFilter<"CultivationTechnique"> | $Enums.ItemRarity
    isActive?: BoolFilter<"CultivationTechnique"> | boolean
    createdAt?: DateTimeFilter<"CultivationTechnique"> | Date | string
    updatedAt?: DateTimeFilter<"CultivationTechnique"> | Date | string
    userProgress?: CultivationProgressListRelationFilter
    characterTechniques?: CharacterTechniqueListRelationFilter
  }, "id" | "name">

  export type CultivationTechniqueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    element?: SortOrder
    minRealm?: SortOrder
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CultivationTechniqueCountOrderByAggregateInput
    _avg?: CultivationTechniqueAvgOrderByAggregateInput
    _max?: CultivationTechniqueMaxOrderByAggregateInput
    _min?: CultivationTechniqueMinOrderByAggregateInput
    _sum?: CultivationTechniqueSumOrderByAggregateInput
  }

  export type CultivationTechniqueScalarWhereWithAggregatesInput = {
    AND?: CultivationTechniqueScalarWhereWithAggregatesInput | CultivationTechniqueScalarWhereWithAggregatesInput[]
    OR?: CultivationTechniqueScalarWhereWithAggregatesInput[]
    NOT?: CultivationTechniqueScalarWhereWithAggregatesInput | CultivationTechniqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CultivationTechnique"> | string
    name?: StringWithAggregatesFilter<"CultivationTechnique"> | string
    description?: StringWithAggregatesFilter<"CultivationTechnique"> | string
    type?: EnumTechniqueTypeWithAggregatesFilter<"CultivationTechnique"> | $Enums.TechniqueType
    element?: EnumElementTypeWithAggregatesFilter<"CultivationTechnique"> | $Enums.ElementType
    minRealm?: EnumCultivationRealmWithAggregatesFilter<"CultivationTechnique"> | $Enums.CultivationRealm
    minLevel?: IntWithAggregatesFilter<"CultivationTechnique"> | number
    baseSpeed?: FloatWithAggregatesFilter<"CultivationTechnique"> | number
    qiEfficiency?: FloatWithAggregatesFilter<"CultivationTechnique"> | number
    stabilityBonus?: FloatWithAggregatesFilter<"CultivationTechnique"> | number
    rarity?: EnumItemRarityWithAggregatesFilter<"CultivationTechnique"> | $Enums.ItemRarity
    isActive?: BoolWithAggregatesFilter<"CultivationTechnique"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CultivationTechnique"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CultivationTechnique"> | Date | string
  }

  export type CharacterTechniqueWhereInput = {
    AND?: CharacterTechniqueWhereInput | CharacterTechniqueWhereInput[]
    OR?: CharacterTechniqueWhereInput[]
    NOT?: CharacterTechniqueWhereInput | CharacterTechniqueWhereInput[]
    id?: StringFilter<"CharacterTechnique"> | string
    characterId?: StringFilter<"CharacterTechnique"> | string
    techniqueId?: StringFilter<"CharacterTechnique"> | string
    proficiency?: FloatFilter<"CharacterTechnique"> | number
    level?: IntFilter<"CharacterTechnique"> | number
    experience?: BigIntFilter<"CharacterTechnique"> | bigint | number
    masteryBonus?: FloatFilter<"CharacterTechnique"> | number
    learnedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
    lastUsedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    technique?: XOR<CultivationTechniqueScalarRelationFilter, CultivationTechniqueWhereInput>
  }

  export type CharacterTechniqueOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    techniqueId?: SortOrder
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
    learnedAt?: SortOrder
    lastUsedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
    technique?: CultivationTechniqueOrderByWithRelationInput
  }

  export type CharacterTechniqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_techniqueId?: CharacterTechniqueCharacterIdTechniqueIdCompoundUniqueInput
    AND?: CharacterTechniqueWhereInput | CharacterTechniqueWhereInput[]
    OR?: CharacterTechniqueWhereInput[]
    NOT?: CharacterTechniqueWhereInput | CharacterTechniqueWhereInput[]
    characterId?: StringFilter<"CharacterTechnique"> | string
    techniqueId?: StringFilter<"CharacterTechnique"> | string
    proficiency?: FloatFilter<"CharacterTechnique"> | number
    level?: IntFilter<"CharacterTechnique"> | number
    experience?: BigIntFilter<"CharacterTechnique"> | bigint | number
    masteryBonus?: FloatFilter<"CharacterTechnique"> | number
    learnedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
    lastUsedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    technique?: XOR<CultivationTechniqueScalarRelationFilter, CultivationTechniqueWhereInput>
  }, "id" | "characterId_techniqueId">

  export type CharacterTechniqueOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    techniqueId?: SortOrder
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
    learnedAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: CharacterTechniqueCountOrderByAggregateInput
    _avg?: CharacterTechniqueAvgOrderByAggregateInput
    _max?: CharacterTechniqueMaxOrderByAggregateInput
    _min?: CharacterTechniqueMinOrderByAggregateInput
    _sum?: CharacterTechniqueSumOrderByAggregateInput
  }

  export type CharacterTechniqueScalarWhereWithAggregatesInput = {
    AND?: CharacterTechniqueScalarWhereWithAggregatesInput | CharacterTechniqueScalarWhereWithAggregatesInput[]
    OR?: CharacterTechniqueScalarWhereWithAggregatesInput[]
    NOT?: CharacterTechniqueScalarWhereWithAggregatesInput | CharacterTechniqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterTechnique"> | string
    characterId?: StringWithAggregatesFilter<"CharacterTechnique"> | string
    techniqueId?: StringWithAggregatesFilter<"CharacterTechnique"> | string
    proficiency?: FloatWithAggregatesFilter<"CharacterTechnique"> | number
    level?: IntWithAggregatesFilter<"CharacterTechnique"> | number
    experience?: BigIntWithAggregatesFilter<"CharacterTechnique"> | bigint | number
    masteryBonus?: FloatWithAggregatesFilter<"CharacterTechnique"> | number
    learnedAt?: DateTimeWithAggregatesFilter<"CharacterTechnique"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"CharacterTechnique"> | Date | string
  }

  export type TalentWhereInput = {
    AND?: TalentWhereInput | TalentWhereInput[]
    OR?: TalentWhereInput[]
    NOT?: TalentWhereInput | TalentWhereInput[]
    id?: StringFilter<"Talent"> | string
    name?: StringFilter<"Talent"> | string
    description?: StringFilter<"Talent"> | string
    type?: EnumTalentTypeFilter<"Talent"> | $Enums.TalentType
    effects?: JsonFilter<"Talent">
    requirements?: JsonFilter<"Talent">
    rarity?: EnumItemRarityFilter<"Talent"> | $Enums.ItemRarity
    isActive?: BoolFilter<"Talent"> | boolean
    createdAt?: DateTimeFilter<"Talent"> | Date | string
    updatedAt?: DateTimeFilter<"Talent"> | Date | string
    characterTalents?: CharacterTalentListRelationFilter
  }

  export type TalentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characterTalents?: CharacterTalentOrderByRelationAggregateInput
  }

  export type TalentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TalentWhereInput | TalentWhereInput[]
    OR?: TalentWhereInput[]
    NOT?: TalentWhereInput | TalentWhereInput[]
    description?: StringFilter<"Talent"> | string
    type?: EnumTalentTypeFilter<"Talent"> | $Enums.TalentType
    effects?: JsonFilter<"Talent">
    requirements?: JsonFilter<"Talent">
    rarity?: EnumItemRarityFilter<"Talent"> | $Enums.ItemRarity
    isActive?: BoolFilter<"Talent"> | boolean
    createdAt?: DateTimeFilter<"Talent"> | Date | string
    updatedAt?: DateTimeFilter<"Talent"> | Date | string
    characterTalents?: CharacterTalentListRelationFilter
  }, "id" | "name">

  export type TalentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TalentCountOrderByAggregateInput
    _max?: TalentMaxOrderByAggregateInput
    _min?: TalentMinOrderByAggregateInput
  }

  export type TalentScalarWhereWithAggregatesInput = {
    AND?: TalentScalarWhereWithAggregatesInput | TalentScalarWhereWithAggregatesInput[]
    OR?: TalentScalarWhereWithAggregatesInput[]
    NOT?: TalentScalarWhereWithAggregatesInput | TalentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Talent"> | string
    name?: StringWithAggregatesFilter<"Talent"> | string
    description?: StringWithAggregatesFilter<"Talent"> | string
    type?: EnumTalentTypeWithAggregatesFilter<"Talent"> | $Enums.TalentType
    effects?: JsonWithAggregatesFilter<"Talent">
    requirements?: JsonWithAggregatesFilter<"Talent">
    rarity?: EnumItemRarityWithAggregatesFilter<"Talent"> | $Enums.ItemRarity
    isActive?: BoolWithAggregatesFilter<"Talent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Talent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Talent"> | Date | string
  }

  export type CharacterTalentWhereInput = {
    AND?: CharacterTalentWhereInput | CharacterTalentWhereInput[]
    OR?: CharacterTalentWhereInput[]
    NOT?: CharacterTalentWhereInput | CharacterTalentWhereInput[]
    id?: StringFilter<"CharacterTalent"> | string
    characterId?: StringFilter<"CharacterTalent"> | string
    talentId?: StringFilter<"CharacterTalent"> | string
    isUnlocked?: BoolFilter<"CharacterTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"CharacterTalent"> | Date | string | null
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    talent?: XOR<TalentScalarRelationFilter, TalentWhereInput>
  }

  export type CharacterTalentOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    talentId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
    talent?: TalentOrderByWithRelationInput
  }

  export type CharacterTalentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_talentId?: CharacterTalentCharacterIdTalentIdCompoundUniqueInput
    AND?: CharacterTalentWhereInput | CharacterTalentWhereInput[]
    OR?: CharacterTalentWhereInput[]
    NOT?: CharacterTalentWhereInput | CharacterTalentWhereInput[]
    characterId?: StringFilter<"CharacterTalent"> | string
    talentId?: StringFilter<"CharacterTalent"> | string
    isUnlocked?: BoolFilter<"CharacterTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"CharacterTalent"> | Date | string | null
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    talent?: XOR<TalentScalarRelationFilter, TalentWhereInput>
  }, "id" | "characterId_talentId">

  export type CharacterTalentOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    talentId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    _count?: CharacterTalentCountOrderByAggregateInput
    _max?: CharacterTalentMaxOrderByAggregateInput
    _min?: CharacterTalentMinOrderByAggregateInput
  }

  export type CharacterTalentScalarWhereWithAggregatesInput = {
    AND?: CharacterTalentScalarWhereWithAggregatesInput | CharacterTalentScalarWhereWithAggregatesInput[]
    OR?: CharacterTalentScalarWhereWithAggregatesInput[]
    NOT?: CharacterTalentScalarWhereWithAggregatesInput | CharacterTalentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterTalent"> | string
    characterId?: StringWithAggregatesFilter<"CharacterTalent"> | string
    talentId?: StringWithAggregatesFilter<"CharacterTalent"> | string
    isUnlocked?: BoolWithAggregatesFilter<"CharacterTalent"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"CharacterTalent"> | Date | string | null
  }

  export type BloodlineWhereInput = {
    AND?: BloodlineWhereInput | BloodlineWhereInput[]
    OR?: BloodlineWhereInput[]
    NOT?: BloodlineWhereInput | BloodlineWhereInput[]
    id?: StringFilter<"Bloodline"> | string
    name?: StringFilter<"Bloodline"> | string
    description?: StringFilter<"Bloodline"> | string
    rarity?: EnumItemRarityFilter<"Bloodline"> | $Enums.ItemRarity
    abilities?: JsonFilter<"Bloodline">
    isActive?: BoolFilter<"Bloodline"> | boolean
    createdAt?: DateTimeFilter<"Bloodline"> | Date | string
    updatedAt?: DateTimeFilter<"Bloodline"> | Date | string
    characters?: CharacterListRelationFilter
  }

  export type BloodlineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rarity?: SortOrder
    abilities?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type BloodlineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BloodlineWhereInput | BloodlineWhereInput[]
    OR?: BloodlineWhereInput[]
    NOT?: BloodlineWhereInput | BloodlineWhereInput[]
    description?: StringFilter<"Bloodline"> | string
    rarity?: EnumItemRarityFilter<"Bloodline"> | $Enums.ItemRarity
    abilities?: JsonFilter<"Bloodline">
    isActive?: BoolFilter<"Bloodline"> | boolean
    createdAt?: DateTimeFilter<"Bloodline"> | Date | string
    updatedAt?: DateTimeFilter<"Bloodline"> | Date | string
    characters?: CharacterListRelationFilter
  }, "id" | "name">

  export type BloodlineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rarity?: SortOrder
    abilities?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BloodlineCountOrderByAggregateInput
    _max?: BloodlineMaxOrderByAggregateInput
    _min?: BloodlineMinOrderByAggregateInput
  }

  export type BloodlineScalarWhereWithAggregatesInput = {
    AND?: BloodlineScalarWhereWithAggregatesInput | BloodlineScalarWhereWithAggregatesInput[]
    OR?: BloodlineScalarWhereWithAggregatesInput[]
    NOT?: BloodlineScalarWhereWithAggregatesInput | BloodlineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bloodline"> | string
    name?: StringWithAggregatesFilter<"Bloodline"> | string
    description?: StringWithAggregatesFilter<"Bloodline"> | string
    rarity?: EnumItemRarityWithAggregatesFilter<"Bloodline"> | $Enums.ItemRarity
    abilities?: JsonWithAggregatesFilter<"Bloodline">
    isActive?: BoolWithAggregatesFilter<"Bloodline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bloodline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bloodline"> | Date | string
  }

  export type ResourcesWhereInput = {
    AND?: ResourcesWhereInput | ResourcesWhereInput[]
    OR?: ResourcesWhereInput[]
    NOT?: ResourcesWhereInput | ResourcesWhereInput[]
    id?: StringFilter<"Resources"> | string
    userId?: StringFilter<"Resources"> | string
    spiritStones?: BigIntFilter<"Resources"> | bigint | number
    gold?: BigIntFilter<"Resources"> | bigint | number
    materials?: JsonFilter<"Resources">
    pills?: JsonFilter<"Resources">
    herbs?: JsonFilter<"Resources">
    lastUpdated?: DateTimeFilter<"Resources"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResourcesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    spiritStones?: SortOrder
    gold?: SortOrder
    materials?: SortOrder
    pills?: SortOrder
    herbs?: SortOrder
    lastUpdated?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ResourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ResourcesWhereInput | ResourcesWhereInput[]
    OR?: ResourcesWhereInput[]
    NOT?: ResourcesWhereInput | ResourcesWhereInput[]
    spiritStones?: BigIntFilter<"Resources"> | bigint | number
    gold?: BigIntFilter<"Resources"> | bigint | number
    materials?: JsonFilter<"Resources">
    pills?: JsonFilter<"Resources">
    herbs?: JsonFilter<"Resources">
    lastUpdated?: DateTimeFilter<"Resources"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ResourcesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    spiritStones?: SortOrder
    gold?: SortOrder
    materials?: SortOrder
    pills?: SortOrder
    herbs?: SortOrder
    lastUpdated?: SortOrder
    _count?: ResourcesCountOrderByAggregateInput
    _avg?: ResourcesAvgOrderByAggregateInput
    _max?: ResourcesMaxOrderByAggregateInput
    _min?: ResourcesMinOrderByAggregateInput
    _sum?: ResourcesSumOrderByAggregateInput
  }

  export type ResourcesScalarWhereWithAggregatesInput = {
    AND?: ResourcesScalarWhereWithAggregatesInput | ResourcesScalarWhereWithAggregatesInput[]
    OR?: ResourcesScalarWhereWithAggregatesInput[]
    NOT?: ResourcesScalarWhereWithAggregatesInput | ResourcesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resources"> | string
    userId?: StringWithAggregatesFilter<"Resources"> | string
    spiritStones?: BigIntWithAggregatesFilter<"Resources"> | bigint | number
    gold?: BigIntWithAggregatesFilter<"Resources"> | bigint | number
    materials?: JsonWithAggregatesFilter<"Resources">
    pills?: JsonWithAggregatesFilter<"Resources">
    herbs?: JsonWithAggregatesFilter<"Resources">
    lastUpdated?: DateTimeWithAggregatesFilter<"Resources"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    value?: IntFilter<"Item"> | number
    stackable?: BoolFilter<"Item"> | boolean
    tradeable?: BoolFilter<"Item"> | boolean
    consumable?: BoolFilter<"Item"> | boolean
    effects?: JsonFilter<"Item">
    requirements?: JsonFilter<"Item">
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    tradeable?: SortOrder
    consumable?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    description?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    value?: IntFilter<"Item"> | number
    stackable?: BoolFilter<"Item"> | boolean
    tradeable?: BoolFilter<"Item"> | boolean
    consumable?: BoolFilter<"Item"> | boolean
    effects?: JsonFilter<"Item">
    requirements?: JsonFilter<"Item">
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
  }, "id" | "name">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    tradeable?: SortOrder
    consumable?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringWithAggregatesFilter<"Item"> | string
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityWithAggregatesFilter<"Item"> | $Enums.ItemRarity
    value?: IntWithAggregatesFilter<"Item"> | number
    stackable?: BoolWithAggregatesFilter<"Item"> | boolean
    tradeable?: BoolWithAggregatesFilter<"Item"> | boolean
    consumable?: BoolWithAggregatesFilter<"Item"> | boolean
    effects?: JsonWithAggregatesFilter<"Item">
    requirements?: JsonWithAggregatesFilter<"Item">
    isActive?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    userId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    metadata?: JsonFilter<"InventoryItem">
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
    acquiredAt?: SortOrder
    user?: UserOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_itemId?: InventoryItemUserIdItemIdCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    userId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    metadata?: JsonFilter<"InventoryItem">
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id" | "userId_itemId">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
    acquiredAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    userId?: StringWithAggregatesFilter<"InventoryItem"> | string
    itemId?: StringWithAggregatesFilter<"InventoryItem"> | string
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    metadata?: JsonWithAggregatesFilter<"InventoryItem">
    acquiredAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type CombatStatsWhereInput = {
    AND?: CombatStatsWhereInput | CombatStatsWhereInput[]
    OR?: CombatStatsWhereInput[]
    NOT?: CombatStatsWhereInput | CombatStatsWhereInput[]
    id?: StringFilter<"CombatStats"> | string
    userId?: StringFilter<"CombatStats"> | string
    level?: IntFilter<"CombatStats"> | number
    health?: IntFilter<"CombatStats"> | number
    maxHealth?: IntFilter<"CombatStats"> | number
    attack?: IntFilter<"CombatStats"> | number
    defense?: IntFilter<"CombatStats"> | number
    speed?: IntFilter<"CombatStats"> | number
    criticalChance?: FloatFilter<"CombatStats"> | number
    criticalDamage?: FloatFilter<"CombatStats"> | number
    combatExperience?: BigIntFilter<"CombatStats"> | bigint | number
    wins?: IntFilter<"CombatStats"> | number
    losses?: IntFilter<"CombatStats"> | number
    draws?: IntFilter<"CombatStats"> | number
    lastCombatAt?: DateTimeNullableFilter<"CombatStats"> | Date | string | null
    createdAt?: DateTimeFilter<"CombatStats"> | Date | string
    updatedAt?: DateTimeFilter<"CombatStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CombatStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
    lastCombatAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CombatStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CombatStatsWhereInput | CombatStatsWhereInput[]
    OR?: CombatStatsWhereInput[]
    NOT?: CombatStatsWhereInput | CombatStatsWhereInput[]
    level?: IntFilter<"CombatStats"> | number
    health?: IntFilter<"CombatStats"> | number
    maxHealth?: IntFilter<"CombatStats"> | number
    attack?: IntFilter<"CombatStats"> | number
    defense?: IntFilter<"CombatStats"> | number
    speed?: IntFilter<"CombatStats"> | number
    criticalChance?: FloatFilter<"CombatStats"> | number
    criticalDamage?: FloatFilter<"CombatStats"> | number
    combatExperience?: BigIntFilter<"CombatStats"> | bigint | number
    wins?: IntFilter<"CombatStats"> | number
    losses?: IntFilter<"CombatStats"> | number
    draws?: IntFilter<"CombatStats"> | number
    lastCombatAt?: DateTimeNullableFilter<"CombatStats"> | Date | string | null
    createdAt?: DateTimeFilter<"CombatStats"> | Date | string
    updatedAt?: DateTimeFilter<"CombatStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CombatStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
    lastCombatAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CombatStatsCountOrderByAggregateInput
    _avg?: CombatStatsAvgOrderByAggregateInput
    _max?: CombatStatsMaxOrderByAggregateInput
    _min?: CombatStatsMinOrderByAggregateInput
    _sum?: CombatStatsSumOrderByAggregateInput
  }

  export type CombatStatsScalarWhereWithAggregatesInput = {
    AND?: CombatStatsScalarWhereWithAggregatesInput | CombatStatsScalarWhereWithAggregatesInput[]
    OR?: CombatStatsScalarWhereWithAggregatesInput[]
    NOT?: CombatStatsScalarWhereWithAggregatesInput | CombatStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CombatStats"> | string
    userId?: StringWithAggregatesFilter<"CombatStats"> | string
    level?: IntWithAggregatesFilter<"CombatStats"> | number
    health?: IntWithAggregatesFilter<"CombatStats"> | number
    maxHealth?: IntWithAggregatesFilter<"CombatStats"> | number
    attack?: IntWithAggregatesFilter<"CombatStats"> | number
    defense?: IntWithAggregatesFilter<"CombatStats"> | number
    speed?: IntWithAggregatesFilter<"CombatStats"> | number
    criticalChance?: FloatWithAggregatesFilter<"CombatStats"> | number
    criticalDamage?: FloatWithAggregatesFilter<"CombatStats"> | number
    combatExperience?: BigIntWithAggregatesFilter<"CombatStats"> | bigint | number
    wins?: IntWithAggregatesFilter<"CombatStats"> | number
    losses?: IntWithAggregatesFilter<"CombatStats"> | number
    draws?: IntWithAggregatesFilter<"CombatStats"> | number
    lastCombatAt?: DateTimeNullableWithAggregatesFilter<"CombatStats"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CombatStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CombatStats"> | Date | string
  }

  export type CombatLogWhereInput = {
    AND?: CombatLogWhereInput | CombatLogWhereInput[]
    OR?: CombatLogWhereInput[]
    NOT?: CombatLogWhereInput | CombatLogWhereInput[]
    id?: StringFilter<"CombatLog"> | string
    userId?: StringFilter<"CombatLog"> | string
    opponentName?: StringFilter<"CombatLog"> | string
    result?: EnumCombatResultFilter<"CombatLog"> | $Enums.CombatResult
    duration?: IntFilter<"CombatLog"> | number
    damageDealt?: IntFilter<"CombatLog"> | number
    damageReceived?: IntFilter<"CombatLog"> | number
    experienceGained?: BigIntFilter<"CombatLog"> | bigint | number
    lootGained?: JsonFilter<"CombatLog">
    combatDetails?: JsonFilter<"CombatLog">
    foughtAt?: DateTimeFilter<"CombatLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CombatLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    opponentName?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
    lootGained?: SortOrder
    combatDetails?: SortOrder
    foughtAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CombatLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CombatLogWhereInput | CombatLogWhereInput[]
    OR?: CombatLogWhereInput[]
    NOT?: CombatLogWhereInput | CombatLogWhereInput[]
    userId?: StringFilter<"CombatLog"> | string
    opponentName?: StringFilter<"CombatLog"> | string
    result?: EnumCombatResultFilter<"CombatLog"> | $Enums.CombatResult
    duration?: IntFilter<"CombatLog"> | number
    damageDealt?: IntFilter<"CombatLog"> | number
    damageReceived?: IntFilter<"CombatLog"> | number
    experienceGained?: BigIntFilter<"CombatLog"> | bigint | number
    lootGained?: JsonFilter<"CombatLog">
    combatDetails?: JsonFilter<"CombatLog">
    foughtAt?: DateTimeFilter<"CombatLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CombatLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    opponentName?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
    lootGained?: SortOrder
    combatDetails?: SortOrder
    foughtAt?: SortOrder
    _count?: CombatLogCountOrderByAggregateInput
    _avg?: CombatLogAvgOrderByAggregateInput
    _max?: CombatLogMaxOrderByAggregateInput
    _min?: CombatLogMinOrderByAggregateInput
    _sum?: CombatLogSumOrderByAggregateInput
  }

  export type CombatLogScalarWhereWithAggregatesInput = {
    AND?: CombatLogScalarWhereWithAggregatesInput | CombatLogScalarWhereWithAggregatesInput[]
    OR?: CombatLogScalarWhereWithAggregatesInput[]
    NOT?: CombatLogScalarWhereWithAggregatesInput | CombatLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CombatLog"> | string
    userId?: StringWithAggregatesFilter<"CombatLog"> | string
    opponentName?: StringWithAggregatesFilter<"CombatLog"> | string
    result?: EnumCombatResultWithAggregatesFilter<"CombatLog"> | $Enums.CombatResult
    duration?: IntWithAggregatesFilter<"CombatLog"> | number
    damageDealt?: IntWithAggregatesFilter<"CombatLog"> | number
    damageReceived?: IntWithAggregatesFilter<"CombatLog"> | number
    experienceGained?: BigIntWithAggregatesFilter<"CombatLog"> | bigint | number
    lootGained?: JsonWithAggregatesFilter<"CombatLog">
    combatDetails?: JsonWithAggregatesFilter<"CombatLog">
    foughtAt?: DateTimeWithAggregatesFilter<"CombatLog"> | Date | string
  }

  export type SectWhereInput = {
    AND?: SectWhereInput | SectWhereInput[]
    OR?: SectWhereInput[]
    NOT?: SectWhereInput | SectWhereInput[]
    id?: StringFilter<"Sect"> | string
    name?: StringFilter<"Sect"> | string
    description?: StringFilter<"Sect"> | string
    level?: IntFilter<"Sect"> | number
    experience?: BigIntFilter<"Sect"> | bigint | number
    leaderId?: StringFilter<"Sect"> | string
    spiritStones?: BigIntFilter<"Sect"> | bigint | number
    reputation?: IntFilter<"Sect"> | number
    influence?: IntFilter<"Sect"> | number
    territory?: IntFilter<"Sect"> | number
    buildings?: JsonFilter<"Sect">
    alliances?: JsonFilter<"Sect">
    enemies?: JsonFilter<"Sect">
    createdAt?: DateTimeFilter<"Sect"> | Date | string
    updatedAt?: DateTimeFilter<"Sect"> | Date | string
    members?: SectMemberListRelationFilter
  }

  export type SectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    leaderId?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
    buildings?: SortOrder
    alliances?: SortOrder
    enemies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: SectMemberOrderByRelationAggregateInput
  }

  export type SectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SectWhereInput | SectWhereInput[]
    OR?: SectWhereInput[]
    NOT?: SectWhereInput | SectWhereInput[]
    description?: StringFilter<"Sect"> | string
    level?: IntFilter<"Sect"> | number
    experience?: BigIntFilter<"Sect"> | bigint | number
    leaderId?: StringFilter<"Sect"> | string
    spiritStones?: BigIntFilter<"Sect"> | bigint | number
    reputation?: IntFilter<"Sect"> | number
    influence?: IntFilter<"Sect"> | number
    territory?: IntFilter<"Sect"> | number
    buildings?: JsonFilter<"Sect">
    alliances?: JsonFilter<"Sect">
    enemies?: JsonFilter<"Sect">
    createdAt?: DateTimeFilter<"Sect"> | Date | string
    updatedAt?: DateTimeFilter<"Sect"> | Date | string
    members?: SectMemberListRelationFilter
  }, "id" | "name">

  export type SectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    leaderId?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
    buildings?: SortOrder
    alliances?: SortOrder
    enemies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectCountOrderByAggregateInput
    _avg?: SectAvgOrderByAggregateInput
    _max?: SectMaxOrderByAggregateInput
    _min?: SectMinOrderByAggregateInput
    _sum?: SectSumOrderByAggregateInput
  }

  export type SectScalarWhereWithAggregatesInput = {
    AND?: SectScalarWhereWithAggregatesInput | SectScalarWhereWithAggregatesInput[]
    OR?: SectScalarWhereWithAggregatesInput[]
    NOT?: SectScalarWhereWithAggregatesInput | SectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sect"> | string
    name?: StringWithAggregatesFilter<"Sect"> | string
    description?: StringWithAggregatesFilter<"Sect"> | string
    level?: IntWithAggregatesFilter<"Sect"> | number
    experience?: BigIntWithAggregatesFilter<"Sect"> | bigint | number
    leaderId?: StringWithAggregatesFilter<"Sect"> | string
    spiritStones?: BigIntWithAggregatesFilter<"Sect"> | bigint | number
    reputation?: IntWithAggregatesFilter<"Sect"> | number
    influence?: IntWithAggregatesFilter<"Sect"> | number
    territory?: IntWithAggregatesFilter<"Sect"> | number
    buildings?: JsonWithAggregatesFilter<"Sect">
    alliances?: JsonWithAggregatesFilter<"Sect">
    enemies?: JsonWithAggregatesFilter<"Sect">
    createdAt?: DateTimeWithAggregatesFilter<"Sect"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sect"> | Date | string
  }

  export type SectMemberWhereInput = {
    AND?: SectMemberWhereInput | SectMemberWhereInput[]
    OR?: SectMemberWhereInput[]
    NOT?: SectMemberWhereInput | SectMemberWhereInput[]
    id?: StringFilter<"SectMember"> | string
    userId?: StringFilter<"SectMember"> | string
    sectId?: StringFilter<"SectMember"> | string
    role?: EnumSectRoleFilter<"SectMember"> | $Enums.SectRole
    contribution?: BigIntFilter<"SectMember"> | bigint | number
    permissions?: JsonFilter<"SectMember">
    joinedAt?: DateTimeFilter<"SectMember"> | Date | string
    lastActiveAt?: DateTimeFilter<"SectMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sect?: XOR<SectScalarRelationFilter, SectWhereInput>
  }

  export type SectMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sectId?: SortOrder
    role?: SortOrder
    contribution?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    user?: UserOrderByWithRelationInput
    sect?: SectOrderByWithRelationInput
  }

  export type SectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SectMemberWhereInput | SectMemberWhereInput[]
    OR?: SectMemberWhereInput[]
    NOT?: SectMemberWhereInput | SectMemberWhereInput[]
    sectId?: StringFilter<"SectMember"> | string
    role?: EnumSectRoleFilter<"SectMember"> | $Enums.SectRole
    contribution?: BigIntFilter<"SectMember"> | bigint | number
    permissions?: JsonFilter<"SectMember">
    joinedAt?: DateTimeFilter<"SectMember"> | Date | string
    lastActiveAt?: DateTimeFilter<"SectMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sect?: XOR<SectScalarRelationFilter, SectWhereInput>
  }, "id" | "userId">

  export type SectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sectId?: SortOrder
    role?: SortOrder
    contribution?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
    _count?: SectMemberCountOrderByAggregateInput
    _avg?: SectMemberAvgOrderByAggregateInput
    _max?: SectMemberMaxOrderByAggregateInput
    _min?: SectMemberMinOrderByAggregateInput
    _sum?: SectMemberSumOrderByAggregateInput
  }

  export type SectMemberScalarWhereWithAggregatesInput = {
    AND?: SectMemberScalarWhereWithAggregatesInput | SectMemberScalarWhereWithAggregatesInput[]
    OR?: SectMemberScalarWhereWithAggregatesInput[]
    NOT?: SectMemberScalarWhereWithAggregatesInput | SectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectMember"> | string
    userId?: StringWithAggregatesFilter<"SectMember"> | string
    sectId?: StringWithAggregatesFilter<"SectMember"> | string
    role?: EnumSectRoleWithAggregatesFilter<"SectMember"> | $Enums.SectRole
    contribution?: BigIntWithAggregatesFilter<"SectMember"> | bigint | number
    permissions?: JsonWithAggregatesFilter<"SectMember">
    joinedAt?: DateTimeWithAggregatesFilter<"SectMember"> | Date | string
    lastActiveAt?: DateTimeWithAggregatesFilter<"SectMember"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    maxProgress?: IntFilter<"Achievement"> | number
    rewards?: JsonFilter<"Achievement">
    isHidden?: BoolFilter<"Achievement"> | boolean
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    maxProgress?: SortOrder
    rewards?: SortOrder
    isHidden?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    description?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    maxProgress?: IntFilter<"Achievement"> | number
    rewards?: JsonFilter<"Achievement">
    isHidden?: BoolFilter<"Achievement"> | boolean
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }, "id" | "name">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    maxProgress?: SortOrder
    rewards?: SortOrder
    isHidden?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
    maxProgress?: IntWithAggregatesFilter<"Achievement"> | number
    rewards?: JsonWithAggregatesFilter<"Achievement">
    isHidden?: BoolWithAggregatesFilter<"Achievement"> | boolean
    isActive?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    isCompleted?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    isCompleted?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    progress?: IntWithAggregatesFilter<"UserAchievement"> | number
    isCompleted?: BoolWithAggregatesFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserAchievement"> | Date | string | null
  }

  export type GameStatisticsWhereInput = {
    AND?: GameStatisticsWhereInput | GameStatisticsWhereInput[]
    OR?: GameStatisticsWhereInput[]
    NOT?: GameStatisticsWhereInput | GameStatisticsWhereInput[]
    id?: StringFilter<"GameStatistics"> | string
    userId?: StringFilter<"GameStatistics"> | string
    totalPlayTime?: BigIntFilter<"GameStatistics"> | bigint | number
    cultivationTime?: BigIntFilter<"GameStatistics"> | bigint | number
    combatWins?: IntFilter<"GameStatistics"> | number
    combatLosses?: IntFilter<"GameStatistics"> | number
    itemsCrafted?: IntFilter<"GameStatistics"> | number
    achievementsUnlocked?: IntFilter<"GameStatistics"> | number
    realmBreakthroughs?: IntFilter<"GameStatistics"> | number
    sectContribution?: BigIntFilter<"GameStatistics"> | bigint | number
    resourcesEarned?: JsonFilter<"GameStatistics">
    lastUpdated?: DateTimeFilter<"GameStatistics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
    resourcesEarned?: SortOrder
    lastUpdated?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GameStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GameStatisticsWhereInput | GameStatisticsWhereInput[]
    OR?: GameStatisticsWhereInput[]
    NOT?: GameStatisticsWhereInput | GameStatisticsWhereInput[]
    totalPlayTime?: BigIntFilter<"GameStatistics"> | bigint | number
    cultivationTime?: BigIntFilter<"GameStatistics"> | bigint | number
    combatWins?: IntFilter<"GameStatistics"> | number
    combatLosses?: IntFilter<"GameStatistics"> | number
    itemsCrafted?: IntFilter<"GameStatistics"> | number
    achievementsUnlocked?: IntFilter<"GameStatistics"> | number
    realmBreakthroughs?: IntFilter<"GameStatistics"> | number
    sectContribution?: BigIntFilter<"GameStatistics"> | bigint | number
    resourcesEarned?: JsonFilter<"GameStatistics">
    lastUpdated?: DateTimeFilter<"GameStatistics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type GameStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
    resourcesEarned?: SortOrder
    lastUpdated?: SortOrder
    _count?: GameStatisticsCountOrderByAggregateInput
    _avg?: GameStatisticsAvgOrderByAggregateInput
    _max?: GameStatisticsMaxOrderByAggregateInput
    _min?: GameStatisticsMinOrderByAggregateInput
    _sum?: GameStatisticsSumOrderByAggregateInput
  }

  export type GameStatisticsScalarWhereWithAggregatesInput = {
    AND?: GameStatisticsScalarWhereWithAggregatesInput | GameStatisticsScalarWhereWithAggregatesInput[]
    OR?: GameStatisticsScalarWhereWithAggregatesInput[]
    NOT?: GameStatisticsScalarWhereWithAggregatesInput | GameStatisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameStatistics"> | string
    userId?: StringWithAggregatesFilter<"GameStatistics"> | string
    totalPlayTime?: BigIntWithAggregatesFilter<"GameStatistics"> | bigint | number
    cultivationTime?: BigIntWithAggregatesFilter<"GameStatistics"> | bigint | number
    combatWins?: IntWithAggregatesFilter<"GameStatistics"> | number
    combatLosses?: IntWithAggregatesFilter<"GameStatistics"> | number
    itemsCrafted?: IntWithAggregatesFilter<"GameStatistics"> | number
    achievementsUnlocked?: IntWithAggregatesFilter<"GameStatistics"> | number
    realmBreakthroughs?: IntWithAggregatesFilter<"GameStatistics"> | number
    sectContribution?: BigIntWithAggregatesFilter<"GameStatistics"> | bigint | number
    resourcesEarned?: JsonWithAggregatesFilter<"GameStatistics">
    lastUpdated?: DateTimeWithAggregatesFilter<"GameStatistics"> | Date | string
  }

  export type GameEventWhereInput = {
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    userId?: StringFilter<"GameEvent"> | string
    type?: EnumGameEventTypeFilter<"GameEvent"> | $Enums.GameEventType
    data?: JsonFilter<"GameEvent">
    processed?: BoolFilter<"GameEvent"> | boolean
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GameEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    userId?: StringFilter<"GameEvent"> | string
    type?: EnumGameEventTypeFilter<"GameEvent"> | $Enums.GameEventType
    data?: JsonFilter<"GameEvent">
    processed?: BoolFilter<"GameEvent"> | boolean
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GameEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: GameEventCountOrderByAggregateInput
    _max?: GameEventMaxOrderByAggregateInput
    _min?: GameEventMinOrderByAggregateInput
  }

  export type GameEventScalarWhereWithAggregatesInput = {
    AND?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    OR?: GameEventScalarWhereWithAggregatesInput[]
    NOT?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameEvent"> | string
    userId?: StringWithAggregatesFilter<"GameEvent"> | string
    type?: EnumGameEventTypeWithAggregatesFilter<"GameEvent"> | $Enums.GameEventType
    data?: JsonWithAggregatesFilter<"GameEvent">
    processed?: BoolWithAggregatesFilter<"GameEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GameEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"GameEvent"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharacterInput
    bloodline?: BloodlineCreateNestedOneWithoutCharactersInput
    techniques?: CharacterTechniqueCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineId?: string | null
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    techniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharacterNestedInput
    bloodline?: BloodlineUpdateOneWithoutCharactersNestedInput
    techniques?: CharacterTechniqueUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineId?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniques?: CharacterTechniqueUncheckedUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineId?: string | null
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineId?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationProgressCreateInput = {
    id?: string
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCultivationInput
    currentTechnique?: CultivationTechniqueCreateNestedOneWithoutUserProgressInput
  }

  export type CultivationProgressUncheckedCreateInput = {
    id?: string
    userId: string
    currentTechniqueId?: string | null
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultivationProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCultivationNestedInput
    currentTechnique?: CultivationTechniqueUpdateOneWithoutUserProgressNestedInput
  }

  export type CultivationProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentTechniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationProgressCreateManyInput = {
    id?: string
    userId: string
    currentTechniqueId?: string | null
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultivationProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentTechniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationTechniqueCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: CultivationProgressCreateNestedManyWithoutCurrentTechniqueInput
    characterTechniques?: CharacterTechniqueCreateNestedManyWithoutTechniqueInput
  }

  export type CultivationTechniqueUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: CultivationProgressUncheckedCreateNestedManyWithoutCurrentTechniqueInput
    characterTechniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutTechniqueInput
  }

  export type CultivationTechniqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: CultivationProgressUpdateManyWithoutCurrentTechniqueNestedInput
    characterTechniques?: CharacterTechniqueUpdateManyWithoutTechniqueNestedInput
  }

  export type CultivationTechniqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: CultivationProgressUncheckedUpdateManyWithoutCurrentTechniqueNestedInput
    characterTechniques?: CharacterTechniqueUncheckedUpdateManyWithoutTechniqueNestedInput
  }

  export type CultivationTechniqueCreateManyInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultivationTechniqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationTechniqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueCreateInput = {
    id?: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
    character: CharacterCreateNestedOneWithoutTechniquesInput
    technique: CultivationTechniqueCreateNestedOneWithoutCharacterTechniquesInput
  }

  export type CharacterTechniqueUncheckedCreateInput = {
    id?: string
    characterId: string
    techniqueId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CharacterTechniqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutTechniquesNestedInput
    technique?: CultivationTechniqueUpdateOneRequiredWithoutCharacterTechniquesNestedInput
  }

  export type CharacterTechniqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueCreateManyInput = {
    id?: string
    characterId: string
    techniqueId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CharacterTechniqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characterTalents?: CharacterTalentCreateNestedManyWithoutTalentInput
  }

  export type TalentUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characterTalents?: CharacterTalentUncheckedCreateNestedManyWithoutTalentInput
  }

  export type TalentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterTalents?: CharacterTalentUpdateManyWithoutTalentNestedInput
  }

  export type TalentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterTalents?: CharacterTalentUncheckedUpdateManyWithoutTalentNestedInput
  }

  export type TalentCreateManyInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTalentCreateInput = {
    id?: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    character: CharacterCreateNestedOneWithoutTalentsInput
    talent: TalentCreateNestedOneWithoutCharacterTalentsInput
  }

  export type CharacterTalentUncheckedCreateInput = {
    id?: string
    characterId: string
    talentId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTalentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutTalentsNestedInput
    talent?: TalentUpdateOneRequiredWithoutCharacterTalentsNestedInput
  }

  export type CharacterTalentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterTalentCreateManyInput = {
    id?: string
    characterId: string
    talentId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTalentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterTalentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BloodlineCreateInput = {
    id?: string
    name: string
    description: string
    rarity?: $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutBloodlineInput
  }

  export type BloodlineUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    rarity?: $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutBloodlineInput
  }

  export type BloodlineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutBloodlineNestedInput
  }

  export type BloodlineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutBloodlineNestedInput
  }

  export type BloodlineCreateManyInput = {
    id?: string
    name: string
    description: string
    rarity?: $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BloodlineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BloodlineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourcesCreateInput = {
    id?: string
    spiritStones?: bigint | number
    gold?: bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
    user: UserCreateNestedOneWithoutResourcesInput
  }

  export type ResourcesUncheckedCreateInput = {
    id?: string
    userId: string
    spiritStones?: bigint | number
    gold?: bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type ResourcesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type ResourcesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourcesCreateManyInput = {
    id?: string
    userId: string
    spiritStones?: bigint | number
    gold?: bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type ResourcesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourcesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.ItemType
    rarity?: $Enums.ItemRarity
    value?: number
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.ItemType
    rarity?: $Enums.ItemRarity
    value?: number
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.ItemType
    rarity?: $Enums.ItemRarity
    value?: number
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    user: UserCreateNestedOneWithoutInventoryInput
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    userId: string
    itemId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    userId: string
    itemId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatStatsCreateInput = {
    id?: string
    level?: number
    health?: number
    maxHealth?: number
    attack?: number
    defense?: number
    speed?: number
    criticalChance?: number
    criticalDamage?: number
    combatExperience?: bigint | number
    wins?: number
    losses?: number
    draws?: number
    lastCombatAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCombatInput
  }

  export type CombatStatsUncheckedCreateInput = {
    id?: string
    userId: string
    level?: number
    health?: number
    maxHealth?: number
    attack?: number
    defense?: number
    speed?: number
    criticalChance?: number
    criticalDamage?: number
    combatExperience?: bigint | number
    wins?: number
    losses?: number
    draws?: number
    lastCombatAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCombatNestedInput
  }

  export type CombatStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatStatsCreateManyInput = {
    id?: string
    userId: string
    level?: number
    health?: number
    maxHealth?: number
    attack?: number
    defense?: number
    speed?: number
    criticalChance?: number
    criticalDamage?: number
    combatExperience?: bigint | number
    wins?: number
    losses?: number
    draws?: number
    lastCombatAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogCreateInput = {
    id?: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
    user: UserCreateNestedOneWithoutCombatLogsInput
  }

  export type CombatLogUncheckedCreateInput = {
    id?: string
    userId: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
  }

  export type CombatLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCombatLogsNestedInput
  }

  export type CombatLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogCreateManyInput = {
    id?: string
    userId: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
  }

  export type CombatLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectCreateInput = {
    id?: string
    name: string
    description: string
    level?: number
    experience?: bigint | number
    leaderId: string
    spiritStones?: bigint | number
    reputation?: number
    influence?: number
    territory?: number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SectMemberCreateNestedManyWithoutSectInput
  }

  export type SectUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    level?: number
    experience?: bigint | number
    leaderId: string
    spiritStones?: bigint | number
    reputation?: number
    influence?: number
    territory?: number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SectMemberUncheckedCreateNestedManyWithoutSectInput
  }

  export type SectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SectMemberUpdateManyWithoutSectNestedInput
  }

  export type SectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SectMemberUncheckedUpdateManyWithoutSectNestedInput
  }

  export type SectCreateManyInput = {
    id?: string
    name: string
    description: string
    level?: number
    experience?: bigint | number
    leaderId: string
    spiritStones?: bigint | number
    reputation?: number
    influence?: number
    territory?: number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberCreateInput = {
    id?: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    user: UserCreateNestedOneWithoutSectMembershipInput
    sect: SectCreateNestedOneWithoutMembersInput
  }

  export type SectMemberUncheckedCreateInput = {
    id?: string
    userId: string
    sectId: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type SectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSectMembershipNestedInput
    sect?: SectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectId?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberCreateManyInput = {
    id?: string
    userId: string
    sectId: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type SectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectId?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    category?: $Enums.AchievementCategory
    maxProgress?: number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category?: $Enums.AchievementCategory
    maxProgress?: number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    category?: $Enums.AchievementCategory
    maxProgress?: number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameStatisticsCreateInput = {
    id?: string
    totalPlayTime?: bigint | number
    cultivationTime?: bigint | number
    combatWins?: number
    combatLosses?: number
    itemsCrafted?: number
    achievementsUnlocked?: number
    realmBreakthroughs?: number
    sectContribution?: bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
    user: UserCreateNestedOneWithoutStatisticsInput
  }

  export type GameStatisticsUncheckedCreateInput = {
    id?: string
    userId: string
    totalPlayTime?: bigint | number
    cultivationTime?: bigint | number
    combatWins?: number
    combatLosses?: number
    itemsCrafted?: number
    achievementsUnlocked?: number
    realmBreakthroughs?: number
    sectContribution?: bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type GameStatisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type GameStatisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatisticsCreateManyInput = {
    id?: string
    userId: string
    totalPlayTime?: bigint | number
    cultivationTime?: bigint | number
    combatWins?: number
    combatLosses?: number
    itemsCrafted?: number
    achievementsUnlocked?: number
    realmBreakthroughs?: number
    sectContribution?: bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type GameStatisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventCreateInput = {
    id?: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutGameEventsInput
  }

  export type GameEventUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type GameEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutGameEventsNestedInput
  }

  export type GameEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type GameEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CharacterNullableScalarRelationFilter = {
    is?: CharacterWhereInput | null
    isNot?: CharacterWhereInput | null
  }

  export type ResourcesNullableScalarRelationFilter = {
    is?: ResourcesWhereInput | null
    isNot?: ResourcesWhereInput | null
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type CultivationProgressNullableScalarRelationFilter = {
    is?: CultivationProgressWhereInput | null
    isNot?: CultivationProgressWhereInput | null
  }

  export type CombatStatsNullableScalarRelationFilter = {
    is?: CombatStatsWhereInput | null
    isNot?: CombatStatsWhereInput | null
  }

  export type SectMemberNullableScalarRelationFilter = {
    is?: SectMemberWhereInput | null
    isNot?: SectMemberWhereInput | null
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type GameStatisticsNullableScalarRelationFilter = {
    is?: GameStatisticsWhereInput | null
    isNot?: GameStatisticsWhereInput | null
  }

  export type GameEventListRelationFilter = {
    every?: GameEventWhereInput
    some?: GameEventWhereInput
    none?: GameEventWhereInput
  }

  export type CombatLogListRelationFilter = {
    every?: CombatLogWhereInput
    some?: CombatLogWhereInput
    none?: CombatLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CombatLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    title?: SortOrder
    biography?: SortOrder
    autoSave?: SortOrder
    notifications?: SortOrder
    soundEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    title?: SortOrder
    biography?: SortOrder
    autoSave?: SortOrder
    notifications?: SortOrder
    soundEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    title?: SortOrder
    biography?: SortOrder
    autoSave?: SortOrder
    notifications?: SortOrder
    soundEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumCultivationRealmFilter<$PrismaModel = never> = {
    equals?: $Enums.CultivationRealm | EnumCultivationRealmFieldRefInput<$PrismaModel>
    in?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    notIn?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    not?: NestedEnumCultivationRealmFilter<$PrismaModel> | $Enums.CultivationRealm
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type EnumSpiritualGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpiritualGrade | EnumSpiritualGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpiritualGradeFilter<$PrismaModel> | $Enums.SpiritualGrade
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BloodlineNullableScalarRelationFilter = {
    is?: BloodlineWhereInput | null
    isNot?: BloodlineWhereInput | null
  }

  export type CharacterTechniqueListRelationFilter = {
    every?: CharacterTechniqueWhereInput
    some?: CharacterTechniqueWhereInput
    none?: CharacterTechniqueWhereInput
  }

  export type CharacterTalentListRelationFilter = {
    every?: CharacterTalentWhereInput
    some?: CharacterTalentWhereInput
    none?: CharacterTalentWhereInput
  }

  export type CharacterTechniqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterTalentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualElement?: SortOrder
    spiritualPurity?: SortOrder
    spiritualGrade?: SortOrder
    bloodlineId?: SortOrder
    bloodlineAwakening?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualPurity?: SortOrder
    bloodlineAwakening?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualElement?: SortOrder
    spiritualPurity?: SortOrder
    spiritualGrade?: SortOrder
    bloodlineId?: SortOrder
    bloodlineAwakening?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    realm?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualElement?: SortOrder
    spiritualPurity?: SortOrder
    spiritualGrade?: SortOrder
    bloodlineId?: SortOrder
    bloodlineAwakening?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    experienceToNext?: SortOrder
    strength?: SortOrder
    agility?: SortOrder
    intelligence?: SortOrder
    constitution?: SortOrder
    perception?: SortOrder
    luck?: SortOrder
    spiritualPurity?: SortOrder
    bloodlineAwakening?: SortOrder
  }

  export type EnumCultivationRealmWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CultivationRealm | EnumCultivationRealmFieldRefInput<$PrismaModel>
    in?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    notIn?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    not?: NestedEnumCultivationRealmWithAggregatesFilter<$PrismaModel> | $Enums.CultivationRealm
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCultivationRealmFilter<$PrismaModel>
    _max?: NestedEnumCultivationRealmFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type EnumSpiritualGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpiritualGrade | EnumSpiritualGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpiritualGradeWithAggregatesFilter<$PrismaModel> | $Enums.SpiritualGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpiritualGradeFilter<$PrismaModel>
    _max?: NestedEnumSpiritualGradeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CultivationTechniqueNullableScalarRelationFilter = {
    is?: CultivationTechniqueWhereInput | null
    isNot?: CultivationTechniqueWhereInput | null
  }

  export type CultivationProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentTechniqueId?: SortOrder
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    isSessionActive?: SortOrder
    sessionStartTime?: SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationProgressAvgOrderByAggregateInput = {
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
  }

  export type CultivationProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentTechniqueId?: SortOrder
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    isSessionActive?: SortOrder
    sessionStartTime?: SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentTechniqueId?: SortOrder
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    isSessionActive?: SortOrder
    sessionStartTime?: SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationProgressSumOrderByAggregateInput = {
    qiAmount?: SortOrder
    qiCapacity?: SortOrder
    cultivationSpeed?: SortOrder
    bottleneckProgress?: SortOrder
    breakthroughAttempts?: SortOrder
    stabilityPercentage?: SortOrder
    sessionDuration?: SortOrder
    sessionQiGained?: SortOrder
    sessionExpGained?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTechniqueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TechniqueType | EnumTechniqueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechniqueTypeFilter<$PrismaModel> | $Enums.TechniqueType
  }

  export type EnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type CultivationProgressListRelationFilter = {
    every?: CultivationProgressWhereInput
    some?: CultivationProgressWhereInput
    none?: CultivationProgressWhereInput
  }

  export type CultivationProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CultivationTechniqueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    element?: SortOrder
    minRealm?: SortOrder
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationTechniqueAvgOrderByAggregateInput = {
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
  }

  export type CultivationTechniqueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    element?: SortOrder
    minRealm?: SortOrder
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationTechniqueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    element?: SortOrder
    minRealm?: SortOrder
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultivationTechniqueSumOrderByAggregateInput = {
    minLevel?: SortOrder
    baseSpeed?: SortOrder
    qiEfficiency?: SortOrder
    stabilityBonus?: SortOrder
  }

  export type EnumTechniqueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechniqueType | EnumTechniqueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechniqueTypeWithAggregatesFilter<$PrismaModel> | $Enums.TechniqueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechniqueTypeFilter<$PrismaModel>
    _max?: NestedEnumTechniqueTypeFilter<$PrismaModel>
  }

  export type EnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type CharacterScalarRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CultivationTechniqueScalarRelationFilter = {
    is?: CultivationTechniqueWhereInput
    isNot?: CultivationTechniqueWhereInput
  }

  export type CharacterTechniqueCharacterIdTechniqueIdCompoundUniqueInput = {
    characterId: string
    techniqueId: string
  }

  export type CharacterTechniqueCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    techniqueId?: SortOrder
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
    learnedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type CharacterTechniqueAvgOrderByAggregateInput = {
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
  }

  export type CharacterTechniqueMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    techniqueId?: SortOrder
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
    learnedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type CharacterTechniqueMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    techniqueId?: SortOrder
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
    learnedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type CharacterTechniqueSumOrderByAggregateInput = {
    proficiency?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    masteryBonus?: SortOrder
  }

  export type EnumTalentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TalentType | EnumTalentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTalentTypeFilter<$PrismaModel> | $Enums.TalentType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TalentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TalentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTalentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TalentType | EnumTalentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTalentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TalentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTalentTypeFilter<$PrismaModel>
    _max?: NestedEnumTalentTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TalentScalarRelationFilter = {
    is?: TalentWhereInput
    isNot?: TalentWhereInput
  }

  export type CharacterTalentCharacterIdTalentIdCompoundUniqueInput = {
    characterId: string
    talentId: string
  }

  export type CharacterTalentCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    talentId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type CharacterTalentMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    talentId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type CharacterTalentMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    talentId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BloodlineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rarity?: SortOrder
    abilities?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BloodlineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BloodlineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rarity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourcesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    spiritStones?: SortOrder
    gold?: SortOrder
    materials?: SortOrder
    pills?: SortOrder
    herbs?: SortOrder
    lastUpdated?: SortOrder
  }

  export type ResourcesAvgOrderByAggregateInput = {
    spiritStones?: SortOrder
    gold?: SortOrder
  }

  export type ResourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    spiritStones?: SortOrder
    gold?: SortOrder
    lastUpdated?: SortOrder
  }

  export type ResourcesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    spiritStones?: SortOrder
    gold?: SortOrder
    lastUpdated?: SortOrder
  }

  export type ResourcesSumOrderByAggregateInput = {
    spiritStones?: SortOrder
    gold?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    tradeable?: SortOrder
    consumable?: SortOrder
    effects?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    tradeable?: SortOrder
    consumable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    value?: SortOrder
    stackable?: SortOrder
    tradeable?: SortOrder
    consumable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type InventoryItemUserIdItemIdCompoundUniqueInput = {
    userId: string
    itemId: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    metadata?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    acquiredAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CombatStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
    lastCombatAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatStatsAvgOrderByAggregateInput = {
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
  }

  export type CombatStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
    lastCombatAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
    lastCombatAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatStatsSumOrderByAggregateInput = {
    level?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    attack?: SortOrder
    defense?: SortOrder
    speed?: SortOrder
    criticalChance?: SortOrder
    criticalDamage?: SortOrder
    combatExperience?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    draws?: SortOrder
  }

  export type EnumCombatResultFilter<$PrismaModel = never> = {
    equals?: $Enums.CombatResult | EnumCombatResultFieldRefInput<$PrismaModel>
    in?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    not?: NestedEnumCombatResultFilter<$PrismaModel> | $Enums.CombatResult
  }

  export type CombatLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponentName?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
    lootGained?: SortOrder
    combatDetails?: SortOrder
    foughtAt?: SortOrder
  }

  export type CombatLogAvgOrderByAggregateInput = {
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
  }

  export type CombatLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponentName?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
    foughtAt?: SortOrder
  }

  export type CombatLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponentName?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
    foughtAt?: SortOrder
  }

  export type CombatLogSumOrderByAggregateInput = {
    duration?: SortOrder
    damageDealt?: SortOrder
    damageReceived?: SortOrder
    experienceGained?: SortOrder
  }

  export type EnumCombatResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CombatResult | EnumCombatResultFieldRefInput<$PrismaModel>
    in?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    not?: NestedEnumCombatResultWithAggregatesFilter<$PrismaModel> | $Enums.CombatResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCombatResultFilter<$PrismaModel>
    _max?: NestedEnumCombatResultFilter<$PrismaModel>
  }

  export type SectMemberListRelationFilter = {
    every?: SectMemberWhereInput
    some?: SectMemberWhereInput
    none?: SectMemberWhereInput
  }

  export type SectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    leaderId?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
    buildings?: SortOrder
    alliances?: SortOrder
    enemies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
  }

  export type SectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    leaderId?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    leaderId?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    spiritStones?: SortOrder
    reputation?: SortOrder
    influence?: SortOrder
    territory?: SortOrder
  }

  export type EnumSectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SectRole | EnumSectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSectRoleFilter<$PrismaModel> | $Enums.SectRole
  }

  export type SectScalarRelationFilter = {
    is?: SectWhereInput
    isNot?: SectWhereInput
  }

  export type SectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sectId?: SortOrder
    role?: SortOrder
    contribution?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type SectMemberAvgOrderByAggregateInput = {
    contribution?: SortOrder
  }

  export type SectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sectId?: SortOrder
    role?: SortOrder
    contribution?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type SectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sectId?: SortOrder
    role?: SortOrder
    contribution?: SortOrder
    joinedAt?: SortOrder
    lastActiveAt?: SortOrder
  }

  export type SectMemberSumOrderByAggregateInput = {
    contribution?: SortOrder
  }

  export type EnumSectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectRole | EnumSectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSectRoleWithAggregatesFilter<$PrismaModel> | $Enums.SectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectRoleFilter<$PrismaModel>
    _max?: NestedEnumSectRoleFilter<$PrismaModel>
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    maxProgress?: SortOrder
    rewards?: SortOrder
    isHidden?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    maxProgress?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    maxProgress?: SortOrder
    isHidden?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    maxProgress?: SortOrder
    isHidden?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    maxProgress?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type GameStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
    resourcesEarned?: SortOrder
    lastUpdated?: SortOrder
  }

  export type GameStatisticsAvgOrderByAggregateInput = {
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
  }

  export type GameStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
    lastUpdated?: SortOrder
  }

  export type GameStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
    lastUpdated?: SortOrder
  }

  export type GameStatisticsSumOrderByAggregateInput = {
    totalPlayTime?: SortOrder
    cultivationTime?: SortOrder
    combatWins?: SortOrder
    combatLosses?: SortOrder
    itemsCrafted?: SortOrder
    achievementsUnlocked?: SortOrder
    realmBreakthroughs?: SortOrder
    sectContribution?: SortOrder
  }

  export type EnumGameEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameEventType | EnumGameEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameEventTypeFilter<$PrismaModel> | $Enums.GameEventType
  }

  export type GameEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type GameEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type GameEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type EnumGameEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameEventType | EnumGameEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameEventTypeFilter<$PrismaModel>
    _max?: NestedEnumGameEventTypeFilter<$PrismaModel>
  }

  export type CharacterCreateNestedOneWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput
    connect?: CharacterWhereUniqueInput
  }

  export type ResourcesCreateNestedOneWithoutUserInput = {
    create?: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResourcesCreateOrConnectWithoutUserInput
    connect?: ResourcesWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput> | InventoryItemCreateWithoutUserInput[] | InventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUserInput | InventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: InventoryItemCreateManyUserInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type CultivationProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutUserInput
    connect?: CultivationProgressWhereUniqueInput
  }

  export type CombatStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CombatStatsCreateOrConnectWithoutUserInput
    connect?: CombatStatsWhereUniqueInput
  }

  export type SectMemberCreateNestedOneWithoutUserInput = {
    create?: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectMemberCreateOrConnectWithoutUserInput
    connect?: SectMemberWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type GameStatisticsCreateNestedOneWithoutUserInput = {
    create?: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameStatisticsCreateOrConnectWithoutUserInput
    connect?: GameStatisticsWhereUniqueInput
  }

  export type GameEventCreateNestedManyWithoutUserInput = {
    create?: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput> | GameEventCreateWithoutUserInput[] | GameEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutUserInput | GameEventCreateOrConnectWithoutUserInput[]
    createMany?: GameEventCreateManyUserInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type CombatLogCreateNestedManyWithoutUserInput = {
    create?: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput> | CombatLogCreateWithoutUserInput[] | CombatLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutUserInput | CombatLogCreateOrConnectWithoutUserInput[]
    createMany?: CombatLogCreateManyUserInputEnvelope
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput
    connect?: CharacterWhereUniqueInput
  }

  export type ResourcesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResourcesCreateOrConnectWithoutUserInput
    connect?: ResourcesWhereUniqueInput
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput> | InventoryItemCreateWithoutUserInput[] | InventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUserInput | InventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: InventoryItemCreateManyUserInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type CultivationProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutUserInput
    connect?: CultivationProgressWhereUniqueInput
  }

  export type CombatStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CombatStatsCreateOrConnectWithoutUserInput
    connect?: CombatStatsWhereUniqueInput
  }

  export type SectMemberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectMemberCreateOrConnectWithoutUserInput
    connect?: SectMemberWhereUniqueInput
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type GameStatisticsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameStatisticsCreateOrConnectWithoutUserInput
    connect?: GameStatisticsWhereUniqueInput
  }

  export type GameEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput> | GameEventCreateWithoutUserInput[] | GameEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutUserInput | GameEventCreateOrConnectWithoutUserInput[]
    createMany?: GameEventCreateManyUserInputEnvelope
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
  }

  export type CombatLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput> | CombatLogCreateWithoutUserInput[] | CombatLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutUserInput | CombatLogCreateOrConnectWithoutUserInput[]
    createMany?: CombatLogCreateManyUserInputEnvelope
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CharacterUpdateOneWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput
    upsert?: CharacterUpsertWithoutUserInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutUserInput, CharacterUpdateWithoutUserInput>, CharacterUncheckedUpdateWithoutUserInput>
  }

  export type ResourcesUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResourcesCreateOrConnectWithoutUserInput
    upsert?: ResourcesUpsertWithoutUserInput
    disconnect?: ResourcesWhereInput | boolean
    delete?: ResourcesWhereInput | boolean
    connect?: ResourcesWhereUniqueInput
    update?: XOR<XOR<ResourcesUpdateToOneWithWhereWithoutUserInput, ResourcesUpdateWithoutUserInput>, ResourcesUncheckedUpdateWithoutUserInput>
  }

  export type InventoryItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput> | InventoryItemCreateWithoutUserInput[] | InventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUserInput | InventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutUserInput | InventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryItemCreateManyUserInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutUserInput | InventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutUserInput | InventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type CultivationProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutUserInput
    upsert?: CultivationProgressUpsertWithoutUserInput
    disconnect?: CultivationProgressWhereInput | boolean
    delete?: CultivationProgressWhereInput | boolean
    connect?: CultivationProgressWhereUniqueInput
    update?: XOR<XOR<CultivationProgressUpdateToOneWithWhereWithoutUserInput, CultivationProgressUpdateWithoutUserInput>, CultivationProgressUncheckedUpdateWithoutUserInput>
  }

  export type CombatStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CombatStatsCreateOrConnectWithoutUserInput
    upsert?: CombatStatsUpsertWithoutUserInput
    disconnect?: CombatStatsWhereInput | boolean
    delete?: CombatStatsWhereInput | boolean
    connect?: CombatStatsWhereUniqueInput
    update?: XOR<XOR<CombatStatsUpdateToOneWithWhereWithoutUserInput, CombatStatsUpdateWithoutUserInput>, CombatStatsUncheckedUpdateWithoutUserInput>
  }

  export type SectMemberUpdateOneWithoutUserNestedInput = {
    create?: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectMemberCreateOrConnectWithoutUserInput
    upsert?: SectMemberUpsertWithoutUserInput
    disconnect?: SectMemberWhereInput | boolean
    delete?: SectMemberWhereInput | boolean
    connect?: SectMemberWhereUniqueInput
    update?: XOR<XOR<SectMemberUpdateToOneWithWhereWithoutUserInput, SectMemberUpdateWithoutUserInput>, SectMemberUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type GameStatisticsUpdateOneWithoutUserNestedInput = {
    create?: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameStatisticsCreateOrConnectWithoutUserInput
    upsert?: GameStatisticsUpsertWithoutUserInput
    disconnect?: GameStatisticsWhereInput | boolean
    delete?: GameStatisticsWhereInput | boolean
    connect?: GameStatisticsWhereUniqueInput
    update?: XOR<XOR<GameStatisticsUpdateToOneWithWhereWithoutUserInput, GameStatisticsUpdateWithoutUserInput>, GameStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type GameEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput> | GameEventCreateWithoutUserInput[] | GameEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutUserInput | GameEventCreateOrConnectWithoutUserInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutUserInput | GameEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameEventCreateManyUserInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutUserInput | GameEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutUserInput | GameEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type CombatLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput> | CombatLogCreateWithoutUserInput[] | CombatLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutUserInput | CombatLogCreateOrConnectWithoutUserInput[]
    upsert?: CombatLogUpsertWithWhereUniqueWithoutUserInput | CombatLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CombatLogCreateManyUserInputEnvelope
    set?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    disconnect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    delete?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    update?: CombatLogUpdateWithWhereUniqueWithoutUserInput | CombatLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CombatLogUpdateManyWithWhereWithoutUserInput | CombatLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutUserInput
    upsert?: CharacterUpsertWithoutUserInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutUserInput, CharacterUpdateWithoutUserInput>, CharacterUncheckedUpdateWithoutUserInput>
  }

  export type ResourcesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ResourcesCreateOrConnectWithoutUserInput
    upsert?: ResourcesUpsertWithoutUserInput
    disconnect?: ResourcesWhereInput | boolean
    delete?: ResourcesWhereInput | boolean
    connect?: ResourcesWhereUniqueInput
    update?: XOR<XOR<ResourcesUpdateToOneWithWhereWithoutUserInput, ResourcesUpdateWithoutUserInput>, ResourcesUncheckedUpdateWithoutUserInput>
  }

  export type InventoryItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput> | InventoryItemCreateWithoutUserInput[] | InventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUserInput | InventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutUserInput | InventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryItemCreateManyUserInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutUserInput | InventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutUserInput | InventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type CultivationProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutUserInput
    upsert?: CultivationProgressUpsertWithoutUserInput
    disconnect?: CultivationProgressWhereInput | boolean
    delete?: CultivationProgressWhereInput | boolean
    connect?: CultivationProgressWhereUniqueInput
    update?: XOR<XOR<CultivationProgressUpdateToOneWithWhereWithoutUserInput, CultivationProgressUpdateWithoutUserInput>, CultivationProgressUncheckedUpdateWithoutUserInput>
  }

  export type CombatStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CombatStatsCreateOrConnectWithoutUserInput
    upsert?: CombatStatsUpsertWithoutUserInput
    disconnect?: CombatStatsWhereInput | boolean
    delete?: CombatStatsWhereInput | boolean
    connect?: CombatStatsWhereUniqueInput
    update?: XOR<XOR<CombatStatsUpdateToOneWithWhereWithoutUserInput, CombatStatsUpdateWithoutUserInput>, CombatStatsUncheckedUpdateWithoutUserInput>
  }

  export type SectMemberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: SectMemberCreateOrConnectWithoutUserInput
    upsert?: SectMemberUpsertWithoutUserInput
    disconnect?: SectMemberWhereInput | boolean
    delete?: SectMemberWhereInput | boolean
    connect?: SectMemberWhereUniqueInput
    update?: XOR<XOR<SectMemberUpdateToOneWithWhereWithoutUserInput, SectMemberUpdateWithoutUserInput>, SectMemberUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type GameStatisticsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameStatisticsCreateOrConnectWithoutUserInput
    upsert?: GameStatisticsUpsertWithoutUserInput
    disconnect?: GameStatisticsWhereInput | boolean
    delete?: GameStatisticsWhereInput | boolean
    connect?: GameStatisticsWhereUniqueInput
    update?: XOR<XOR<GameStatisticsUpdateToOneWithWhereWithoutUserInput, GameStatisticsUpdateWithoutUserInput>, GameStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type GameEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput> | GameEventCreateWithoutUserInput[] | GameEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameEventCreateOrConnectWithoutUserInput | GameEventCreateOrConnectWithoutUserInput[]
    upsert?: GameEventUpsertWithWhereUniqueWithoutUserInput | GameEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameEventCreateManyUserInputEnvelope
    set?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    disconnect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    delete?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    connect?: GameEventWhereUniqueInput | GameEventWhereUniqueInput[]
    update?: GameEventUpdateWithWhereUniqueWithoutUserInput | GameEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameEventUpdateManyWithWhereWithoutUserInput | GameEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
  }

  export type CombatLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput> | CombatLogCreateWithoutUserInput[] | CombatLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CombatLogCreateOrConnectWithoutUserInput | CombatLogCreateOrConnectWithoutUserInput[]
    upsert?: CombatLogUpsertWithWhereUniqueWithoutUserInput | CombatLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CombatLogCreateManyUserInputEnvelope
    set?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    disconnect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    delete?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    connect?: CombatLogWhereUniqueInput | CombatLogWhereUniqueInput[]
    update?: CombatLogUpdateWithWhereUniqueWithoutUserInput | CombatLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CombatLogUpdateManyWithWhereWithoutUserInput | CombatLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCharacterInput = {
    create?: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterInput
    connect?: UserWhereUniqueInput
  }

  export type BloodlineCreateNestedOneWithoutCharactersInput = {
    create?: XOR<BloodlineCreateWithoutCharactersInput, BloodlineUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: BloodlineCreateOrConnectWithoutCharactersInput
    connect?: BloodlineWhereUniqueInput
  }

  export type CharacterTechniqueCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput> | CharacterTechniqueCreateWithoutCharacterInput[] | CharacterTechniqueUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutCharacterInput | CharacterTechniqueCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterTechniqueCreateManyCharacterInputEnvelope
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
  }

  export type CharacterTalentCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput> | CharacterTalentCreateWithoutCharacterInput[] | CharacterTalentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutCharacterInput | CharacterTalentCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterTalentCreateManyCharacterInputEnvelope
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
  }

  export type CharacterTechniqueUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput> | CharacterTechniqueCreateWithoutCharacterInput[] | CharacterTechniqueUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutCharacterInput | CharacterTechniqueCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterTechniqueCreateManyCharacterInputEnvelope
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
  }

  export type CharacterTalentUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput> | CharacterTalentCreateWithoutCharacterInput[] | CharacterTalentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutCharacterInput | CharacterTalentCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterTalentCreateManyCharacterInputEnvelope
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
  }

  export type EnumCultivationRealmFieldUpdateOperationsInput = {
    set?: $Enums.CultivationRealm
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumElementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ElementType
  }

  export type EnumSpiritualGradeFieldUpdateOperationsInput = {
    set?: $Enums.SpiritualGrade
  }

  export type UserUpdateOneRequiredWithoutCharacterNestedInput = {
    create?: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharacterInput
    upsert?: UserUpsertWithoutCharacterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharacterInput, UserUpdateWithoutCharacterInput>, UserUncheckedUpdateWithoutCharacterInput>
  }

  export type BloodlineUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<BloodlineCreateWithoutCharactersInput, BloodlineUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: BloodlineCreateOrConnectWithoutCharactersInput
    upsert?: BloodlineUpsertWithoutCharactersInput
    disconnect?: BloodlineWhereInput | boolean
    delete?: BloodlineWhereInput | boolean
    connect?: BloodlineWhereUniqueInput
    update?: XOR<XOR<BloodlineUpdateToOneWithWhereWithoutCharactersInput, BloodlineUpdateWithoutCharactersInput>, BloodlineUncheckedUpdateWithoutCharactersInput>
  }

  export type CharacterTechniqueUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput> | CharacterTechniqueCreateWithoutCharacterInput[] | CharacterTechniqueUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutCharacterInput | CharacterTechniqueCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterTechniqueUpsertWithWhereUniqueWithoutCharacterInput | CharacterTechniqueUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterTechniqueCreateManyCharacterInputEnvelope
    set?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    disconnect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    delete?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    update?: CharacterTechniqueUpdateWithWhereUniqueWithoutCharacterInput | CharacterTechniqueUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterTechniqueUpdateManyWithWhereWithoutCharacterInput | CharacterTechniqueUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
  }

  export type CharacterTalentUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput> | CharacterTalentCreateWithoutCharacterInput[] | CharacterTalentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutCharacterInput | CharacterTalentCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterTalentUpsertWithWhereUniqueWithoutCharacterInput | CharacterTalentUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterTalentCreateManyCharacterInputEnvelope
    set?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    disconnect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    delete?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    update?: CharacterTalentUpdateWithWhereUniqueWithoutCharacterInput | CharacterTalentUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterTalentUpdateManyWithWhereWithoutCharacterInput | CharacterTalentUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
  }

  export type CharacterTechniqueUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput> | CharacterTechniqueCreateWithoutCharacterInput[] | CharacterTechniqueUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutCharacterInput | CharacterTechniqueCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterTechniqueUpsertWithWhereUniqueWithoutCharacterInput | CharacterTechniqueUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterTechniqueCreateManyCharacterInputEnvelope
    set?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    disconnect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    delete?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    update?: CharacterTechniqueUpdateWithWhereUniqueWithoutCharacterInput | CharacterTechniqueUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterTechniqueUpdateManyWithWhereWithoutCharacterInput | CharacterTechniqueUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
  }

  export type CharacterTalentUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput> | CharacterTalentCreateWithoutCharacterInput[] | CharacterTalentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutCharacterInput | CharacterTalentCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterTalentUpsertWithWhereUniqueWithoutCharacterInput | CharacterTalentUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterTalentCreateManyCharacterInputEnvelope
    set?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    disconnect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    delete?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    update?: CharacterTalentUpdateWithWhereUniqueWithoutCharacterInput | CharacterTalentUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterTalentUpdateManyWithWhereWithoutCharacterInput | CharacterTalentUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCultivationInput = {
    create?: XOR<UserCreateWithoutCultivationInput, UserUncheckedCreateWithoutCultivationInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultivationInput
    connect?: UserWhereUniqueInput
  }

  export type CultivationTechniqueCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<CultivationTechniqueCreateWithoutUserProgressInput, CultivationTechniqueUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: CultivationTechniqueCreateOrConnectWithoutUserProgressInput
    connect?: CultivationTechniqueWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCultivationNestedInput = {
    create?: XOR<UserCreateWithoutCultivationInput, UserUncheckedCreateWithoutCultivationInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultivationInput
    upsert?: UserUpsertWithoutCultivationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCultivationInput, UserUpdateWithoutCultivationInput>, UserUncheckedUpdateWithoutCultivationInput>
  }

  export type CultivationTechniqueUpdateOneWithoutUserProgressNestedInput = {
    create?: XOR<CultivationTechniqueCreateWithoutUserProgressInput, CultivationTechniqueUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: CultivationTechniqueCreateOrConnectWithoutUserProgressInput
    upsert?: CultivationTechniqueUpsertWithoutUserProgressInput
    disconnect?: CultivationTechniqueWhereInput | boolean
    delete?: CultivationTechniqueWhereInput | boolean
    connect?: CultivationTechniqueWhereUniqueInput
    update?: XOR<XOR<CultivationTechniqueUpdateToOneWithWhereWithoutUserProgressInput, CultivationTechniqueUpdateWithoutUserProgressInput>, CultivationTechniqueUncheckedUpdateWithoutUserProgressInput>
  }

  export type CultivationProgressCreateNestedManyWithoutCurrentTechniqueInput = {
    create?: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput> | CultivationProgressCreateWithoutCurrentTechniqueInput[] | CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput[]
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput | CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput[]
    createMany?: CultivationProgressCreateManyCurrentTechniqueInputEnvelope
    connect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
  }

  export type CharacterTechniqueCreateNestedManyWithoutTechniqueInput = {
    create?: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput> | CharacterTechniqueCreateWithoutTechniqueInput[] | CharacterTechniqueUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutTechniqueInput | CharacterTechniqueCreateOrConnectWithoutTechniqueInput[]
    createMany?: CharacterTechniqueCreateManyTechniqueInputEnvelope
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
  }

  export type CultivationProgressUncheckedCreateNestedManyWithoutCurrentTechniqueInput = {
    create?: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput> | CultivationProgressCreateWithoutCurrentTechniqueInput[] | CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput[]
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput | CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput[]
    createMany?: CultivationProgressCreateManyCurrentTechniqueInputEnvelope
    connect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
  }

  export type CharacterTechniqueUncheckedCreateNestedManyWithoutTechniqueInput = {
    create?: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput> | CharacterTechniqueCreateWithoutTechniqueInput[] | CharacterTechniqueUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutTechniqueInput | CharacterTechniqueCreateOrConnectWithoutTechniqueInput[]
    createMany?: CharacterTechniqueCreateManyTechniqueInputEnvelope
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
  }

  export type EnumTechniqueTypeFieldUpdateOperationsInput = {
    set?: $Enums.TechniqueType
  }

  export type EnumItemRarityFieldUpdateOperationsInput = {
    set?: $Enums.ItemRarity
  }

  export type CultivationProgressUpdateManyWithoutCurrentTechniqueNestedInput = {
    create?: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput> | CultivationProgressCreateWithoutCurrentTechniqueInput[] | CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput[]
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput | CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput[]
    upsert?: CultivationProgressUpsertWithWhereUniqueWithoutCurrentTechniqueInput | CultivationProgressUpsertWithWhereUniqueWithoutCurrentTechniqueInput[]
    createMany?: CultivationProgressCreateManyCurrentTechniqueInputEnvelope
    set?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    disconnect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    delete?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    connect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    update?: CultivationProgressUpdateWithWhereUniqueWithoutCurrentTechniqueInput | CultivationProgressUpdateWithWhereUniqueWithoutCurrentTechniqueInput[]
    updateMany?: CultivationProgressUpdateManyWithWhereWithoutCurrentTechniqueInput | CultivationProgressUpdateManyWithWhereWithoutCurrentTechniqueInput[]
    deleteMany?: CultivationProgressScalarWhereInput | CultivationProgressScalarWhereInput[]
  }

  export type CharacterTechniqueUpdateManyWithoutTechniqueNestedInput = {
    create?: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput> | CharacterTechniqueCreateWithoutTechniqueInput[] | CharacterTechniqueUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutTechniqueInput | CharacterTechniqueCreateOrConnectWithoutTechniqueInput[]
    upsert?: CharacterTechniqueUpsertWithWhereUniqueWithoutTechniqueInput | CharacterTechniqueUpsertWithWhereUniqueWithoutTechniqueInput[]
    createMany?: CharacterTechniqueCreateManyTechniqueInputEnvelope
    set?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    disconnect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    delete?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    update?: CharacterTechniqueUpdateWithWhereUniqueWithoutTechniqueInput | CharacterTechniqueUpdateWithWhereUniqueWithoutTechniqueInput[]
    updateMany?: CharacterTechniqueUpdateManyWithWhereWithoutTechniqueInput | CharacterTechniqueUpdateManyWithWhereWithoutTechniqueInput[]
    deleteMany?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
  }

  export type CultivationProgressUncheckedUpdateManyWithoutCurrentTechniqueNestedInput = {
    create?: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput> | CultivationProgressCreateWithoutCurrentTechniqueInput[] | CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput[]
    connectOrCreate?: CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput | CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput[]
    upsert?: CultivationProgressUpsertWithWhereUniqueWithoutCurrentTechniqueInput | CultivationProgressUpsertWithWhereUniqueWithoutCurrentTechniqueInput[]
    createMany?: CultivationProgressCreateManyCurrentTechniqueInputEnvelope
    set?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    disconnect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    delete?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    connect?: CultivationProgressWhereUniqueInput | CultivationProgressWhereUniqueInput[]
    update?: CultivationProgressUpdateWithWhereUniqueWithoutCurrentTechniqueInput | CultivationProgressUpdateWithWhereUniqueWithoutCurrentTechniqueInput[]
    updateMany?: CultivationProgressUpdateManyWithWhereWithoutCurrentTechniqueInput | CultivationProgressUpdateManyWithWhereWithoutCurrentTechniqueInput[]
    deleteMany?: CultivationProgressScalarWhereInput | CultivationProgressScalarWhereInput[]
  }

  export type CharacterTechniqueUncheckedUpdateManyWithoutTechniqueNestedInput = {
    create?: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput> | CharacterTechniqueCreateWithoutTechniqueInput[] | CharacterTechniqueUncheckedCreateWithoutTechniqueInput[]
    connectOrCreate?: CharacterTechniqueCreateOrConnectWithoutTechniqueInput | CharacterTechniqueCreateOrConnectWithoutTechniqueInput[]
    upsert?: CharacterTechniqueUpsertWithWhereUniqueWithoutTechniqueInput | CharacterTechniqueUpsertWithWhereUniqueWithoutTechniqueInput[]
    createMany?: CharacterTechniqueCreateManyTechniqueInputEnvelope
    set?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    disconnect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    delete?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    connect?: CharacterTechniqueWhereUniqueInput | CharacterTechniqueWhereUniqueInput[]
    update?: CharacterTechniqueUpdateWithWhereUniqueWithoutTechniqueInput | CharacterTechniqueUpdateWithWhereUniqueWithoutTechniqueInput[]
    updateMany?: CharacterTechniqueUpdateManyWithWhereWithoutTechniqueInput | CharacterTechniqueUpdateManyWithWhereWithoutTechniqueInput[]
    deleteMany?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutTechniquesInput = {
    create?: XOR<CharacterCreateWithoutTechniquesInput, CharacterUncheckedCreateWithoutTechniquesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutTechniquesInput
    connect?: CharacterWhereUniqueInput
  }

  export type CultivationTechniqueCreateNestedOneWithoutCharacterTechniquesInput = {
    create?: XOR<CultivationTechniqueCreateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedCreateWithoutCharacterTechniquesInput>
    connectOrCreate?: CultivationTechniqueCreateOrConnectWithoutCharacterTechniquesInput
    connect?: CultivationTechniqueWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutTechniquesNestedInput = {
    create?: XOR<CharacterCreateWithoutTechniquesInput, CharacterUncheckedCreateWithoutTechniquesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutTechniquesInput
    upsert?: CharacterUpsertWithoutTechniquesInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutTechniquesInput, CharacterUpdateWithoutTechniquesInput>, CharacterUncheckedUpdateWithoutTechniquesInput>
  }

  export type CultivationTechniqueUpdateOneRequiredWithoutCharacterTechniquesNestedInput = {
    create?: XOR<CultivationTechniqueCreateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedCreateWithoutCharacterTechniquesInput>
    connectOrCreate?: CultivationTechniqueCreateOrConnectWithoutCharacterTechniquesInput
    upsert?: CultivationTechniqueUpsertWithoutCharacterTechniquesInput
    connect?: CultivationTechniqueWhereUniqueInput
    update?: XOR<XOR<CultivationTechniqueUpdateToOneWithWhereWithoutCharacterTechniquesInput, CultivationTechniqueUpdateWithoutCharacterTechniquesInput>, CultivationTechniqueUncheckedUpdateWithoutCharacterTechniquesInput>
  }

  export type CharacterTalentCreateNestedManyWithoutTalentInput = {
    create?: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput> | CharacterTalentCreateWithoutTalentInput[] | CharacterTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutTalentInput | CharacterTalentCreateOrConnectWithoutTalentInput[]
    createMany?: CharacterTalentCreateManyTalentInputEnvelope
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
  }

  export type CharacterTalentUncheckedCreateNestedManyWithoutTalentInput = {
    create?: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput> | CharacterTalentCreateWithoutTalentInput[] | CharacterTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutTalentInput | CharacterTalentCreateOrConnectWithoutTalentInput[]
    createMany?: CharacterTalentCreateManyTalentInputEnvelope
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
  }

  export type EnumTalentTypeFieldUpdateOperationsInput = {
    set?: $Enums.TalentType
  }

  export type CharacterTalentUpdateManyWithoutTalentNestedInput = {
    create?: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput> | CharacterTalentCreateWithoutTalentInput[] | CharacterTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutTalentInput | CharacterTalentCreateOrConnectWithoutTalentInput[]
    upsert?: CharacterTalentUpsertWithWhereUniqueWithoutTalentInput | CharacterTalentUpsertWithWhereUniqueWithoutTalentInput[]
    createMany?: CharacterTalentCreateManyTalentInputEnvelope
    set?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    disconnect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    delete?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    update?: CharacterTalentUpdateWithWhereUniqueWithoutTalentInput | CharacterTalentUpdateWithWhereUniqueWithoutTalentInput[]
    updateMany?: CharacterTalentUpdateManyWithWhereWithoutTalentInput | CharacterTalentUpdateManyWithWhereWithoutTalentInput[]
    deleteMany?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
  }

  export type CharacterTalentUncheckedUpdateManyWithoutTalentNestedInput = {
    create?: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput> | CharacterTalentCreateWithoutTalentInput[] | CharacterTalentUncheckedCreateWithoutTalentInput[]
    connectOrCreate?: CharacterTalentCreateOrConnectWithoutTalentInput | CharacterTalentCreateOrConnectWithoutTalentInput[]
    upsert?: CharacterTalentUpsertWithWhereUniqueWithoutTalentInput | CharacterTalentUpsertWithWhereUniqueWithoutTalentInput[]
    createMany?: CharacterTalentCreateManyTalentInputEnvelope
    set?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    disconnect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    delete?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    connect?: CharacterTalentWhereUniqueInput | CharacterTalentWhereUniqueInput[]
    update?: CharacterTalentUpdateWithWhereUniqueWithoutTalentInput | CharacterTalentUpdateWithWhereUniqueWithoutTalentInput[]
    updateMany?: CharacterTalentUpdateManyWithWhereWithoutTalentInput | CharacterTalentUpdateManyWithWhereWithoutTalentInput[]
    deleteMany?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutTalentsInput = {
    create?: XOR<CharacterCreateWithoutTalentsInput, CharacterUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutTalentsInput
    connect?: CharacterWhereUniqueInput
  }

  export type TalentCreateNestedOneWithoutCharacterTalentsInput = {
    create?: XOR<TalentCreateWithoutCharacterTalentsInput, TalentUncheckedCreateWithoutCharacterTalentsInput>
    connectOrCreate?: TalentCreateOrConnectWithoutCharacterTalentsInput
    connect?: TalentWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutTalentsNestedInput = {
    create?: XOR<CharacterCreateWithoutTalentsInput, CharacterUncheckedCreateWithoutTalentsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutTalentsInput
    upsert?: CharacterUpsertWithoutTalentsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutTalentsInput, CharacterUpdateWithoutTalentsInput>, CharacterUncheckedUpdateWithoutTalentsInput>
  }

  export type TalentUpdateOneRequiredWithoutCharacterTalentsNestedInput = {
    create?: XOR<TalentCreateWithoutCharacterTalentsInput, TalentUncheckedCreateWithoutCharacterTalentsInput>
    connectOrCreate?: TalentCreateOrConnectWithoutCharacterTalentsInput
    upsert?: TalentUpsertWithoutCharacterTalentsInput
    connect?: TalentWhereUniqueInput
    update?: XOR<XOR<TalentUpdateToOneWithWhereWithoutCharacterTalentsInput, TalentUpdateWithoutCharacterTalentsInput>, TalentUncheckedUpdateWithoutCharacterTalentsInput>
  }

  export type CharacterCreateNestedManyWithoutBloodlineInput = {
    create?: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput> | CharacterCreateWithoutBloodlineInput[] | CharacterUncheckedCreateWithoutBloodlineInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBloodlineInput | CharacterCreateOrConnectWithoutBloodlineInput[]
    createMany?: CharacterCreateManyBloodlineInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutBloodlineInput = {
    create?: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput> | CharacterCreateWithoutBloodlineInput[] | CharacterUncheckedCreateWithoutBloodlineInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBloodlineInput | CharacterCreateOrConnectWithoutBloodlineInput[]
    createMany?: CharacterCreateManyBloodlineInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutBloodlineNestedInput = {
    create?: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput> | CharacterCreateWithoutBloodlineInput[] | CharacterUncheckedCreateWithoutBloodlineInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBloodlineInput | CharacterCreateOrConnectWithoutBloodlineInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutBloodlineInput | CharacterUpsertWithWhereUniqueWithoutBloodlineInput[]
    createMany?: CharacterCreateManyBloodlineInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutBloodlineInput | CharacterUpdateWithWhereUniqueWithoutBloodlineInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutBloodlineInput | CharacterUpdateManyWithWhereWithoutBloodlineInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutBloodlineNestedInput = {
    create?: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput> | CharacterCreateWithoutBloodlineInput[] | CharacterUncheckedCreateWithoutBloodlineInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutBloodlineInput | CharacterCreateOrConnectWithoutBloodlineInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutBloodlineInput | CharacterUpsertWithWhereUniqueWithoutBloodlineInput[]
    createMany?: CharacterCreateManyBloodlineInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutBloodlineInput | CharacterUpdateWithWhereUniqueWithoutBloodlineInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutBloodlineInput | CharacterUpdateManyWithWhereWithoutBloodlineInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    upsert?: UserUpsertWithoutResourcesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesInput, UserUpdateWithoutResourcesInput>, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type InventoryItemCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type InventoryItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput> | InventoryItemCreateWithoutItemInput[] | InventoryItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutItemInput | InventoryItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutItemInput | InventoryItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryItemCreateManyItemInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutItemInput | InventoryItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutItemInput | InventoryItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryItemsInput
    upsert?: ItemUpsertWithoutInventoryItemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryItemsInput, ItemUpdateWithoutInventoryItemsInput>, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type UserCreateNestedOneWithoutCombatInput = {
    create?: XOR<UserCreateWithoutCombatInput, UserUncheckedCreateWithoutCombatInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombatInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCombatNestedInput = {
    create?: XOR<UserCreateWithoutCombatInput, UserUncheckedCreateWithoutCombatInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombatInput
    upsert?: UserUpsertWithoutCombatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCombatInput, UserUpdateWithoutCombatInput>, UserUncheckedUpdateWithoutCombatInput>
  }

  export type UserCreateNestedOneWithoutCombatLogsInput = {
    create?: XOR<UserCreateWithoutCombatLogsInput, UserUncheckedCreateWithoutCombatLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombatLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCombatResultFieldUpdateOperationsInput = {
    set?: $Enums.CombatResult
  }

  export type UserUpdateOneRequiredWithoutCombatLogsNestedInput = {
    create?: XOR<UserCreateWithoutCombatLogsInput, UserUncheckedCreateWithoutCombatLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombatLogsInput
    upsert?: UserUpsertWithoutCombatLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCombatLogsInput, UserUpdateWithoutCombatLogsInput>, UserUncheckedUpdateWithoutCombatLogsInput>
  }

  export type SectMemberCreateNestedManyWithoutSectInput = {
    create?: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput> | SectMemberCreateWithoutSectInput[] | SectMemberUncheckedCreateWithoutSectInput[]
    connectOrCreate?: SectMemberCreateOrConnectWithoutSectInput | SectMemberCreateOrConnectWithoutSectInput[]
    createMany?: SectMemberCreateManySectInputEnvelope
    connect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
  }

  export type SectMemberUncheckedCreateNestedManyWithoutSectInput = {
    create?: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput> | SectMemberCreateWithoutSectInput[] | SectMemberUncheckedCreateWithoutSectInput[]
    connectOrCreate?: SectMemberCreateOrConnectWithoutSectInput | SectMemberCreateOrConnectWithoutSectInput[]
    createMany?: SectMemberCreateManySectInputEnvelope
    connect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
  }

  export type SectMemberUpdateManyWithoutSectNestedInput = {
    create?: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput> | SectMemberCreateWithoutSectInput[] | SectMemberUncheckedCreateWithoutSectInput[]
    connectOrCreate?: SectMemberCreateOrConnectWithoutSectInput | SectMemberCreateOrConnectWithoutSectInput[]
    upsert?: SectMemberUpsertWithWhereUniqueWithoutSectInput | SectMemberUpsertWithWhereUniqueWithoutSectInput[]
    createMany?: SectMemberCreateManySectInputEnvelope
    set?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    disconnect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    delete?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    connect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    update?: SectMemberUpdateWithWhereUniqueWithoutSectInput | SectMemberUpdateWithWhereUniqueWithoutSectInput[]
    updateMany?: SectMemberUpdateManyWithWhereWithoutSectInput | SectMemberUpdateManyWithWhereWithoutSectInput[]
    deleteMany?: SectMemberScalarWhereInput | SectMemberScalarWhereInput[]
  }

  export type SectMemberUncheckedUpdateManyWithoutSectNestedInput = {
    create?: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput> | SectMemberCreateWithoutSectInput[] | SectMemberUncheckedCreateWithoutSectInput[]
    connectOrCreate?: SectMemberCreateOrConnectWithoutSectInput | SectMemberCreateOrConnectWithoutSectInput[]
    upsert?: SectMemberUpsertWithWhereUniqueWithoutSectInput | SectMemberUpsertWithWhereUniqueWithoutSectInput[]
    createMany?: SectMemberCreateManySectInputEnvelope
    set?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    disconnect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    delete?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    connect?: SectMemberWhereUniqueInput | SectMemberWhereUniqueInput[]
    update?: SectMemberUpdateWithWhereUniqueWithoutSectInput | SectMemberUpdateWithWhereUniqueWithoutSectInput[]
    updateMany?: SectMemberUpdateManyWithWhereWithoutSectInput | SectMemberUpdateManyWithWhereWithoutSectInput[]
    deleteMany?: SectMemberScalarWhereInput | SectMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSectMembershipInput = {
    create?: XOR<UserCreateWithoutSectMembershipInput, UserUncheckedCreateWithoutSectMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutSectMembershipInput
    connect?: UserWhereUniqueInput
  }

  export type SectCreateNestedOneWithoutMembersInput = {
    create?: XOR<SectCreateWithoutMembersInput, SectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SectCreateOrConnectWithoutMembersInput
    connect?: SectWhereUniqueInput
  }

  export type EnumSectRoleFieldUpdateOperationsInput = {
    set?: $Enums.SectRole
  }

  export type UserUpdateOneRequiredWithoutSectMembershipNestedInput = {
    create?: XOR<UserCreateWithoutSectMembershipInput, UserUncheckedCreateWithoutSectMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutSectMembershipInput
    upsert?: UserUpsertWithoutSectMembershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSectMembershipInput, UserUpdateWithoutSectMembershipInput>, UserUncheckedUpdateWithoutSectMembershipInput>
  }

  export type SectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SectCreateWithoutMembersInput, SectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SectCreateOrConnectWithoutMembersInput
    upsert?: SectUpsertWithoutMembersInput
    connect?: SectWhereUniqueInput
    update?: XOR<XOR<SectUpdateToOneWithWhereWithoutMembersInput, SectUpdateWithoutMembersInput>, SectUncheckedUpdateWithoutMembersInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<UserCreateWithoutStatisticsInput, UserUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatisticsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<UserCreateWithoutStatisticsInput, UserUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatisticsInput
    upsert?: UserUpsertWithoutStatisticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatisticsInput, UserUpdateWithoutStatisticsInput>, UserUncheckedUpdateWithoutStatisticsInput>
  }

  export type UserCreateNestedOneWithoutGameEventsInput = {
    create?: XOR<UserCreateWithoutGameEventsInput, UserUncheckedCreateWithoutGameEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGameEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameEventType
  }

  export type UserUpdateOneRequiredWithoutGameEventsNestedInput = {
    create?: XOR<UserCreateWithoutGameEventsInput, UserUncheckedCreateWithoutGameEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameEventsInput
    upsert?: UserUpsertWithoutGameEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameEventsInput, UserUpdateWithoutGameEventsInput>, UserUncheckedUpdateWithoutGameEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCultivationRealmFilter<$PrismaModel = never> = {
    equals?: $Enums.CultivationRealm | EnumCultivationRealmFieldRefInput<$PrismaModel>
    in?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    notIn?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    not?: NestedEnumCultivationRealmFilter<$PrismaModel> | $Enums.CultivationRealm
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type NestedEnumSpiritualGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpiritualGrade | EnumSpiritualGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpiritualGradeFilter<$PrismaModel> | $Enums.SpiritualGrade
  }

  export type NestedEnumCultivationRealmWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CultivationRealm | EnumCultivationRealmFieldRefInput<$PrismaModel>
    in?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    notIn?: $Enums.CultivationRealm[] | ListEnumCultivationRealmFieldRefInput<$PrismaModel>
    not?: NestedEnumCultivationRealmWithAggregatesFilter<$PrismaModel> | $Enums.CultivationRealm
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCultivationRealmFilter<$PrismaModel>
    _max?: NestedEnumCultivationRealmFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type NestedEnumSpiritualGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpiritualGrade | EnumSpiritualGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpiritualGrade[] | ListEnumSpiritualGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpiritualGradeWithAggregatesFilter<$PrismaModel> | $Enums.SpiritualGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpiritualGradeFilter<$PrismaModel>
    _max?: NestedEnumSpiritualGradeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTechniqueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TechniqueType | EnumTechniqueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechniqueTypeFilter<$PrismaModel> | $Enums.TechniqueType
  }

  export type NestedEnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type NestedEnumTechniqueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechniqueType | EnumTechniqueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechniqueType[] | ListEnumTechniqueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTechniqueTypeWithAggregatesFilter<$PrismaModel> | $Enums.TechniqueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechniqueTypeFilter<$PrismaModel>
    _max?: NestedEnumTechniqueTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRarity[] | ListEnumItemRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type NestedEnumTalentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TalentType | EnumTalentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTalentTypeFilter<$PrismaModel> | $Enums.TalentType
  }

  export type NestedEnumTalentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TalentType | EnumTalentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TalentType[] | ListEnumTalentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTalentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TalentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTalentTypeFilter<$PrismaModel>
    _max?: NestedEnumTalentTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumCombatResultFilter<$PrismaModel = never> = {
    equals?: $Enums.CombatResult | EnumCombatResultFieldRefInput<$PrismaModel>
    in?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    not?: NestedEnumCombatResultFilter<$PrismaModel> | $Enums.CombatResult
  }

  export type NestedEnumCombatResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CombatResult | EnumCombatResultFieldRefInput<$PrismaModel>
    in?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.CombatResult[] | ListEnumCombatResultFieldRefInput<$PrismaModel>
    not?: NestedEnumCombatResultWithAggregatesFilter<$PrismaModel> | $Enums.CombatResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCombatResultFilter<$PrismaModel>
    _max?: NestedEnumCombatResultFilter<$PrismaModel>
  }

  export type NestedEnumSectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SectRole | EnumSectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSectRoleFilter<$PrismaModel> | $Enums.SectRole
  }

  export type NestedEnumSectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SectRole | EnumSectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SectRole[] | ListEnumSectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSectRoleWithAggregatesFilter<$PrismaModel> | $Enums.SectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSectRoleFilter<$PrismaModel>
    _max?: NestedEnumSectRoleFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedEnumGameEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameEventType | EnumGameEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameEventTypeFilter<$PrismaModel> | $Enums.GameEventType
  }

  export type NestedEnumGameEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameEventType | EnumGameEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameEventType[] | ListEnumGameEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameEventTypeFilter<$PrismaModel>
    _max?: NestedEnumGameEventTypeFilter<$PrismaModel>
  }

  export type CharacterCreateWithoutUserInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bloodline?: BloodlineCreateNestedOneWithoutCharactersInput
    techniques?: CharacterTechniqueCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineId?: string | null
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    techniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutUserInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
  }

  export type ResourcesCreateWithoutUserInput = {
    id?: string
    spiritStones?: bigint | number
    gold?: bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type ResourcesUncheckedCreateWithoutUserInput = {
    id?: string
    spiritStones?: bigint | number
    gold?: bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type ResourcesCreateOrConnectWithoutUserInput = {
    where: ResourcesWhereUniqueInput
    create: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
  }

  export type InventoryItemCreateWithoutUserInput = {
    id?: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutUserInput = {
    id?: string
    itemId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutUserInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput>
  }

  export type InventoryItemCreateManyUserInputEnvelope = {
    data: InventoryItemCreateManyUserInput | InventoryItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CultivationProgressCreateWithoutUserInput = {
    id?: string
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentTechnique?: CultivationTechniqueCreateNestedOneWithoutUserProgressInput
  }

  export type CultivationProgressUncheckedCreateWithoutUserInput = {
    id?: string
    currentTechniqueId?: string | null
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultivationProgressCreateOrConnectWithoutUserInput = {
    where: CultivationProgressWhereUniqueInput
    create: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
  }

  export type CombatStatsCreateWithoutUserInput = {
    id?: string
    level?: number
    health?: number
    maxHealth?: number
    attack?: number
    defense?: number
    speed?: number
    criticalChance?: number
    criticalDamage?: number
    combatExperience?: bigint | number
    wins?: number
    losses?: number
    draws?: number
    lastCombatAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatStatsUncheckedCreateWithoutUserInput = {
    id?: string
    level?: number
    health?: number
    maxHealth?: number
    attack?: number
    defense?: number
    speed?: number
    criticalChance?: number
    criticalDamage?: number
    combatExperience?: bigint | number
    wins?: number
    losses?: number
    draws?: number
    lastCombatAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatStatsCreateOrConnectWithoutUserInput = {
    where: CombatStatsWhereUniqueInput
    create: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
  }

  export type SectMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    sect: SectCreateNestedOneWithoutMembersInput
  }

  export type SectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    sectId: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type SectMemberCreateOrConnectWithoutUserInput = {
    where: SectMemberWhereUniqueInput
    create: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameStatisticsCreateWithoutUserInput = {
    id?: string
    totalPlayTime?: bigint | number
    cultivationTime?: bigint | number
    combatWins?: number
    combatLosses?: number
    itemsCrafted?: number
    achievementsUnlocked?: number
    realmBreakthroughs?: number
    sectContribution?: bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type GameStatisticsUncheckedCreateWithoutUserInput = {
    id?: string
    totalPlayTime?: bigint | number
    cultivationTime?: bigint | number
    combatWins?: number
    combatLosses?: number
    itemsCrafted?: number
    achievementsUnlocked?: number
    realmBreakthroughs?: number
    sectContribution?: bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string
  }

  export type GameStatisticsCreateOrConnectWithoutUserInput = {
    where: GameStatisticsWhereUniqueInput
    create: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
  }

  export type GameEventCreateWithoutUserInput = {
    id?: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type GameEventUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type GameEventCreateOrConnectWithoutUserInput = {
    where: GameEventWhereUniqueInput
    create: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput>
  }

  export type GameEventCreateManyUserInputEnvelope = {
    data: GameEventCreateManyUserInput | GameEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CombatLogCreateWithoutUserInput = {
    id?: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
  }

  export type CombatLogUncheckedCreateWithoutUserInput = {
    id?: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
  }

  export type CombatLogCreateOrConnectWithoutUserInput = {
    where: CombatLogWhereUniqueInput
    create: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput>
  }

  export type CombatLogCreateManyUserInputEnvelope = {
    data: CombatLogCreateManyUserInput | CombatLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithoutUserInput = {
    update: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
    create: XOR<CharacterCreateWithoutUserInput, CharacterUncheckedCreateWithoutUserInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutUserInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutUserInput, CharacterUncheckedUpdateWithoutUserInput>
  }

  export type CharacterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodline?: BloodlineUpdateOneWithoutCharactersNestedInput
    techniques?: CharacterTechniqueUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineId?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniques?: CharacterTechniqueUncheckedUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type ResourcesUpsertWithoutUserInput = {
    update: XOR<ResourcesUpdateWithoutUserInput, ResourcesUncheckedUpdateWithoutUserInput>
    create: XOR<ResourcesCreateWithoutUserInput, ResourcesUncheckedCreateWithoutUserInput>
    where?: ResourcesWhereInput
  }

  export type ResourcesUpdateToOneWithWhereWithoutUserInput = {
    where?: ResourcesWhereInput
    data: XOR<ResourcesUpdateWithoutUserInput, ResourcesUncheckedUpdateWithoutUserInput>
  }

  export type ResourcesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourcesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    gold?: BigIntFieldUpdateOperationsInput | bigint | number
    materials?: JsonNullValueInput | InputJsonValue
    pills?: JsonNullValueInput | InputJsonValue
    herbs?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutUserInput, InventoryItemUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryItemCreateWithoutUserInput, InventoryItemUncheckedCreateWithoutUserInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutUserInput, InventoryItemUncheckedUpdateWithoutUserInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutUserInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    userId?: StringFilter<"InventoryItem"> | string
    itemId?: StringFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    metadata?: JsonFilter<"InventoryItem">
    acquiredAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type CultivationProgressUpsertWithoutUserInput = {
    update: XOR<CultivationProgressUpdateWithoutUserInput, CultivationProgressUncheckedUpdateWithoutUserInput>
    create: XOR<CultivationProgressCreateWithoutUserInput, CultivationProgressUncheckedCreateWithoutUserInput>
    where?: CultivationProgressWhereInput
  }

  export type CultivationProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: CultivationProgressWhereInput
    data: XOR<CultivationProgressUpdateWithoutUserInput, CultivationProgressUncheckedUpdateWithoutUserInput>
  }

  export type CultivationProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentTechnique?: CultivationTechniqueUpdateOneWithoutUserProgressNestedInput
  }

  export type CultivationProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentTechniqueId?: NullableStringFieldUpdateOperationsInput | string | null
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatStatsUpsertWithoutUserInput = {
    update: XOR<CombatStatsUpdateWithoutUserInput, CombatStatsUncheckedUpdateWithoutUserInput>
    create: XOR<CombatStatsCreateWithoutUserInput, CombatStatsUncheckedCreateWithoutUserInput>
    where?: CombatStatsWhereInput
  }

  export type CombatStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: CombatStatsWhereInput
    data: XOR<CombatStatsUpdateWithoutUserInput, CombatStatsUncheckedUpdateWithoutUserInput>
  }

  export type CombatStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    attack?: IntFieldUpdateOperationsInput | number
    defense?: IntFieldUpdateOperationsInput | number
    speed?: IntFieldUpdateOperationsInput | number
    criticalChance?: FloatFieldUpdateOperationsInput | number
    criticalDamage?: FloatFieldUpdateOperationsInput | number
    combatExperience?: BigIntFieldUpdateOperationsInput | bigint | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    draws?: IntFieldUpdateOperationsInput | number
    lastCombatAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberUpsertWithoutUserInput = {
    update: XOR<SectMemberUpdateWithoutUserInput, SectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<SectMemberCreateWithoutUserInput, SectMemberUncheckedCreateWithoutUserInput>
    where?: SectMemberWhereInput
  }

  export type SectMemberUpdateToOneWithWhereWithoutUserInput = {
    where?: SectMemberWhereInput
    data: XOR<SectMemberUpdateWithoutUserInput, SectMemberUncheckedUpdateWithoutUserInput>
  }

  export type SectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sect?: SectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectId?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    isCompleted?: BoolFilter<"UserAchievement"> | boolean
    completedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
  }

  export type GameStatisticsUpsertWithoutUserInput = {
    update: XOR<GameStatisticsUpdateWithoutUserInput, GameStatisticsUncheckedUpdateWithoutUserInput>
    create: XOR<GameStatisticsCreateWithoutUserInput, GameStatisticsUncheckedCreateWithoutUserInput>
    where?: GameStatisticsWhereInput
  }

  export type GameStatisticsUpdateToOneWithWhereWithoutUserInput = {
    where?: GameStatisticsWhereInput
    data: XOR<GameStatisticsUpdateWithoutUserInput, GameStatisticsUncheckedUpdateWithoutUserInput>
  }

  export type GameStatisticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatisticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPlayTime?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationTime?: BigIntFieldUpdateOperationsInput | bigint | number
    combatWins?: IntFieldUpdateOperationsInput | number
    combatLosses?: IntFieldUpdateOperationsInput | number
    itemsCrafted?: IntFieldUpdateOperationsInput | number
    achievementsUnlocked?: IntFieldUpdateOperationsInput | number
    realmBreakthroughs?: IntFieldUpdateOperationsInput | number
    sectContribution?: BigIntFieldUpdateOperationsInput | bigint | number
    resourcesEarned?: JsonNullValueInput | InputJsonValue
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventUpsertWithWhereUniqueWithoutUserInput = {
    where: GameEventWhereUniqueInput
    update: XOR<GameEventUpdateWithoutUserInput, GameEventUncheckedUpdateWithoutUserInput>
    create: XOR<GameEventCreateWithoutUserInput, GameEventUncheckedCreateWithoutUserInput>
  }

  export type GameEventUpdateWithWhereUniqueWithoutUserInput = {
    where: GameEventWhereUniqueInput
    data: XOR<GameEventUpdateWithoutUserInput, GameEventUncheckedUpdateWithoutUserInput>
  }

  export type GameEventUpdateManyWithWhereWithoutUserInput = {
    where: GameEventScalarWhereInput
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyWithoutUserInput>
  }

  export type GameEventScalarWhereInput = {
    AND?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    OR?: GameEventScalarWhereInput[]
    NOT?: GameEventScalarWhereInput | GameEventScalarWhereInput[]
    id?: StringFilter<"GameEvent"> | string
    userId?: StringFilter<"GameEvent"> | string
    type?: EnumGameEventTypeFilter<"GameEvent"> | $Enums.GameEventType
    data?: JsonFilter<"GameEvent">
    processed?: BoolFilter<"GameEvent"> | boolean
    createdAt?: DateTimeFilter<"GameEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
  }

  export type CombatLogUpsertWithWhereUniqueWithoutUserInput = {
    where: CombatLogWhereUniqueInput
    update: XOR<CombatLogUpdateWithoutUserInput, CombatLogUncheckedUpdateWithoutUserInput>
    create: XOR<CombatLogCreateWithoutUserInput, CombatLogUncheckedCreateWithoutUserInput>
  }

  export type CombatLogUpdateWithWhereUniqueWithoutUserInput = {
    where: CombatLogWhereUniqueInput
    data: XOR<CombatLogUpdateWithoutUserInput, CombatLogUncheckedUpdateWithoutUserInput>
  }

  export type CombatLogUpdateManyWithWhereWithoutUserInput = {
    where: CombatLogScalarWhereInput
    data: XOR<CombatLogUpdateManyMutationInput, CombatLogUncheckedUpdateManyWithoutUserInput>
  }

  export type CombatLogScalarWhereInput = {
    AND?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
    OR?: CombatLogScalarWhereInput[]
    NOT?: CombatLogScalarWhereInput | CombatLogScalarWhereInput[]
    id?: StringFilter<"CombatLog"> | string
    userId?: StringFilter<"CombatLog"> | string
    opponentName?: StringFilter<"CombatLog"> | string
    result?: EnumCombatResultFilter<"CombatLog"> | $Enums.CombatResult
    duration?: IntFilter<"CombatLog"> | number
    damageDealt?: IntFilter<"CombatLog"> | number
    damageReceived?: IntFilter<"CombatLog"> | number
    experienceGained?: BigIntFilter<"CombatLog"> | bigint | number
    lootGained?: JsonFilter<"CombatLog">
    combatDetails?: JsonFilter<"CombatLog">
    foughtAt?: DateTimeFilter<"CombatLog"> | Date | string
  }

  export type UserCreateWithoutCharacterInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCharacterInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCharacterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
  }

  export type BloodlineCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    rarity?: $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BloodlineUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    rarity?: $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BloodlineCreateOrConnectWithoutCharactersInput = {
    where: BloodlineWhereUniqueInput
    create: XOR<BloodlineCreateWithoutCharactersInput, BloodlineUncheckedCreateWithoutCharactersInput>
  }

  export type CharacterTechniqueCreateWithoutCharacterInput = {
    id?: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
    technique: CultivationTechniqueCreateNestedOneWithoutCharacterTechniquesInput
  }

  export type CharacterTechniqueUncheckedCreateWithoutCharacterInput = {
    id?: string
    techniqueId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CharacterTechniqueCreateOrConnectWithoutCharacterInput = {
    where: CharacterTechniqueWhereUniqueInput
    create: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterTechniqueCreateManyCharacterInputEnvelope = {
    data: CharacterTechniqueCreateManyCharacterInput | CharacterTechniqueCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterTalentCreateWithoutCharacterInput = {
    id?: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    talent: TalentCreateNestedOneWithoutCharacterTalentsInput
  }

  export type CharacterTalentUncheckedCreateWithoutCharacterInput = {
    id?: string
    talentId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTalentCreateOrConnectWithoutCharacterInput = {
    where: CharacterTalentWhereUniqueInput
    create: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterTalentCreateManyCharacterInputEnvelope = {
    data: CharacterTalentCreateManyCharacterInput | CharacterTalentCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCharacterInput = {
    update: XOR<UserUpdateWithoutCharacterInput, UserUncheckedUpdateWithoutCharacterInput>
    create: XOR<UserCreateWithoutCharacterInput, UserUncheckedCreateWithoutCharacterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharacterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharacterInput, UserUncheckedUpdateWithoutCharacterInput>
  }

  export type UserUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BloodlineUpsertWithoutCharactersInput = {
    update: XOR<BloodlineUpdateWithoutCharactersInput, BloodlineUncheckedUpdateWithoutCharactersInput>
    create: XOR<BloodlineCreateWithoutCharactersInput, BloodlineUncheckedCreateWithoutCharactersInput>
    where?: BloodlineWhereInput
  }

  export type BloodlineUpdateToOneWithWhereWithoutCharactersInput = {
    where?: BloodlineWhereInput
    data: XOR<BloodlineUpdateWithoutCharactersInput, BloodlineUncheckedUpdateWithoutCharactersInput>
  }

  export type BloodlineUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BloodlineUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    abilities?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterTechniqueWhereUniqueInput
    update: XOR<CharacterTechniqueUpdateWithoutCharacterInput, CharacterTechniqueUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterTechniqueCreateWithoutCharacterInput, CharacterTechniqueUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterTechniqueUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterTechniqueWhereUniqueInput
    data: XOR<CharacterTechniqueUpdateWithoutCharacterInput, CharacterTechniqueUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterTechniqueUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterTechniqueScalarWhereInput
    data: XOR<CharacterTechniqueUpdateManyMutationInput, CharacterTechniqueUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterTechniqueScalarWhereInput = {
    AND?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
    OR?: CharacterTechniqueScalarWhereInput[]
    NOT?: CharacterTechniqueScalarWhereInput | CharacterTechniqueScalarWhereInput[]
    id?: StringFilter<"CharacterTechnique"> | string
    characterId?: StringFilter<"CharacterTechnique"> | string
    techniqueId?: StringFilter<"CharacterTechnique"> | string
    proficiency?: FloatFilter<"CharacterTechnique"> | number
    level?: IntFilter<"CharacterTechnique"> | number
    experience?: BigIntFilter<"CharacterTechnique"> | bigint | number
    masteryBonus?: FloatFilter<"CharacterTechnique"> | number
    learnedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
    lastUsedAt?: DateTimeFilter<"CharacterTechnique"> | Date | string
  }

  export type CharacterTalentUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterTalentWhereUniqueInput
    update: XOR<CharacterTalentUpdateWithoutCharacterInput, CharacterTalentUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterTalentCreateWithoutCharacterInput, CharacterTalentUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterTalentUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterTalentWhereUniqueInput
    data: XOR<CharacterTalentUpdateWithoutCharacterInput, CharacterTalentUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterTalentUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterTalentScalarWhereInput
    data: XOR<CharacterTalentUpdateManyMutationInput, CharacterTalentUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterTalentScalarWhereInput = {
    AND?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
    OR?: CharacterTalentScalarWhereInput[]
    NOT?: CharacterTalentScalarWhereInput | CharacterTalentScalarWhereInput[]
    id?: StringFilter<"CharacterTalent"> | string
    characterId?: StringFilter<"CharacterTalent"> | string
    talentId?: StringFilter<"CharacterTalent"> | string
    isUnlocked?: BoolFilter<"CharacterTalent"> | boolean
    unlockedAt?: DateTimeNullableFilter<"CharacterTalent"> | Date | string | null
  }

  export type UserCreateWithoutCultivationInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCultivationInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCultivationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultivationInput, UserUncheckedCreateWithoutCultivationInput>
  }

  export type CultivationTechniqueCreateWithoutUserProgressInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characterTechniques?: CharacterTechniqueCreateNestedManyWithoutTechniqueInput
  }

  export type CultivationTechniqueUncheckedCreateWithoutUserProgressInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characterTechniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutTechniqueInput
  }

  export type CultivationTechniqueCreateOrConnectWithoutUserProgressInput = {
    where: CultivationTechniqueWhereUniqueInput
    create: XOR<CultivationTechniqueCreateWithoutUserProgressInput, CultivationTechniqueUncheckedCreateWithoutUserProgressInput>
  }

  export type UserUpsertWithoutCultivationInput = {
    update: XOR<UserUpdateWithoutCultivationInput, UserUncheckedUpdateWithoutCultivationInput>
    create: XOR<UserCreateWithoutCultivationInput, UserUncheckedCreateWithoutCultivationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCultivationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCultivationInput, UserUncheckedUpdateWithoutCultivationInput>
  }

  export type UserUpdateWithoutCultivationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCultivationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CultivationTechniqueUpsertWithoutUserProgressInput = {
    update: XOR<CultivationTechniqueUpdateWithoutUserProgressInput, CultivationTechniqueUncheckedUpdateWithoutUserProgressInput>
    create: XOR<CultivationTechniqueCreateWithoutUserProgressInput, CultivationTechniqueUncheckedCreateWithoutUserProgressInput>
    where?: CultivationTechniqueWhereInput
  }

  export type CultivationTechniqueUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: CultivationTechniqueWhereInput
    data: XOR<CultivationTechniqueUpdateWithoutUserProgressInput, CultivationTechniqueUncheckedUpdateWithoutUserProgressInput>
  }

  export type CultivationTechniqueUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterTechniques?: CharacterTechniqueUpdateManyWithoutTechniqueNestedInput
  }

  export type CultivationTechniqueUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characterTechniques?: CharacterTechniqueUncheckedUpdateManyWithoutTechniqueNestedInput
  }

  export type CultivationProgressCreateWithoutCurrentTechniqueInput = {
    id?: string
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCultivationInput
  }

  export type CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput = {
    id?: string
    userId: string
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultivationProgressCreateOrConnectWithoutCurrentTechniqueInput = {
    where: CultivationProgressWhereUniqueInput
    create: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput>
  }

  export type CultivationProgressCreateManyCurrentTechniqueInputEnvelope = {
    data: CultivationProgressCreateManyCurrentTechniqueInput | CultivationProgressCreateManyCurrentTechniqueInput[]
    skipDuplicates?: boolean
  }

  export type CharacterTechniqueCreateWithoutTechniqueInput = {
    id?: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
    character: CharacterCreateNestedOneWithoutTechniquesInput
  }

  export type CharacterTechniqueUncheckedCreateWithoutTechniqueInput = {
    id?: string
    characterId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CharacterTechniqueCreateOrConnectWithoutTechniqueInput = {
    where: CharacterTechniqueWhereUniqueInput
    create: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput>
  }

  export type CharacterTechniqueCreateManyTechniqueInputEnvelope = {
    data: CharacterTechniqueCreateManyTechniqueInput | CharacterTechniqueCreateManyTechniqueInput[]
    skipDuplicates?: boolean
  }

  export type CultivationProgressUpsertWithWhereUniqueWithoutCurrentTechniqueInput = {
    where: CultivationProgressWhereUniqueInput
    update: XOR<CultivationProgressUpdateWithoutCurrentTechniqueInput, CultivationProgressUncheckedUpdateWithoutCurrentTechniqueInput>
    create: XOR<CultivationProgressCreateWithoutCurrentTechniqueInput, CultivationProgressUncheckedCreateWithoutCurrentTechniqueInput>
  }

  export type CultivationProgressUpdateWithWhereUniqueWithoutCurrentTechniqueInput = {
    where: CultivationProgressWhereUniqueInput
    data: XOR<CultivationProgressUpdateWithoutCurrentTechniqueInput, CultivationProgressUncheckedUpdateWithoutCurrentTechniqueInput>
  }

  export type CultivationProgressUpdateManyWithWhereWithoutCurrentTechniqueInput = {
    where: CultivationProgressScalarWhereInput
    data: XOR<CultivationProgressUpdateManyMutationInput, CultivationProgressUncheckedUpdateManyWithoutCurrentTechniqueInput>
  }

  export type CultivationProgressScalarWhereInput = {
    AND?: CultivationProgressScalarWhereInput | CultivationProgressScalarWhereInput[]
    OR?: CultivationProgressScalarWhereInput[]
    NOT?: CultivationProgressScalarWhereInput | CultivationProgressScalarWhereInput[]
    id?: StringFilter<"CultivationProgress"> | string
    userId?: StringFilter<"CultivationProgress"> | string
    currentTechniqueId?: StringNullableFilter<"CultivationProgress"> | string | null
    qiAmount?: BigIntFilter<"CultivationProgress"> | bigint | number
    qiCapacity?: BigIntFilter<"CultivationProgress"> | bigint | number
    cultivationSpeed?: FloatFilter<"CultivationProgress"> | number
    bottleneckProgress?: FloatFilter<"CultivationProgress"> | number
    breakthroughAttempts?: IntFilter<"CultivationProgress"> | number
    stabilityPercentage?: FloatFilter<"CultivationProgress"> | number
    isSessionActive?: BoolFilter<"CultivationProgress"> | boolean
    sessionStartTime?: DateTimeNullableFilter<"CultivationProgress"> | Date | string | null
    sessionDuration?: IntFilter<"CultivationProgress"> | number
    sessionQiGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    sessionExpGained?: BigIntFilter<"CultivationProgress"> | bigint | number
    lastCalculatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    createdAt?: DateTimeFilter<"CultivationProgress"> | Date | string
    updatedAt?: DateTimeFilter<"CultivationProgress"> | Date | string
  }

  export type CharacterTechniqueUpsertWithWhereUniqueWithoutTechniqueInput = {
    where: CharacterTechniqueWhereUniqueInput
    update: XOR<CharacterTechniqueUpdateWithoutTechniqueInput, CharacterTechniqueUncheckedUpdateWithoutTechniqueInput>
    create: XOR<CharacterTechniqueCreateWithoutTechniqueInput, CharacterTechniqueUncheckedCreateWithoutTechniqueInput>
  }

  export type CharacterTechniqueUpdateWithWhereUniqueWithoutTechniqueInput = {
    where: CharacterTechniqueWhereUniqueInput
    data: XOR<CharacterTechniqueUpdateWithoutTechniqueInput, CharacterTechniqueUncheckedUpdateWithoutTechniqueInput>
  }

  export type CharacterTechniqueUpdateManyWithWhereWithoutTechniqueInput = {
    where: CharacterTechniqueScalarWhereInput
    data: XOR<CharacterTechniqueUpdateManyMutationInput, CharacterTechniqueUncheckedUpdateManyWithoutTechniqueInput>
  }

  export type CharacterCreateWithoutTechniquesInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharacterInput
    bloodline?: BloodlineCreateNestedOneWithoutCharactersInput
    talents?: CharacterTalentCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutTechniquesInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineId?: string | null
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    talents?: CharacterTalentUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutTechniquesInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutTechniquesInput, CharacterUncheckedCreateWithoutTechniquesInput>
  }

  export type CultivationTechniqueCreateWithoutCharacterTechniquesInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: CultivationProgressCreateNestedManyWithoutCurrentTechniqueInput
  }

  export type CultivationTechniqueUncheckedCreateWithoutCharacterTechniquesInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TechniqueType
    element?: $Enums.ElementType
    minRealm?: $Enums.CultivationRealm
    minLevel?: number
    baseSpeed?: number
    qiEfficiency?: number
    stabilityBonus?: number
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: CultivationProgressUncheckedCreateNestedManyWithoutCurrentTechniqueInput
  }

  export type CultivationTechniqueCreateOrConnectWithoutCharacterTechniquesInput = {
    where: CultivationTechniqueWhereUniqueInput
    create: XOR<CultivationTechniqueCreateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedCreateWithoutCharacterTechniquesInput>
  }

  export type CharacterUpsertWithoutTechniquesInput = {
    update: XOR<CharacterUpdateWithoutTechniquesInput, CharacterUncheckedUpdateWithoutTechniquesInput>
    create: XOR<CharacterCreateWithoutTechniquesInput, CharacterUncheckedCreateWithoutTechniquesInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutTechniquesInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutTechniquesInput, CharacterUncheckedUpdateWithoutTechniquesInput>
  }

  export type CharacterUpdateWithoutTechniquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharacterNestedInput
    bloodline?: BloodlineUpdateOneWithoutCharactersNestedInput
    talents?: CharacterTalentUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutTechniquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineId?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    talents?: CharacterTalentUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CultivationTechniqueUpsertWithoutCharacterTechniquesInput = {
    update: XOR<CultivationTechniqueUpdateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedUpdateWithoutCharacterTechniquesInput>
    create: XOR<CultivationTechniqueCreateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedCreateWithoutCharacterTechniquesInput>
    where?: CultivationTechniqueWhereInput
  }

  export type CultivationTechniqueUpdateToOneWithWhereWithoutCharacterTechniquesInput = {
    where?: CultivationTechniqueWhereInput
    data: XOR<CultivationTechniqueUpdateWithoutCharacterTechniquesInput, CultivationTechniqueUncheckedUpdateWithoutCharacterTechniquesInput>
  }

  export type CultivationTechniqueUpdateWithoutCharacterTechniquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: CultivationProgressUpdateManyWithoutCurrentTechniqueNestedInput
  }

  export type CultivationTechniqueUncheckedUpdateWithoutCharacterTechniquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTechniqueTypeFieldUpdateOperationsInput | $Enums.TechniqueType
    element?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    minRealm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    minLevel?: IntFieldUpdateOperationsInput | number
    baseSpeed?: FloatFieldUpdateOperationsInput | number
    qiEfficiency?: FloatFieldUpdateOperationsInput | number
    stabilityBonus?: FloatFieldUpdateOperationsInput | number
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: CultivationProgressUncheckedUpdateManyWithoutCurrentTechniqueNestedInput
  }

  export type CharacterTalentCreateWithoutTalentInput = {
    id?: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    character: CharacterCreateNestedOneWithoutTalentsInput
  }

  export type CharacterTalentUncheckedCreateWithoutTalentInput = {
    id?: string
    characterId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTalentCreateOrConnectWithoutTalentInput = {
    where: CharacterTalentWhereUniqueInput
    create: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput>
  }

  export type CharacterTalentCreateManyTalentInputEnvelope = {
    data: CharacterTalentCreateManyTalentInput | CharacterTalentCreateManyTalentInput[]
    skipDuplicates?: boolean
  }

  export type CharacterTalentUpsertWithWhereUniqueWithoutTalentInput = {
    where: CharacterTalentWhereUniqueInput
    update: XOR<CharacterTalentUpdateWithoutTalentInput, CharacterTalentUncheckedUpdateWithoutTalentInput>
    create: XOR<CharacterTalentCreateWithoutTalentInput, CharacterTalentUncheckedCreateWithoutTalentInput>
  }

  export type CharacterTalentUpdateWithWhereUniqueWithoutTalentInput = {
    where: CharacterTalentWhereUniqueInput
    data: XOR<CharacterTalentUpdateWithoutTalentInput, CharacterTalentUncheckedUpdateWithoutTalentInput>
  }

  export type CharacterTalentUpdateManyWithWhereWithoutTalentInput = {
    where: CharacterTalentScalarWhereInput
    data: XOR<CharacterTalentUpdateManyMutationInput, CharacterTalentUncheckedUpdateManyWithoutTalentInput>
  }

  export type CharacterCreateWithoutTalentsInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharacterInput
    bloodline?: BloodlineCreateNestedOneWithoutCharactersInput
    techniques?: CharacterTechniqueCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutTalentsInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineId?: string | null
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    techniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutTalentsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutTalentsInput, CharacterUncheckedCreateWithoutTalentsInput>
  }

  export type TalentCreateWithoutCharacterTalentsInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentUncheckedCreateWithoutCharacterTalentsInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: $Enums.ItemRarity
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TalentCreateOrConnectWithoutCharacterTalentsInput = {
    where: TalentWhereUniqueInput
    create: XOR<TalentCreateWithoutCharacterTalentsInput, TalentUncheckedCreateWithoutCharacterTalentsInput>
  }

  export type CharacterUpsertWithoutTalentsInput = {
    update: XOR<CharacterUpdateWithoutTalentsInput, CharacterUncheckedUpdateWithoutTalentsInput>
    create: XOR<CharacterCreateWithoutTalentsInput, CharacterUncheckedCreateWithoutTalentsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutTalentsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutTalentsInput, CharacterUncheckedUpdateWithoutTalentsInput>
  }

  export type CharacterUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharacterNestedInput
    bloodline?: BloodlineUpdateOneWithoutCharactersNestedInput
    techniques?: CharacterTechniqueUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineId?: NullableStringFieldUpdateOperationsInput | string | null
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniques?: CharacterTechniqueUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type TalentUpsertWithoutCharacterTalentsInput = {
    update: XOR<TalentUpdateWithoutCharacterTalentsInput, TalentUncheckedUpdateWithoutCharacterTalentsInput>
    create: XOR<TalentCreateWithoutCharacterTalentsInput, TalentUncheckedCreateWithoutCharacterTalentsInput>
    where?: TalentWhereInput
  }

  export type TalentUpdateToOneWithWhereWithoutCharacterTalentsInput = {
    where?: TalentWhereInput
    data: XOR<TalentUpdateWithoutCharacterTalentsInput, TalentUncheckedUpdateWithoutCharacterTalentsInput>
  }

  export type TalentUpdateWithoutCharacterTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TalentUncheckedUpdateWithoutCharacterTalentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTalentTypeFieldUpdateOperationsInput | $Enums.TalentType
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateWithoutBloodlineInput = {
    id?: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCharacterInput
    techniques?: CharacterTechniqueCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutBloodlineInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    techniques?: CharacterTechniqueUncheckedCreateNestedManyWithoutCharacterInput
    talents?: CharacterTalentUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutBloodlineInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput>
  }

  export type CharacterCreateManyBloodlineInputEnvelope = {
    data: CharacterCreateManyBloodlineInput | CharacterCreateManyBloodlineInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutBloodlineInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutBloodlineInput, CharacterUncheckedUpdateWithoutBloodlineInput>
    create: XOR<CharacterCreateWithoutBloodlineInput, CharacterUncheckedCreateWithoutBloodlineInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutBloodlineInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutBloodlineInput, CharacterUncheckedUpdateWithoutBloodlineInput>
  }

  export type CharacterUpdateManyWithWhereWithoutBloodlineInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutBloodlineInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    userId?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    realm?: EnumCultivationRealmFilter<"Character"> | $Enums.CultivationRealm
    level?: IntFilter<"Character"> | number
    experience?: BigIntFilter<"Character"> | bigint | number
    experienceToNext?: BigIntFilter<"Character"> | bigint | number
    strength?: IntFilter<"Character"> | number
    agility?: IntFilter<"Character"> | number
    intelligence?: IntFilter<"Character"> | number
    constitution?: IntFilter<"Character"> | number
    perception?: IntFilter<"Character"> | number
    luck?: IntFilter<"Character"> | number
    spiritualElement?: EnumElementTypeFilter<"Character"> | $Enums.ElementType
    spiritualPurity?: IntFilter<"Character"> | number
    spiritualGrade?: EnumSpiritualGradeFilter<"Character"> | $Enums.SpiritualGrade
    bloodlineId?: StringNullableFilter<"Character"> | string | null
    bloodlineAwakening?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
  }

  export type UserCreateWithoutResourcesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResourcesInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
  }

  export type UserUpsertWithoutResourcesInput = {
    update: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type UserUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    user: UserCreateNestedOneWithoutInventoryInput
  }

  export type InventoryItemUncheckedCreateWithoutItemInput = {
    id?: string
    userId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemCreateManyItemInputEnvelope = {
    data: InventoryItemCreateManyItemInput | InventoryItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryItemCreateWithoutItemInput, InventoryItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutItemInput, InventoryItemUncheckedUpdateWithoutItemInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutItemInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutItemInput>
  }

  export type UserCreateWithoutInventoryInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type ItemCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.ItemType
    rarity?: $Enums.ItemRarity
    value?: number
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description: string
    type?: $Enums.ItemType
    rarity?: $Enums.ItemRarity
    value?: number
    stackable?: boolean
    tradeable?: boolean
    consumable?: boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutInventoryItemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ItemUpsertWithoutInventoryItemsInput = {
    update: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ItemCreateWithoutInventoryItemsInput, ItemUncheckedCreateWithoutInventoryItemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryItemsInput, ItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ItemUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    value?: IntFieldUpdateOperationsInput | number
    stackable?: BoolFieldUpdateOperationsInput | boolean
    tradeable?: BoolFieldUpdateOperationsInput | boolean
    consumable?: BoolFieldUpdateOperationsInput | boolean
    effects?: JsonNullValueInput | InputJsonValue
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCombatInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCombatInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCombatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCombatInput, UserUncheckedCreateWithoutCombatInput>
  }

  export type UserUpsertWithoutCombatInput = {
    update: XOR<UserUpdateWithoutCombatInput, UserUncheckedUpdateWithoutCombatInput>
    create: XOR<UserCreateWithoutCombatInput, UserUncheckedCreateWithoutCombatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCombatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCombatInput, UserUncheckedUpdateWithoutCombatInput>
  }

  export type UserUpdateWithoutCombatInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCombatInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCombatLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCombatLogsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCombatLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCombatLogsInput, UserUncheckedCreateWithoutCombatLogsInput>
  }

  export type UserUpsertWithoutCombatLogsInput = {
    update: XOR<UserUpdateWithoutCombatLogsInput, UserUncheckedUpdateWithoutCombatLogsInput>
    create: XOR<UserCreateWithoutCombatLogsInput, UserUncheckedCreateWithoutCombatLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCombatLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCombatLogsInput, UserUncheckedUpdateWithoutCombatLogsInput>
  }

  export type UserUpdateWithoutCombatLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCombatLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SectMemberCreateWithoutSectInput = {
    id?: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
    user: UserCreateNestedOneWithoutSectMembershipInput
  }

  export type SectMemberUncheckedCreateWithoutSectInput = {
    id?: string
    userId: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type SectMemberCreateOrConnectWithoutSectInput = {
    where: SectMemberWhereUniqueInput
    create: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput>
  }

  export type SectMemberCreateManySectInputEnvelope = {
    data: SectMemberCreateManySectInput | SectMemberCreateManySectInput[]
    skipDuplicates?: boolean
  }

  export type SectMemberUpsertWithWhereUniqueWithoutSectInput = {
    where: SectMemberWhereUniqueInput
    update: XOR<SectMemberUpdateWithoutSectInput, SectMemberUncheckedUpdateWithoutSectInput>
    create: XOR<SectMemberCreateWithoutSectInput, SectMemberUncheckedCreateWithoutSectInput>
  }

  export type SectMemberUpdateWithWhereUniqueWithoutSectInput = {
    where: SectMemberWhereUniqueInput
    data: XOR<SectMemberUpdateWithoutSectInput, SectMemberUncheckedUpdateWithoutSectInput>
  }

  export type SectMemberUpdateManyWithWhereWithoutSectInput = {
    where: SectMemberScalarWhereInput
    data: XOR<SectMemberUpdateManyMutationInput, SectMemberUncheckedUpdateManyWithoutSectInput>
  }

  export type SectMemberScalarWhereInput = {
    AND?: SectMemberScalarWhereInput | SectMemberScalarWhereInput[]
    OR?: SectMemberScalarWhereInput[]
    NOT?: SectMemberScalarWhereInput | SectMemberScalarWhereInput[]
    id?: StringFilter<"SectMember"> | string
    userId?: StringFilter<"SectMember"> | string
    sectId?: StringFilter<"SectMember"> | string
    role?: EnumSectRoleFilter<"SectMember"> | $Enums.SectRole
    contribution?: BigIntFilter<"SectMember"> | bigint | number
    permissions?: JsonFilter<"SectMember">
    joinedAt?: DateTimeFilter<"SectMember"> | Date | string
    lastActiveAt?: DateTimeFilter<"SectMember"> | Date | string
  }

  export type UserCreateWithoutSectMembershipInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSectMembershipInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSectMembershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSectMembershipInput, UserUncheckedCreateWithoutSectMembershipInput>
  }

  export type SectCreateWithoutMembersInput = {
    id?: string
    name: string
    description: string
    level?: number
    experience?: bigint | number
    leaderId: string
    spiritStones?: bigint | number
    reputation?: number
    influence?: number
    territory?: number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description: string
    level?: number
    experience?: bigint | number
    leaderId: string
    spiritStones?: bigint | number
    reputation?: number
    influence?: number
    territory?: number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectCreateOrConnectWithoutMembersInput = {
    where: SectWhereUniqueInput
    create: XOR<SectCreateWithoutMembersInput, SectUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutSectMembershipInput = {
    update: XOR<UserUpdateWithoutSectMembershipInput, UserUncheckedUpdateWithoutSectMembershipInput>
    create: XOR<UserCreateWithoutSectMembershipInput, UserUncheckedCreateWithoutSectMembershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSectMembershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSectMembershipInput, UserUncheckedUpdateWithoutSectMembershipInput>
  }

  export type UserUpdateWithoutSectMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSectMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SectUpsertWithoutMembersInput = {
    update: XOR<SectUpdateWithoutMembersInput, SectUncheckedUpdateWithoutMembersInput>
    create: XOR<SectCreateWithoutMembersInput, SectUncheckedCreateWithoutMembersInput>
    where?: SectWhereInput
  }

  export type SectUpdateToOneWithWhereWithoutMembersInput = {
    where?: SectWhereInput
    data: XOR<SectUpdateWithoutMembersInput, SectUncheckedUpdateWithoutMembersInput>
  }

  export type SectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    leaderId?: StringFieldUpdateOperationsInput | string
    spiritStones?: BigIntFieldUpdateOperationsInput | bigint | number
    reputation?: IntFieldUpdateOperationsInput | number
    influence?: IntFieldUpdateOperationsInput | number
    territory?: IntFieldUpdateOperationsInput | number
    buildings?: JsonNullValueInput | InputJsonValue
    alliances?: JsonNullValueInput | InputJsonValue
    enemies?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    category?: $Enums.AchievementCategory
    maxProgress?: number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    category?: $Enums.AchievementCategory
    maxProgress?: number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    maxProgress?: IntFieldUpdateOperationsInput | number
    rewards?: JsonNullValueInput | InputJsonValue
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutStatisticsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    gameEvents?: GameEventCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatisticsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    gameEvents?: GameEventUncheckedCreateNestedManyWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatisticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatisticsInput, UserUncheckedCreateWithoutStatisticsInput>
  }

  export type UserUpsertWithoutStatisticsInput = {
    update: XOR<UserUpdateWithoutStatisticsInput, UserUncheckedUpdateWithoutStatisticsInput>
    create: XOR<UserCreateWithoutStatisticsInput, UserUncheckedCreateWithoutStatisticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatisticsInput, UserUncheckedUpdateWithoutStatisticsInput>
  }

  export type UserUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    gameEvents?: GameEventUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    gameEvents?: GameEventUncheckedUpdateManyWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGameEventsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterCreateNestedOneWithoutUserInput
    resources?: ResourcesCreateNestedOneWithoutUserInput
    inventory?: InventoryItemCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressCreateNestedOneWithoutUserInput
    combat?: CombatStatsCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsCreateNestedOneWithoutUserInput
    combatLogs?: CombatLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameEventsInput = {
    id?: string
    username: string
    email: string
    passwordHash: string
    displayName: string
    avatar?: string | null
    title?: string | null
    biography?: string | null
    autoSave?: boolean
    notifications?: boolean
    soundEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActiveAt?: Date | string
    character?: CharacterUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourcesUncheckedCreateNestedOneWithoutUserInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutUserInput
    cultivation?: CultivationProgressUncheckedCreateNestedOneWithoutUserInput
    combat?: CombatStatsUncheckedCreateNestedOneWithoutUserInput
    sectMembership?: SectMemberUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    statistics?: GameStatisticsUncheckedCreateNestedOneWithoutUserInput
    combatLogs?: CombatLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameEventsInput, UserUncheckedCreateWithoutGameEventsInput>
  }

  export type UserUpsertWithoutGameEventsInput = {
    update: XOR<UserUpdateWithoutGameEventsInput, UserUncheckedUpdateWithoutGameEventsInput>
    create: XOR<UserCreateWithoutGameEventsInput, UserUncheckedCreateWithoutGameEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameEventsInput, UserUncheckedUpdateWithoutGameEventsInput>
  }

  export type UserUpdateWithoutGameEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutUserNestedInput
    resources?: ResourcesUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUpdateOneWithoutUserNestedInput
    combatLogs?: CombatLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    notifications?: BoolFieldUpdateOperationsInput | boolean
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourcesUncheckedUpdateOneWithoutUserNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutUserNestedInput
    cultivation?: CultivationProgressUncheckedUpdateOneWithoutUserNestedInput
    combat?: CombatStatsUncheckedUpdateOneWithoutUserNestedInput
    sectMembership?: SectMemberUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    statistics?: GameStatisticsUncheckedUpdateOneWithoutUserNestedInput
    combatLogs?: CombatLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventoryItemCreateManyUserInput = {
    id?: string
    itemId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type GameEventCreateManyUserInput = {
    id?: string
    type?: $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type CombatLogCreateManyUserInput = {
    id?: string
    opponentName: string
    result?: $Enums.CombatResult
    duration?: number
    damageDealt?: number
    damageReceived?: number
    experienceGained?: bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: Date | string
  }

  export type InventoryItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumGameEventTypeFieldUpdateOperationsInput | $Enums.GameEventType
    data?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CombatLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opponentName?: StringFieldUpdateOperationsInput | string
    result?: EnumCombatResultFieldUpdateOperationsInput | $Enums.CombatResult
    duration?: IntFieldUpdateOperationsInput | number
    damageDealt?: IntFieldUpdateOperationsInput | number
    damageReceived?: IntFieldUpdateOperationsInput | number
    experienceGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lootGained?: JsonNullValueInput | InputJsonValue
    combatDetails?: JsonNullValueInput | InputJsonValue
    foughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueCreateManyCharacterInput = {
    id?: string
    techniqueId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CharacterTalentCreateManyCharacterInput = {
    id?: string
    talentId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTechniqueUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technique?: CultivationTechniqueUpdateOneRequiredWithoutCharacterTechniquesNestedInput
  }

  export type CharacterTechniqueUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTalentUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    talent?: TalentUpdateOneRequiredWithoutCharacterTalentsNestedInput
  }

  export type CharacterTalentUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterTalentUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    talentId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CultivationProgressCreateManyCurrentTechniqueInput = {
    id?: string
    userId: string
    qiAmount?: bigint | number
    qiCapacity?: bigint | number
    cultivationSpeed?: number
    bottleneckProgress?: number
    breakthroughAttempts?: number
    stabilityPercentage?: number
    isSessionActive?: boolean
    sessionStartTime?: Date | string | null
    sessionDuration?: number
    sessionQiGained?: bigint | number
    sessionExpGained?: bigint | number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterTechniqueCreateManyTechniqueInput = {
    id?: string
    characterId: string
    proficiency?: number
    level?: number
    experience?: bigint | number
    masteryBonus?: number
    learnedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type CultivationProgressUpdateWithoutCurrentTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCultivationNestedInput
  }

  export type CultivationProgressUncheckedUpdateWithoutCurrentTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultivationProgressUncheckedUpdateManyWithoutCurrentTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    qiAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    qiCapacity?: BigIntFieldUpdateOperationsInput | bigint | number
    cultivationSpeed?: FloatFieldUpdateOperationsInput | number
    bottleneckProgress?: FloatFieldUpdateOperationsInput | number
    breakthroughAttempts?: IntFieldUpdateOperationsInput | number
    stabilityPercentage?: FloatFieldUpdateOperationsInput | number
    isSessionActive?: BoolFieldUpdateOperationsInput | boolean
    sessionStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionDuration?: IntFieldUpdateOperationsInput | number
    sessionQiGained?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionExpGained?: BigIntFieldUpdateOperationsInput | bigint | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueUpdateWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutTechniquesNestedInput
  }

  export type CharacterTechniqueUncheckedUpdateWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTechniqueUncheckedUpdateManyWithoutTechniqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    proficiency?: FloatFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    masteryBonus?: FloatFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterTalentCreateManyTalentInput = {
    id?: string
    characterId: string
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
  }

  export type CharacterTalentUpdateWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    character?: CharacterUpdateOneRequiredWithoutTalentsNestedInput
  }

  export type CharacterTalentUncheckedUpdateWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterTalentUncheckedUpdateManyWithoutTalentInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CharacterCreateManyBloodlineInput = {
    id?: string
    userId: string
    name: string
    realm?: $Enums.CultivationRealm
    level?: number
    experience?: bigint | number
    experienceToNext?: bigint | number
    strength?: number
    agility?: number
    intelligence?: number
    constitution?: number
    perception?: number
    luck?: number
    spiritualElement?: $Enums.ElementType
    spiritualPurity?: number
    spiritualGrade?: $Enums.SpiritualGrade
    bloodlineAwakening?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutBloodlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCharacterNestedInput
    techniques?: CharacterTechniqueUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutBloodlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    techniques?: CharacterTechniqueUncheckedUpdateManyWithoutCharacterNestedInput
    talents?: CharacterTalentUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutBloodlineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    realm?: EnumCultivationRealmFieldUpdateOperationsInput | $Enums.CultivationRealm
    level?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    experienceToNext?: BigIntFieldUpdateOperationsInput | bigint | number
    strength?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    constitution?: IntFieldUpdateOperationsInput | number
    perception?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    spiritualElement?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    spiritualPurity?: IntFieldUpdateOperationsInput | number
    spiritualGrade?: EnumSpiritualGradeFieldUpdateOperationsInput | $Enums.SpiritualGrade
    bloodlineAwakening?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyItemInput = {
    id?: string
    userId: string
    quantity?: number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
  }

  export type InventoryItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberCreateManySectInput = {
    id?: string
    userId: string
    role?: $Enums.SectRole
    contribution?: bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: Date | string
    lastActiveAt?: Date | string
  }

  export type SectMemberUpdateWithoutSectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSectMembershipNestedInput
  }

  export type SectMemberUncheckedUpdateWithoutSectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectMemberUncheckedUpdateManyWithoutSectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumSectRoleFieldUpdateOperationsInput | $Enums.SectRole
    contribution?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: JsonNullValueInput | InputJsonValue
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    progress?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}